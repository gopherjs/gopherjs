// Code generated by golang.org/x/tools/cmd/bundle.
//go:generate bundle -o cmdgo_bundle.go -prefix cmdgo_ -import github.com/gopherjs/go/internal/singleflight=github.com/gopherjs/gopherjs/internal/singleflight github.com/gopherjs/go/cmd/go

// Go is a tool for managing Go source code.
//
// Usage:
//
// 	go command [arguments]
//
// The commands are:
//
// 	build       compile packages and dependencies
// 	clean       remove object files
// 	doc         show documentation for package or symbol
// 	env         print Go environment information
// 	fix         run go tool fix on packages
// 	fmt         run gofmt on package sources
// 	generate    generate Go files by processing source
// 	get         download and install packages and dependencies
// 	install     compile and install packages and dependencies
// 	list        list packages
// 	run         compile and run Go program
// 	test        test packages
// 	tool        run specified go tool
// 	version     print Go version
// 	vet         run go tool vet on packages
//
// Use "go help [command]" for more information about a command.
//
// Additional help topics:
//
// 	c           calling between Go and C
// 	buildmode   description of build modes
// 	filetype    file types
// 	gopath      GOPATH environment variable
// 	environment environment variables
// 	importpath  import path syntax
// 	packages    description of package lists
// 	testflag    description of testing flags
// 	testfunc    description of testing functions
//
// Use "go help [topic]" for more information about that topic.
//
// Compile packages and dependencies
//
// Usage:
//
// 	go build [-o output] [-i] [build flags] [packages]
//
// Build compiles the packages named by the import paths,
// along with their dependencies, but it does not install the results.
//
// If the arguments to build are a list of .go files, build treats
// them as a list of source files specifying a single package.
//
// When compiling a single main package, build writes
// the resulting executable to an output file named after
// the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')
// or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').
// The '.exe' suffix is added when writing a Windows executable.
//
// When compiling multiple packages or a single non-main package,
// build compiles the packages but discards the resulting object,
// serving only as a check that the packages can be built.
//
// When compiling packages, build ignores files that end in '_test.go'.
//
// The -o flag, only allowed when compiling a single package,
// forces build to write the resulting executable or object
// to the named output file, instead of the default behavior described
// in the last two paragraphs.
//
// The -i flag installs the packages that are dependencies of the target.
//
// The build flags are shared by the build, clean, get, install, list, run,
// and test commands:
//
// 	-a
// 		force rebuilding of packages that are already up-to-date.
// 	-n
// 		print the commands but do not run them.
// 	-p n
// 		the number of programs, such as build commands or
// 		test binaries, that can be run in parallel.
// 		The default is the number of CPUs available.
// 	-race
// 		enable data race detection.
// 		Supported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.
// 	-msan
// 		enable interoperation with memory sanitizer.
// 		Supported only on linux/amd64,
// 		and only with Clang/LLVM as the host C compiler.
// 	-v
// 		print the names of packages as they are compiled.
// 	-work
// 		print the name of the temporary work directory and
// 		do not delete it when exiting.
// 	-x
// 		print the commands.
//
// 	-asmflags 'flag list'
// 		arguments to pass on each go tool asm invocation.
// 	-buildmode mode
// 		build mode to use. See 'go help buildmode' for more.
// 	-compiler name
// 		name of compiler to use, as in runtime.Compiler (gccgo, gc or gopherjs).
// 	-gccgoflags 'arg list'
// 		arguments to pass on each gccgo compiler/linker invocation.
// 	-gcflags 'arg list'
// 		arguments to pass on each go tool compile invocation.
// 	-installsuffix suffix
// 		a suffix to use in the name of the package installation directory,
// 		in order to keep output separate from default builds.
// 		If using the -race flag, the install suffix is automatically set to race
// 		or, if set explicitly, has _race appended to it.  Likewise for the -msan
// 		flag.  Using a -buildmode option that requires non-default compile flags
// 		has a similar effect.
// 	-ldflags 'flag list'
// 		arguments to pass on each go tool link invocation.
// 	-linkshared
// 		link against shared libraries previously created with
// 		-buildmode=shared.
// 	-pkgdir dir
// 		install and load all packages from dir instead of the usual locations.
// 		For example, when building with a non-standard configuration,
// 		use -pkgdir to keep generated packages in a separate location.
// 	-tags 'tag list'
// 		a list of build tags to consider satisfied during the build.
// 		For more information about build tags, see the description of
// 		build constraints in the documentation for the go/build package.
// 	-toolexec 'cmd args'
// 		a program to use to invoke toolchain programs like vet and asm.
// 		For example, instead of running asm, the go command will run
// 		'cmd args /path/to/asm <arguments for asm>'.
//
// The list flags accept a space-separated list of strings. To embed spaces
// in an element in the list, surround it with either single or double quotes.
//
// For more about specifying packages, see 'go help packages'.
// For more about where packages and binaries are installed,
// run 'go help gopath'.
// For more about calling between Go and C/C++, run 'go help c'.
//
// Note: Build adheres to certain conventions such as those described
// by 'go help gopath'. Not all projects can follow these conventions,
// however. Installations that have their own conventions or that use
// a separate software build system may choose to use lower-level
// invocations such as 'go tool compile' and 'go tool link' to avoid
// some of the overheads and design decisions of the build tool.
//
// See also: go install, go get, go clean.
//
// Remove object files
//
// Usage:
//
// 	go clean [-i] [-r] [-n] [-x] [build flags] [packages]
//
// Clean removes object files from package source directories.
// The go command builds most objects in a temporary directory,
// so go clean is mainly concerned with object files left by other
// tools or by manual invocations of go build.
//
// Specifically, clean removes the following files from each of the
// source directories corresponding to the import paths:
//
// 	_obj/            old object directory, left from Makefiles
// 	_test/           old test directory, left from Makefiles
// 	_testmain.go     old gotest file, left from Makefiles
// 	test.out         old test log, left from Makefiles
// 	build.out        old test log, left from Makefiles
// 	*.[568ao]        object files, left from Makefiles
//
// 	DIR(.exe)        from go build
// 	DIR.test(.exe)   from go test -c
// 	MAINFILE(.exe)   from go build MAINFILE.go
// 	*.so             from SWIG
//
// In the list, DIR represents the final path element of the
// directory, and MAINFILE is the base name of any Go source
// file in the directory that is not included when building
// the package.
//
// The -i flag causes clean to remove the corresponding installed
// archive or binary (what 'go install' would create).
//
// The -n flag causes clean to print the remove commands it would execute,
// but not run them.
//
// The -r flag causes clean to be applied recursively to all the
// dependencies of the packages named by the import paths.
//
// The -x flag causes clean to print remove commands as it executes them.
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
// Show documentation for package or symbol
//
// Usage:
//
// 	go doc [-u] [-c] [package|[package.]symbol[.method]]
//
// Doc prints the documentation comments associated with the item identified by its
// arguments (a package, const, func, type, var, or method) followed by a one-line
// summary of each of the first-level items "under" that item (package-level
// declarations for a package, methods for a type, etc.).
//
// Doc accepts zero, one, or two arguments.
//
// Given no arguments, that is, when run as
//
// 	go doc
//
// it prints the package documentation for the package in the current directory.
// If the package is a command (package main), the exported symbols of the package
// are elided from the presentation unless the -cmd flag is provided.
//
// When run with one argument, the argument is treated as a Go-syntax-like
// representation of the item to be documented. What the argument selects depends
// on what is installed in GOROOT and GOPATH, as well as the form of the argument,
// which is schematically one of these:
//
// 	go doc <pkg>
// 	go doc <sym>[.<method>]
// 	go doc [<pkg>.]<sym>[.<method>]
// 	go doc [<pkg>.][<sym>.]<method>
//
// The first item in this list matched by the argument is the one whose documentation
// is printed. (See the examples below.) However, if the argument starts with a capital
// letter it is assumed to identify a symbol or method in the current directory.
//
// For packages, the order of scanning is determined lexically in breadth-first order.
// That is, the package presented is the one that matches the search and is nearest
// the root and lexically first at its level of the hierarchy.  The GOROOT tree is
// always scanned in its entirety before GOPATH.
//
// If there is no package specified or matched, the package in the current
// directory is selected, so "go doc Foo" shows the documentation for symbol Foo in
// the current package.
//
// The package path must be either a qualified path or a proper suffix of a
// path. The go tool's usual package mechanism does not apply: package path
// elements like . and ... are not implemented by go doc.
//
// When run with two arguments, the first must be a full package path (not just a
// suffix), and the second is a symbol or symbol and method; this is similar to the
// syntax accepted by godoc:
//
// 	go doc <pkg> <sym>[.<method>]
//
// In all forms, when matching symbols, lower-case letters in the argument match
// either case but upper-case letters match exactly. This means that there may be
// multiple matches of a lower-case argument in a package if different symbols have
// different cases. If this occurs, documentation for all matches is printed.
//
// Examples:
// 	go doc
// 		Show documentation for current package.
// 	go doc Foo
// 		Show documentation for Foo in the current package.
// 		(Foo starts with a capital letter so it cannot match
// 		a package path.)
// 	go doc encoding/json
// 		Show documentation for the encoding/json package.
// 	go doc json
// 		Shorthand for encoding/json.
// 	go doc json.Number (or go doc json.number)
// 		Show documentation and method summary for json.Number.
// 	go doc json.Number.Int64 (or go doc json.number.int64)
// 		Show documentation for json.Number's Int64 method.
// 	go doc cmd/doc
// 		Show package docs for the doc command.
// 	go doc -cmd cmd/doc
// 		Show package docs and exported symbols within the doc command.
// 	go doc template.new
// 		Show documentation for html/template's New function.
// 		(html/template is lexically before text/template)
// 	go doc text/template.new # One argument
// 		Show documentation for text/template's New function.
// 	go doc text/template new # Two arguments
// 		Show documentation for text/template's New function.
//
// 	At least in the current tree, these invocations all print the
// 	documentation for json.Decoder's Decode method:
//
// 	go doc json.Decoder.Decode
// 	go doc json.decoder.decode
// 	go doc json.decode
// 	cd go/src/encoding/json; go doc decode
//
// Flags:
// 	-c
// 		Respect case when matching symbols.
// 	-cmd
// 		Treat a command (package main) like a regular package.
// 		Otherwise package main's exported symbols are hidden
// 		when showing the package's top-level documentation.
// 	-u
// 		Show documentation for unexported as well as exported
// 		symbols and methods.
//
// Print Go environment information
//
// Usage:
//
// 	go env [var ...]
//
// Env prints Go environment information.
//
// By default env prints information as a shell script
// (on Windows, a batch file).  If one or more variable
// names is given as arguments,  env prints the value of
// each named variable on its own line.
//
// Run go tool fix on packages
//
// Usage:
//
// 	go fix [packages]
//
// Fix runs the Go fix command on the packages named by the import paths.
//
// For more about fix, see 'go doc cmd/fix'.
// For more about specifying packages, see 'go help packages'.
//
// To run fix with specific options, run 'go tool fix'.
//
// See also: go fmt, go vet.
//
// Run gofmt on package sources
//
// Usage:
//
// 	go fmt [-n] [-x] [packages]
//
// Fmt runs the command 'gofmt -l -w' on the packages named
// by the import paths.  It prints the names of the files that are modified.
//
// For more about gofmt, see 'go doc cmd/gofmt'.
// For more about specifying packages, see 'go help packages'.
//
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// To run gofmt with specific options, run gofmt itself.
//
// See also: go fix, go vet.
//
// Generate Go files by processing source
//
// Usage:
//
// 	go generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]
//
// Generate runs commands described by directives within existing
// files. Those commands can run any process but the intent is to
// create or update Go source files, for instance by running yacc.
//
// Go generate is never run automatically by go build, go get, go test,
// and so on. It must be run explicitly.
//
// Go generate scans the file for directives, which are lines of
// the form,
//
// 	//go:generate command argument...
//
// (note: no leading spaces and no space in "//go") where command
// is the generator to be run, corresponding to an executable file
// that can be run locally. It must either be in the shell path
// (gofmt), a fully qualified path (/usr/you/bin/mytool), or a
// command alias, described below.
//
// Note that go generate does not parse the file, so lines that look
// like directives in comments or multiline strings will be treated
// as directives.
//
// The arguments to the directive are space-separated tokens or
// double-quoted strings passed to the generator as individual
// arguments when it is run.
//
// Quoted strings use Go syntax and are evaluated before execution; a
// quoted string appears as a single argument to the generator.
//
// Go generate sets several variables when it runs the generator:
//
// 	$GOARCH
// 		The execution architecture (arm, amd64, etc.)
// 	$GOOS
// 		The execution operating system (linux, windows, etc.)
// 	$GOFILE
// 		The base name of the file.
// 	$GOLINE
// 		The line number of the directive in the source file.
// 	$GOPACKAGE
// 		The name of the package of the file containing the directive.
// 	$DOLLAR
// 		A dollar sign.
//
// Other than variable substitution and quoted-string evaluation, no
// special processing such as "globbing" is performed on the command
// line.
//
// As a last step before running the command, any invocations of any
// environment variables with alphanumeric names, such as $GOFILE or
// $HOME, are expanded throughout the command line. The syntax for
// variable expansion is $NAME on all operating systems.  Due to the
// order of evaluation, variables are expanded even inside quoted
// strings. If the variable NAME is not set, $NAME expands to the
// empty string.
//
// A directive of the form,
//
// 	//go:generate -command xxx args...
//
// specifies, for the remainder of this source file only, that the
// string xxx represents the command identified by the arguments. This
// can be used to create aliases or to handle multiword generators.
// For example,
//
// 	//go:generate -command yacc go tool yacc
//
// specifies that the command "yacc" represents the generator
// "go tool yacc".
//
// Generate processes packages in the order given on the command line,
// one at a time. If the command line lists .go files, they are treated
// as a single package. Within a package, generate processes the
// source files in a package in file name order, one at a time. Within
// a source file, generate runs generators in the order they appear
// in the file, one at a time.
//
// If any generator returns an error exit status, "go generate" skips
// all further processing for that package.
//
// The generator is run in the package's source directory.
//
// Go generate accepts one specific flag:
//
// 	-run=""
// 		if non-empty, specifies a regular expression to select
// 		directives whose full original source text (excluding
// 		any trailing spaces and final newline) matches the
// 		expression.
//
// It also accepts the standard build flags including -v, -n, and -x.
// The -v flag prints the names of packages and files as they are
// processed.
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
// Download and install packages and dependencies
//
// Usage:
//
// 	go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]
//
// Get downloads the packages named by the import paths, along with their
// dependencies. It then installs the named packages, like 'go install'.
//
// The -d flag instructs get to stop after downloading the packages; that is,
// it instructs get not to install the packages.
//
// The -f flag, valid only when -u is set, forces get -u not to verify that
// each package has been checked out from the source control repository
// implied by its import path. This can be useful if the source is a local fork
// of the original.
//
// The -fix flag instructs get to run the fix tool on the downloaded packages
// before resolving dependencies or building the code.
//
// The -insecure flag permits fetching from repositories and resolving
// custom domains using insecure schemes such as HTTP. Use with caution.
//
// The -t flag instructs get to also download the packages required to build
// the tests for the specified packages.
//
// The -u flag instructs get to use the network to update the named packages
// and their dependencies.  By default, get uses the network to check out
// missing packages but does not use it to look for updates to existing packages.
//
// Get also accepts build flags to control the installation. See 'go help build'.
//
// When checking out a new package, get creates the target directory
// GOPATH/src/<import-path>. If the GOPATH contains multiple entries,
// get uses the first one. See 'go help gopath'.
//
// When checking out or updating a package, get looks for a branch or tag
// that matches the locally installed version of Go. The most important
// rule is that if the local installation is running version "go1", get
// searches for a branch or tag named "go1". If no such version exists it
// retrieves the most recent version of the package.
//
// When go get checks out or updates a Git repository,
// it also updates any git submodules referenced by the repository.
//
// Get never checks out or updates code stored in vendor directories.
//
// For more about specifying packages, see 'go help packages'.
//
// For more about how 'go get' finds source code to
// download, see 'go help importpath'.
//
// See also: go build, go install, go clean.
//
// Compile and install packages and dependencies
//
// Usage:
//
// 	go install [build flags] [packages]
//
// Install compiles and installs the packages named by the import paths,
// along with their dependencies.
//
// For more about the build flags, see 'go help build'.
// For more about specifying packages, see 'go help packages'.
//
// See also: go build, go get, go clean.
//
// List packages
//
// Usage:
//
// 	go list [-e] [-f format] [-json] [build flags] [packages]
//
// List lists the packages named by the import paths, one per line.
//
// The default output shows the package import path:
//
//     bytes
//     encoding/json
//     github.com/gorilla/mux
//     golang.org/x/net/html
//
// The -f flag specifies an alternate format for the list, using the
// syntax of package template.  The default output is equivalent to -f
// '{{.ImportPath}}'. The struct being passed to the template is:
//
//     type Package struct {
//         Dir           string // directory containing package sources
//         ImportPath    string // import path of package in dir
//         ImportComment string // path in import comment on package statement
//         Name          string // package name
//         Doc           string // package documentation string
//         Target        string // install path
//         Shlib         string // the shared library that contains this package (only set when -linkshared)
//         Goroot        bool   // is this package in the Go root?
//         Standard      bool   // is this package part of the standard Go library?
//         Stale         bool   // would 'go install' do anything for this package?
//         StaleReason   string // explanation for Stale==true
//         Root          string // Go root or Go path dir containing this package
//         ConflictDir   string // this directory shadows Dir in $GOPATH
//         BinaryOnly    bool   // binary-only package: cannot be recompiled from sources
//
//         // Source files
//         GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
//         CgoFiles       []string // .go sources files that import "C"
//         IgnoredGoFiles []string // .go sources ignored due to build constraints
//         CFiles         []string // .c source files
//         CXXFiles       []string // .cc, .cxx and .cpp source files
//         MFiles         []string // .m source files
//         HFiles         []string // .h, .hh, .hpp and .hxx source files
//         FFiles         []string // .f, .F, .for and .f90 Fortran source files
//         SFiles         []string // .s source files
//         SwigFiles      []string // .swig files
//         SwigCXXFiles   []string // .swigcxx files
//         SysoFiles      []string // .syso object files to add to archive
//
//         // Cgo directives
//         CgoCFLAGS    []string // cgo: flags for C compiler
//         CgoCPPFLAGS  []string // cgo: flags for C preprocessor
//         CgoCXXFLAGS  []string // cgo: flags for C++ compiler
//         CgoFFLAGS    []string // cgo: flags for Fortran compiler
//         CgoLDFLAGS   []string // cgo: flags for linker
//         CgoPkgConfig []string // cgo: pkg-config names
//
//         // Dependency information
//         Imports []string // import paths used by this package
//         Deps    []string // all (recursively) imported dependencies
//
//         // Error information
//         Incomplete bool            // this package or a dependency has an error
//         Error      *PackageError   // error loading package
//         DepsErrors []*PackageError // errors loading dependencies
//
//         TestGoFiles  []string // _test.go files in package
//         TestImports  []string // imports from TestGoFiles
//         XTestGoFiles []string // _test.go files outside package
//         XTestImports []string // imports from XTestGoFiles
//     }
//
// The error information, if any, is
//
//     type PackageError struct {
//         ImportStack   []string // shortest path from package named on command line to this one
//         Pos           string   // position of error (if present, file:line:col)
//         Err           string   // the error itself
//     }
//
// The template function "join" calls strings.Join.
//
// The template function "context" returns the build context, defined as:
//
// 	type Context struct {
// 		GOARCH        string   // target architecture
// 		GOOS          string   // target operating system
// 		GOROOT        string   // Go root
// 		GOPATH        string   // Go path
// 		CgoEnabled    bool     // whether cgo can be used
// 		UseAllFiles   bool     // use files regardless of +build lines, file names
// 		Compiler      string   // compiler to assume when computing target paths
// 		BuildTags     []string // build constraints to match in +build lines
// 		ReleaseTags   []string // releases the current release is compatible with
// 		InstallSuffix string   // suffix to use in the name of the install dir
// 	}
//
// For more information about the meaning of these fields see the documentation
// for the go/build package's Context type.
//
// The -json flag causes the package data to be printed in JSON format
// instead of using the template format.
//
// The -e flag changes the handling of erroneous packages, those that
// cannot be found or are malformed.  By default, the list command
// prints an error to standard error for each erroneous package and
// omits the packages from consideration during the usual printing.
// With the -e flag, the list command never prints errors to standard
// error and instead processes the erroneous packages with the usual
// printing.  Erroneous packages will have a non-empty ImportPath and
// a non-nil Error field; other information may or may not be missing
// (zeroed).
//
// For more about build flags, see 'go help build'.
//
// For more about specifying packages, see 'go help packages'.
//
// Compile and run Go program
//
// Usage:
//
// 	go run [build flags] [-exec xprog] gofiles... [arguments...]
//
// Run compiles and runs the main package comprising the named Go source files.
// A Go source file is defined to be a file ending in a literal ".go" suffix.
//
// By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
// If the -exec flag is given, 'go run' invokes the binary using xprog:
// 	'xprog a.out arguments...'.
// If the -exec flag is not given, GOOS or GOARCH is different from the system
// default, and a program named go_$GOOS_$GOARCH_exec can be found
// on the current search path, 'go run' invokes the binary using that program,
// for example 'go_nacl_386_exec a.out arguments...'. This allows execution of
// cross-compiled programs when a simulator or other execution method is
// available.
//
// For more about build flags, see 'go help build'.
//
// See also: go build.
//
// Test packages
//
// Usage:
//
// 	go test [build/test flags] [packages] [build/test flags & test binary flags]
//
// 'Go test' automates testing the packages named by the import paths.
// It prints a summary of the test results in the format:
//
// 	ok   archive/tar   0.011s
// 	FAIL archive/zip   0.022s
// 	ok   compress/gzip 0.033s
// 	...
//
// followed by detailed output for each failed package.
//
// 'Go test' recompiles each package along with any files with names matching
// the file pattern "*_test.go".
// Files whose names begin with "_" (including "_test.go") or "." are ignored.
// These additional files can contain test functions, benchmark functions, and
// example functions.  See 'go help testfunc' for more.
// Each listed package causes the execution of a separate test binary.
//
// Test files that declare a package with the suffix "_test" will be compiled as a
// separate package, and then linked and run with the main test binary.
//
// The go tool will ignore a directory named "testdata", making it available
// to hold ancillary data needed by the tests.
//
// By default, go test needs no arguments.  It compiles and tests the package
// with source in the current directory, including tests, and runs the tests.
//
// The package is built in a temporary directory so it does not interfere with the
// non-test installation.
//
// In addition to the build flags, the flags handled by 'go test' itself are:
//
// 	-args
// 	    Pass the remainder of the command line (everything after -args)
// 	    to the test binary, uninterpreted and unchanged.
// 	    Because this flag consumes the remainder of the command line,
// 	    the package list (if present) must appear before this flag.
//
// 	-c
// 	    Compile the test binary to pkg.test but do not run it
// 	    (where pkg is the last element of the package's import path).
// 	    The file name can be changed with the -o flag.
//
// 	-exec xprog
// 	    Run the test binary using xprog. The behavior is the same as
// 	    in 'go run'. See 'go help run' for details.
//
// 	-i
// 	    Install packages that are dependencies of the test.
// 	    Do not run the test.
//
// 	-o file
// 	    Compile the test binary to the named file.
// 	    The test still runs (unless -c or -i is specified).
//
// The test binary also accepts flags that control execution of the test; these
// flags are also accessible by 'go test'. See 'go help testflag' for details.
//
// For more about build flags, see 'go help build'.
// For more about specifying packages, see 'go help packages'.
//
// See also: go build, go vet.
//
// Run specified go tool
//
// Usage:
//
// 	go tool [-n] command [args...]
//
// Tool runs the go tool command identified by the arguments.
// With no arguments it prints the list of known tools.
//
// The -n flag causes tool to print the command that would be
// executed but not execute it.
//
// For more about each tool command, see 'go tool command -h'.
//
// Print Go version
//
// Usage:
//
// 	go version
//
// Version prints the Go version, as reported by runtime.Version.
//
// Run go tool vet on packages
//
// Usage:
//
// 	go vet [-n] [-x] [build flags] [packages]
//
// Vet runs the Go vet command on the packages named by the import paths.
//
// For more about vet, see 'go doc cmd/vet'.
// For more about specifying packages, see 'go help packages'.
//
// To run the vet tool with specific options, run 'go tool vet'.
//
// The -n flag prints commands that would be executed.
// The -x flag prints commands as they are executed.
//
// For more about build flags, see 'go help build'.
//
// See also: go fmt, go fix.
//
// Calling between Go and C
//
// There are two different ways to call between Go and C/C++ code.
//
// The first is the cgo tool, which is part of the Go distribution.  For
// information on how to use it see the cgo documentation (go doc cmd/cgo).
//
// The second is the SWIG program, which is a general tool for
// interfacing between languages.  For information on SWIG see
// http://swig.org/.  When running go build, any file with a .swig
// extension will be passed to SWIG.  Any file with a .swigcxx extension
// will be passed to SWIG with the -c++ option.
//
// When either cgo or SWIG is used, go build will pass any .c, .m, .s,
// or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++
// compiler.  The CC or CXX environment variables may be set to determine
// the C or C++ compiler, respectively, to use.
//
// Description of build modes
//
// The 'go build' and 'go install' commands take a -buildmode argument which
// indicates which kind of object file is to be built. Currently supported values
// are:
//
// 	-buildmode=archive
// 		Build the listed non-main packages into .a files. Packages named
// 		main are ignored.
//
// 	-buildmode=c-archive
// 		Build the listed main package, plus all packages it imports,
// 		into a C archive file. The only callable symbols will be those
// 		functions exported using a cgo //export comment. Requires
// 		exactly one main package to be listed.
//
// 	-buildmode=c-shared
// 		Build the listed main packages, plus all packages that they
// 		import, into C shared libraries. The only callable symbols will
// 		be those functions exported using a cgo //export comment.
// 		Non-main packages are ignored.
//
// 	-buildmode=default
// 		Listed main packages are built into executables and listed
// 		non-main packages are built into .a files (the default
// 		behavior).
//
// 	-buildmode=shared
// 		Combine all the listed non-main packages into a single shared
// 		library that will be used when building with the -linkshared
// 		option. Packages named main are ignored.
//
// 	-buildmode=exe
// 		Build the listed main packages and everything they import into
// 		executables. Packages not named main are ignored.
//
// 	-buildmode=pie
// 		Build the listed main packages and everything they import into
// 		position independent executables (PIE). Packages not named
// 		main are ignored.
//
// File types
//
// The go command examines the contents of a restricted set of files
// in each directory. It identifies which files to examine based on
// the extension of the file name. These extensions are:
//
// 	.go
// 		Go source files.
// 	.c, .h
// 		C source files.
// 		If the package uses cgo or SWIG, these will be compiled with the
// 		OS-native compiler (typically gcc); otherwise they will
// 		trigger an error.
// 	.cc, .cpp, .cxx, .hh, .hpp, .hxx
// 		C++ source files. Only useful with cgo or SWIG, and always
// 		compiled with the OS-native compiler.
// 	.m
// 		Objective-C source files. Only useful with cgo, and always
// 		compiled with the OS-native compiler.
// 	.s, .S
// 		Assembler source files.
// 		If the package uses cgo or SWIG, these will be assembled with the
// 		OS-native assembler (typically gcc (sic)); otherwise they
// 		will be assembled with the Go assembler.
// 	.swig, .swigcxx
// 		SWIG definition files.
// 	.syso
// 		System object files.
// 	.inc.js
// 		JavaScript source files.
// 		Automatically included when building the package.
//
// Files of each of these types except .syso may contain build
// constraints, but the go command stops scanning for build constraints
// at the first item in the file that is not a blank line or //-style
// line comment. See the go/build package documentation for
// more details.
//
// Non-test Go source files can also include a //go:binary-only-package
// comment, indicating that the package sources are included
// for documentation only and must not be used to build the
// package binary. This enables distribution of Go packages in
// their compiled form alone. See the go/build package documentation
// for more details.
//
// GOPATH environment variable
//
// The Go path is used to resolve import statements.
// It is implemented by and documented in the go/build package.
//
// The GOPATH environment variable lists places to look for Go code.
// On Unix, the value is a colon-separated string.
// On Windows, the value is a semicolon-separated string.
// On Plan 9, the value is a list.
//
// GOPATH must be set to get, build and install packages outside the
// standard Go tree.
//
// Each directory listed in GOPATH must have a prescribed structure:
//
// The src directory holds source code.  The path below src
// determines the import path or executable name.
//
// The pkg directory holds installed package objects.
// As in the Go tree, each target operating system and
// architecture pair has its own subdirectory of pkg
// (pkg/GOOS_GOARCH).
//
// If DIR is a directory listed in the GOPATH, a package with
// source in DIR/src/foo/bar can be imported as "foo/bar" and
// has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".
//
// The bin directory holds compiled commands.
// Each command is named for its source directory, but only
// the final element, not the entire path.  That is, the
// command with source in DIR/src/foo/quux is installed into
// DIR/bin/quux, not DIR/bin/foo/quux.  The "foo/" prefix is stripped
// so that you can add DIR/bin to your PATH to get at the
// installed commands.  If the GOBIN environment variable is
// set, commands are installed to the directory it names instead
// of DIR/bin. GOBIN must be an absolute path.
//
// Here's an example directory layout:
//
//     GOPATH=/home/user/gocode
//
//     /home/user/gocode/
//         src/
//             foo/
//                 bar/               (go code in package bar)
//                     x.go
//                 quux/              (go code in package main)
//                     y.go
//         bin/
//             quux                   (installed command)
//         pkg/
//             linux_amd64/
//                 foo/
//                     bar.a          (installed package object)
//
// Go searches each directory listed in GOPATH to find source code,
// but new packages are always downloaded into the first directory
// in the list.
//
// See https://golang.org/doc/code.html for an example.
//
// Internal Directories
//
// Code in or below a directory named "internal" is importable only
// by code in the directory tree rooted at the parent of "internal".
// Here's an extended version of the directory layout above:
//
//     /home/user/gocode/
//         src/
//             crash/
//                 bang/              (go code in package bang)
//                     b.go
//             foo/                   (go code in package foo)
//                 f.go
//                 bar/               (go code in package bar)
//                     x.go
//                 internal/
//                     baz/           (go code in package baz)
//                         z.go
//                 quux/              (go code in package main)
//                     y.go
//
// The code in z.go is imported as "foo/internal/baz", but that
// import statement can only appear in source files in the subtree
// rooted at foo. The source files foo/f.go, foo/bar/x.go, and
// foo/quux/y.go can all import "foo/internal/baz", but the source file
// crash/bang/b.go cannot.
//
// See https://golang.org/s/go14internal for details.
//
// Vendor Directories
//
// Go 1.6 includes support for using local copies of external dependencies
// to satisfy imports of those dependencies, often referred to as vendoring.
//
// Code below a directory named "vendor" is importable only
// by code in the directory tree rooted at the parent of "vendor",
// and only using an import path that omits the prefix up to and
// including the vendor element.
//
// Here's the example from the previous section,
// but with the "internal" directory renamed to "vendor"
// and a new foo/vendor/crash/bang directory added:
//
//     /home/user/gocode/
//         src/
//             crash/
//                 bang/              (go code in package bang)
//                     b.go
//             foo/                   (go code in package foo)
//                 f.go
//                 bar/               (go code in package bar)
//                     x.go
//                 vendor/
//                     crash/
//                         bang/      (go code in package bang)
//                             b.go
//                     baz/           (go code in package baz)
//                         z.go
//                 quux/              (go code in package main)
//                     y.go
//
// The same visibility rules apply as for internal, but the code
// in z.go is imported as "baz", not as "foo/vendor/baz".
//
// Code in vendor directories deeper in the source tree shadows
// code in higher directories. Within the subtree rooted at foo, an import
// of "crash/bang" resolves to "foo/vendor/crash/bang", not the
// top-level "crash/bang".
//
// Code in vendor directories is not subject to import path
// checking (see 'go help importpath').
//
// When 'go get' checks out or updates a git repository, it now also
// updates submodules.
//
// Vendor directories do not affect the placement of new repositories
// being checked out for the first time by 'go get': those are always
// placed in the main GOPATH, never in a vendor subtree.
//
// See https://golang.org/s/go15vendor for details.
//
// Environment variables
//
// The go command, and the tools it invokes, examine a few different
// environment variables. For many of these, you can see the default
// value of on your system by running 'go env NAME', where NAME is the
// name of the variable.
//
// General-purpose environment variables:
//
// 	GCCGO
// 		The gccgo command to run for 'go build -compiler=gccgo'.
// 	GOARCH
// 		The architecture, or processor, for which to compile code.
// 		Examples are amd64, 386, arm, ppc64.
// 	GOBIN
// 		The directory where 'go install' will install a command.
// 	GOOS
// 		The operating system for which to compile code.
// 		Examples are linux, darwin, windows, netbsd.
// 	GOPATH
// 		See 'go help gopath'.
// 	GORACE
// 		Options for the race detector.
// 		See https://golang.org/doc/articles/race_detector.html.
// 	GOROOT
// 		The root of the go tree.
//
// Environment variables for use with cgo:
//
// 	CC
// 		The command to use to compile C code.
// 	CGO_ENABLED
// 		Whether the cgo command is supported.  Either 0 or 1.
// 	CGO_CFLAGS
// 		Flags that cgo will pass to the compiler when compiling
// 		C code.
// 	CGO_CPPFLAGS
// 		Flags that cgo will pass to the compiler when compiling
// 		C or C++ code.
// 	CGO_CXXFLAGS
// 		Flags that cgo will pass to the compiler when compiling
// 		C++ code.
// 	CGO_LDFLAGS
// 		Flags that cgo will pass to the compiler when linking.
// 	CXX
// 		The command to use to compile C++ code.
//
// Architecture-specific environment variables:
//
// 	GOARM
// 		For GOARCH=arm, the ARM architecture for which to compile.
// 		Valid values are 5, 6, 7.
// 	GO386
// 		For GOARCH=386, the floating point instruction set.
// 		Valid values are 387, sse2.
//
// Special-purpose environment variables:
//
// 	GOROOT_FINAL
// 		The root of the installed Go tree, when it is
// 		installed in a location other than where it is built.
// 		File names in stack traces are rewritten from GOROOT to
// 		GOROOT_FINAL.
// 	GO_EXTLINK_ENABLED
// 		Whether the linker should use external linking mode
// 		when using -linkmode=auto with code that uses cgo.
// 		Set to 0 to disable external linking mode, 1 to enable it.
//
// Import path syntax
//
// An import path (see 'go help packages') denotes a package
// stored in the local file system.  In general, an import path denotes
// either a standard package (such as "unicode/utf8") or a package
// found in one of the work spaces (see 'go help gopath').
//
// Relative import paths
//
// An import path beginning with ./ or ../ is called a relative path.
// The toolchain supports relative import paths as a shortcut in two ways.
//
// First, a relative path can be used as a shorthand on the command line.
// If you are working in the directory containing the code imported as
// "unicode" and want to run the tests for "unicode/utf8", you can type
// "go test ./utf8" instead of needing to specify the full path.
// Similarly, in the reverse situation, "go test .." will test "unicode" from
// the "unicode/utf8" directory. Relative patterns are also allowed, like
// "go test ./..." to test all subdirectories. See 'go help packages' for details
// on the pattern syntax.
//
// Second, if you are compiling a Go program not in a work space,
// you can use a relative path in an import statement in that program
// to refer to nearby code also not in a work space.
// This makes it easy to experiment with small multipackage programs
// outside of the usual work spaces, but such programs cannot be
// installed with "go install" (there is no work space in which to install them),
// so they are rebuilt from scratch each time they are built.
// To avoid ambiguity, Go programs cannot use relative import paths
// within a work space.
//
// Remote import paths
//
// Certain import paths also
// describe how to obtain the source code for the package using
// a revision control system.
//
// A few common code hosting sites have special syntax:
//
// 	Bitbucket (Git, Mercurial)
//
// 		import "bitbucket.org/user/project"
// 		import "bitbucket.org/user/project/sub/directory"
//
// 	GitHub (Git)
//
// 		import "github.com/user/project"
// 		import "github.com/user/project/sub/directory"
//
// 	Launchpad (Bazaar)
//
// 		import "launchpad.net/project"
// 		import "launchpad.net/project/series"
// 		import "launchpad.net/project/series/sub/directory"
//
// 		import "launchpad.net/~user/project/branch"
// 		import "launchpad.net/~user/project/branch/sub/directory"
//
// 	IBM DevOps Services (Git)
//
// 		import "hub.jazz.net/git/user/project"
// 		import "hub.jazz.net/git/user/project/sub/directory"
//
// For code hosted on other servers, import paths may either be qualified
// with the version control type, or the go tool can dynamically fetch
// the import path over https/http and discover where the code resides
// from a <meta> tag in the HTML.
//
// To declare the code location, an import path of the form
//
// 	repository.vcs/path
//
// specifies the given repository, with or without the .vcs suffix,
// using the named version control system, and then the path inside
// that repository.  The supported version control systems are:
//
// 	Bazaar      .bzr
// 	Git         .git
// 	Mercurial   .hg
// 	Subversion  .svn
//
// For example,
//
// 	import "example.org/user/foo.hg"
//
// denotes the root directory of the Mercurial repository at
// example.org/user/foo or foo.hg, and
//
// 	import "example.org/repo.git/foo/bar"
//
// denotes the foo/bar directory of the Git repository at
// example.org/repo or repo.git.
//
// When a version control system supports multiple protocols,
// each is tried in turn when downloading.  For example, a Git
// download tries https://, then git+ssh://.
//
// If the import path is not a known code hosting site and also lacks a
// version control qualifier, the go tool attempts to fetch the import
// over https/http and looks for a <meta> tag in the document's HTML
// <head>.
//
// The meta tag has the form:
//
// 	<meta name="go-import" content="import-prefix vcs repo-root">
//
// The import-prefix is the import path corresponding to the repository
// root. It must be a prefix or an exact match of the package being
// fetched with "go get". If it's not an exact match, another http
// request is made at the prefix to verify the <meta> tags match.
//
// The meta tag should appear as early in the file as possible.
// In particular, it should appear before any raw JavaScript or CSS,
// to avoid confusing the go command's restricted parser.
//
// The vcs is one of "git", "hg", "svn", etc,
//
// The repo-root is the root of the version control system
// containing a scheme and not containing a .vcs qualifier.
//
// For example,
//
// 	import "example.org/pkg/foo"
//
// will result in the following requests:
//
// 	https://example.org/pkg/foo?go-get=1 (preferred)
// 	http://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)
//
// If that page contains the meta tag
//
// 	<meta name="go-import" content="example.org git https://code.org/r/p/exproj">
//
// the go tool will verify that https://example.org/?go-get=1 contains the
// same meta tag and then git clone https://code.org/r/p/exproj into
// GOPATH/src/example.org.
//
// New downloaded packages are written to the first directory
// listed in the GOPATH environment variable (see 'go help gopath').
//
// The go command attempts to download the version of the
// package appropriate for the Go release being used.
// Run 'go help get' for more.
//
// Import path checking
//
// When the custom import path feature described above redirects to a
// known code hosting site, each of the resulting packages has two possible
// import paths, using the custom domain or the known hosting site.
//
// A package statement is said to have an "import comment" if it is immediately
// followed (before the next newline) by a comment of one of these two forms:
//
// 	package math // import "path"
// 	package math /* import "path" */
//
// The go command will refuse to install a package with an import comment
// unless it is being referred to by that import path. In this way, import comments
// let package authors make sure the custom import path is used and not a
// direct path to the underlying code hosting site.
//
// Import path checking is disabled for code found within vendor trees.
// This makes it possible to copy code into alternate locations in vendor trees
// without needing to update import comments.
//
// See https://golang.org/s/go14customimport for details.
//
// Description of package lists
//
// Many commands apply to a set of packages:
//
// 	go action [packages]
//
// Usually, [packages] is a list of import paths.
//
// An import path that is a rooted path or that begins with
// a . or .. element is interpreted as a file system path and
// denotes the package in that directory.
//
// Otherwise, the import path P denotes the package found in
// the directory DIR/src/P for some DIR listed in the GOPATH
// environment variable (see 'go help gopath').
//
// If no import paths are given, the action applies to the
// package in the current directory.
//
// There are four reserved names for paths that should not be used
// for packages to be built with the go tool:
//
// - "main" denotes the top-level package in a stand-alone executable.
//
// - "all" expands to all package directories found in all the GOPATH
// trees. For example, 'go list all' lists all the packages on the local
// system.
//
// - "std" is like all but expands to just the packages in the standard
// Go library.
//
// - "cmd" expands to the Go repository's commands and their
// internal libraries.
//
// An import path is a pattern if it includes one or more "..." wildcards,
// each of which can match any string, including the empty string and
// strings containing slashes.  Such a pattern expands to all package
// directories found in the GOPATH trees with names matching the
// patterns.  As a special case, x/... matches x as well as x's subdirectories.
// For example, net/... expands to net and packages in its subdirectories.
//
// An import path can also name a package to be downloaded from
// a remote repository.  Run 'go help importpath' for details.
//
// Every package in a program must have a unique import path.
// By convention, this is arranged by starting each path with a
// unique prefix that belongs to you.  For example, paths used
// internally at Google all begin with 'google', and paths
// denoting remote repositories begin with the path to the code,
// such as 'github.com/user/repo'.
//
// Packages in a program need not have unique package names,
// but there are two reserved package names with special meaning.
// The name main indicates a command, not a library.
// Commands are built into binaries and cannot be imported.
// The name documentation indicates documentation for
// a non-Go program in the directory. Files in package documentation
// are ignored by the go command.
//
// As a special case, if the package list is a list of .go files from a
// single directory, the command is applied to a single synthesized
// package made up of exactly those files, ignoring any build constraints
// in those files and ignoring any other files in the directory.
//
// Directory and file names that begin with "." or "_" are ignored
// by the go tool, as are directories named "testdata".
//
// Description of testing flags
//
// The 'go test' command takes both flags that apply to 'go test' itself
// and flags that apply to the resulting test binary.
//
// Several of the flags control profiling and write an execution profile
// suitable for "go tool pprof"; run "go tool pprof -h" for more
// information.  The --alloc_space, --alloc_objects, and --show_bytes
// options of pprof control how the information is presented.
//
// The following flags are recognized by the 'go test' command and
// control the execution of any test:
//
// 	-bench regexp
// 	    Run (sub)benchmarks matching a regular expression.
// 	    The given regular expression is split into smaller ones by
// 	    top-level '/', where each must match the corresponding part of a
// 	    benchmark's identifier.
// 	    By default, no benchmarks run. To run all benchmarks,
// 	    use '-bench .' or '-bench=.'.
//
// 	-benchmem
// 	    Print memory allocation statistics for benchmarks.
//
// 	-benchtime t
// 	    Run enough iterations of each benchmark to take t, specified
// 	    as a time.Duration (for example, -benchtime 1h30s).
// 	    The default is 1 second (1s).
//
// 	-blockprofile block.out
// 	    Write a goroutine blocking profile to the specified file
// 	    when all tests are complete.
// 	    Writes test binary as -c would.
//
// 	-blockprofilerate n
// 	    Control the detail provided in goroutine blocking profiles by
// 	    calling runtime.SetBlockProfileRate with n.
// 	    See 'go doc runtime.SetBlockProfileRate'.
// 	    The profiler aims to sample, on average, one blocking event every
// 	    n nanoseconds the program spends blocked.  By default,
// 	    if -test.blockprofile is set without this flag, all blocking events
// 	    are recorded, equivalent to -test.blockprofilerate=1.
//
// 	-count n
// 	    Run each test and benchmark n times (default 1).
// 	    If -cpu is set, run n times for each GOMAXPROCS value.
// 	    Examples are always run once.
//
// 	-cover
// 	    Enable coverage analysis.
//
// 	-covermode set,count,atomic
// 	    Set the mode for coverage analysis for the package[s]
// 	    being tested. The default is "set" unless -race is enabled,
// 	    in which case it is "atomic".
// 	    The values:
// 		set: bool: does this statement run?
// 		count: int: how many times does this statement run?
// 		atomic: int: count, but correct in multithreaded tests;
// 			significantly more expensive.
// 	    Sets -cover.
//
// 	-coverpkg pkg1,pkg2,pkg3
// 	    Apply coverage analysis in each test to the given list of packages.
// 	    The default is for each test to analyze only the package being tested.
// 	    Packages are specified as import paths.
// 	    Sets -cover.
//
// 	-coverprofile cover.out
// 	    Write a coverage profile to the file after all tests have passed.
// 	    Sets -cover.
//
// 	-cpu 1,2,4
// 	    Specify a list of GOMAXPROCS values for which the tests or
// 	    benchmarks should be executed.  The default is the current value
// 	    of GOMAXPROCS.
//
// 	-cpuprofile cpu.out
// 	    Write a CPU profile to the specified file before exiting.
// 	    Writes test binary as -c would.
//
// 	-memprofile mem.out
// 	    Write a memory profile to the file after all tests have passed.
// 	    Writes test binary as -c would.
//
// 	-memprofilerate n
// 	    Enable more precise (and expensive) memory profiles by setting
// 	    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.
// 	    To profile all memory allocations, use -test.memprofilerate=1
// 	    and pass --alloc_space flag to the pprof tool.
//
// 	-outputdir directory
// 	    Place output files from profiling in the specified directory,
// 	    by default the directory in which "go test" is running.
//
// 	-parallel n
// 	    Allow parallel execution of test functions that call t.Parallel.
// 	    The value of this flag is the maximum number of tests to run
// 	    simultaneously; by default, it is set to the value of GOMAXPROCS.
// 	    Note that -parallel only applies within a single test binary.
// 	    The 'go test' command may run tests for different packages
// 	    in parallel as well, according to the setting of the -p flag
// 	    (see 'go help build').
//
// 	-run regexp
// 	    Run only those tests and examples matching the regular expression.
// 	    For tests the regular expression is split into smaller ones by
// 	    top-level '/', where each must match the corresponding part of a
// 	    test's identifier.
//
// 	-short
// 	    Tell long-running tests to shorten their run time.
// 	    It is off by default but set during all.bash so that installing
// 	    the Go tree can run a sanity check but not spend time running
// 	    exhaustive tests.
//
// 	-timeout t
// 	    If a test runs longer than t, panic.
// 	    The default is 10 minutes (10m).
//
// 	-trace trace.out
// 	    Write an execution trace to the specified file before exiting.
//
// 	-v
// 	    Verbose output: log all tests as they are run. Also print all
// 	    text from Log and Logf calls even if the test succeeds.
//
// Each of these flags is also recognized with an optional 'test.' prefix,
// as in -test.v. When invoking the generated test binary (the result of
// 'go test -c') directly, however, the prefix is mandatory.
//
// The 'go test' command rewrites or removes recognized flags,
// as appropriate, both before and after the optional package list,
// before invoking the test binary.
//
// For instance, the command
//
// 	go test -v -myflag testdata -cpuprofile=prof.out -x
//
// will compile the test binary and then run it as
//
// 	pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out
//
// (The -x flag is removed because it applies only to the go command's
// execution, not to the test itself.)
//
// The test flags that generate profiles (other than for coverage) also
// leave the test binary in pkg.test for use when analyzing the profiles.
//
// When 'go test' runs a test binary, it does so from within the
// corresponding package's source code directory. Depending on the test,
// it may be necessary to do the same when invoking a generated test
// binary directly.
//
// The command-line package list, if present, must appear before any
// flag not known to the go test command. Continuing the example above,
// the package list would have to appear before -myflag, but could appear
// on either side of -v.
//
// To keep an argument for a test binary from being interpreted as a
// known flag or a package name, use -args (see 'go help test') which
// passes the remainder of the command line through to the test binary
// uninterpreted and unaltered.
//
// For instance, the command
//
// 	go test -v -args -x -v
//
// will compile the test binary and then run it as
//
// 	pkg.test -test.v -x -v
//
// Similarly,
//
// 	go test -args math
//
// will compile the test binary and then run it as
//
// 	pkg.test math
//
// In the first example, the -x and the second -v are passed through to the
// test binary unchanged and with no effect on the go command itself.
// In the second example, the argument math is passed through to the test
// binary, instead of being interpreted as the package list.
//
// Description of testing functions
//
// The 'go test' command expects to find test, benchmark, and example functions
// in the "*_test.go" files corresponding to the package under test.
//
// A test function is one named TestXXX (where XXX is any alphanumeric string
// not starting with a lower case letter) and should have the signature,
//
// 	func TestXXX(t *testing.T) { ... }
//
// A benchmark function is one named BenchmarkXXX and should have the signature,
//
// 	func BenchmarkXXX(b *testing.B) { ... }
//
// An example function is similar to a test function but, instead of using
// *testing.T to report success or failure, prints output to os.Stdout.
// If the last comment in the function starts with "Output:" then the output
// is compared exactly against the comment (see examples below). If the last
// comment begins with "Unordered output:" then the output is compared to the
// comment, however the order of the lines is ignored. An example with no such
// comment, or with no text after "Output:" is compiled but not executed.
//
// Godoc displays the body of ExampleXXX to demonstrate the use
// of the function, constant, or variable XXX.  An example of a method M with
// receiver type T or *T is named ExampleT_M.  There may be multiple examples
// for a given function, constant, or variable, distinguished by a trailing _xxx,
// where xxx is a suffix not beginning with an upper case letter.
//
// Here is an example of an example:
//
// 	func ExamplePrintln() {
// 		Println("The output of\nthis example.")
// 		// Output: The output of
// 		// this example.
// 	}
//
// Here is another example where the ordering of the output is ignored:
//
// 	func ExamplePerm() {
// 		for _, value := range Perm(4) {
// 			fmt.Println(value)
// 		}
//
// 		// Unordered output: 4
// 		// 2
// 		// 1
// 		// 3
// 		// 0
// 	}
//
// The entire test file is presented as the example when it contains a single
// example function, at least one other function, type, variable, or constant
// declaration, and no test or benchmark functions.
//
// See the documentation of the testing package for more information.
//

package main

import (
	"bufio"
	"bytes"
	"container/heap"
	"crypto/sha1"
	"crypto/tls"
	"debug/elf"
	"debug/macho"
	"encoding/binary"
	"encoding/json"
	"encoding/xml"
	"errors"
	"flag"
	"fmt"
	"go/ast"
	"go/doc"
	"go/parser"
	"go/scanner"
	"go/token"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"os/signal"
	"path"
	pathpkg "path"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"text/template"
	"time"
	"unicode"
	"unicode/utf8"

	gopherjsbuild "github.com/gopherjs/gopherjs/build"
	"github.com/gopherjs/gopherjs/compiler"
	"github.com/gopherjs/gopherjs/compiler/natives"
	"github.com/gopherjs/gopherjs/go/build"
	"github.com/gopherjs/gopherjs/internal/singleflight"
	"github.com/kardianos/osext"
	ioutil2 "github.com/shurcooL/go/ioutil"
)

var cmdgo_cmdBuild = &cmdgo_Command{
	UsageLine: "build [-o output] [-i] [build flags] [packages]",
	Short:     "compile packages and dependencies",
	Long: `
Build compiles the packages named by the import paths,
along with their dependencies, but it does not install the results.

If the arguments to build are a list of .go files, build treats
them as a list of source files specifying a single package.

When compiling a single main package, build writes
the resulting executable to an output file named after
the first source file ('go build ed.go rx.go' writes 'ed' or 'ed.exe')
or the source code directory ('go build unix/sam' writes 'sam' or 'sam.exe').
The '.exe' suffix is added when writing a Windows executable.

When compiling multiple packages or a single non-main package,
build compiles the packages but discards the resulting object,
serving only as a check that the packages can be built.

When compiling packages, build ignores files that end in '_test.go'.

The -o flag, only allowed when compiling a single package,
forces build to write the resulting executable or object
to the named output file, instead of the default behavior described
in the last two paragraphs.

The -i flag installs the packages that are dependencies of the target.

The build flags are shared by the build, clean, get, install, list, run,
and test commands:

	-a
		force rebuilding of packages that are already up-to-date.
	-n
		print the commands but do not run them.
	-p n
		the number of programs, such as build commands or
		test binaries, that can be run in parallel.
		The default is the number of CPUs available.
	-race
		enable data race detection.
		Supported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.
	-msan
		enable interoperation with memory sanitizer.
		Supported only on linux/amd64,
		and only with Clang/LLVM as the host C compiler.
	-v
		print the names of packages as they are compiled.
	-work
		print the name of the temporary work directory and
		do not delete it when exiting.
	-x
		print the commands.

	-asmflags 'flag list'
		arguments to pass on each go tool asm invocation.
	-buildmode mode
		build mode to use. See 'go help buildmode' for more.
	-compiler name
		name of compiler to use, as in runtime.Compiler (gccgo, gc or gopherjs).
	-gccgoflags 'arg list'
		arguments to pass on each gccgo compiler/linker invocation.
	-gcflags 'arg list'
		arguments to pass on each go tool compile invocation.
	-installsuffix suffix
		a suffix to use in the name of the package installation directory,
		in order to keep output separate from default builds.
		If using the -race flag, the install suffix is automatically set to race
		or, if set explicitly, has _race appended to it.  Likewise for the -msan
		flag.  Using a -buildmode option that requires non-default compile flags
		has a similar effect.
	-ldflags 'flag list'
		arguments to pass on each go tool link invocation.
	-linkshared
		link against shared libraries previously created with
		-buildmode=shared.
	-pkgdir dir
		install and load all packages from dir instead of the usual locations.
		For example, when building with a non-standard configuration,
		use -pkgdir to keep generated packages in a separate location.
	-tags 'tag list'
		a list of build tags to consider satisfied during the build.
		For more information about build tags, see the description of
		build constraints in the documentation for the go/build package.
	-toolexec 'cmd args'
		a program to use to invoke toolchain programs like vet and asm.
		For example, instead of running asm, the go command will run
		'cmd args /path/to/asm <arguments for asm>'.

The list flags accept a space-separated list of strings. To embed spaces
in an element in the list, surround it with either single or double quotes.

For more about specifying packages, see 'go help packages'.
For more about where packages and binaries are installed,
run 'go help gopath'.
For more about calling between Go and C/C++, run 'go help c'.

Note: Build adheres to certain conventions such as those described
by 'go help gopath'. Not all projects can follow these conventions,
however. Installations that have their own conventions or that use
a separate software build system may choose to use lower-level
invocations such as 'go tool compile' and 'go tool link' to avoid
some of the overheads and design decisions of the build tool.

See also: go install, go get, go clean.
	`,
}

func init() {

	cmdgo_cmdBuild.Run = cmdgo_runBuild
	cmdgo_cmdInstall.Run = cmdgo_runInstall

	cmdgo_cmdBuild.Flag.BoolVar(&cmdgo_buildI, "i", false, "")

	cmdgo_addBuildFlags(cmdgo_cmdBuild)
	cmdgo_addBuildFlags(cmdgo_cmdInstall)
}

// Flags set by multiple commands.
var cmdgo_buildA bool // -a flag

var cmdgo_buildN bool // -n flag

var cmdgo_buildP = runtime.NumCPU() // -p flag

var cmdgo_buildV bool // -v flag

var cmdgo_buildX bool // -x flag

var cmdgo_buildI bool // -i flag

var cmdgo_buildO = cmdgo_cmdBuild.Flag.String("o", "", "output file")

var cmdgo_buildWork bool // -work flag

var cmdgo_buildAsmflags []string // -asmflags flag

var cmdgo_buildGcflags []string // -gcflags flag

var cmdgo_buildLdflags []string // -ldflags flag

var cmdgo_buildGccgoflags []string // -gccgoflags flag

var cmdgo_buildRace bool // -race flag

var cmdgo_buildMSan bool // -msan flag

var cmdgo_buildToolExec []string // -toolexec flag

var cmdgo_buildBuildmode string // -buildmode flag

var cmdgo_buildLinkshared bool // -linkshared flag

var cmdgo_buildPkgdir string // -pkgdir flag

var cmdgo_buildContext = build.Default

var cmdgo_buildToolchain cmdgo_toolchain = cmdgo_noToolchain{}

var cmdgo_ldBuildmode string

// buildCompiler implements flag.Var.
// It implements Set by updating both
// buildToolchain and buildContext.Compiler.
type cmdgo_buildCompiler struct{}

func (c cmdgo_buildCompiler) Set(value string) error {
	switch value {
	case "gc":
		cmdgo_buildToolchain = cmdgo_gcToolchain{}
	case "gccgo":
		cmdgo_buildToolchain = cmdgo_gccgoToolchain{}
	case "gopherjs":
		exe, err := osext.Executable()
		if err != nil {
			log.Fatalln("osext.Executable:", err)
		}
		cmdgo_buildToolchain = cmdgo_gopherjsToolchain{binaryPath: exe}
	default:
		return fmt.Errorf("unknown compiler %q", value)
	}
	cmdgo_buildContext.Compiler = value
	return nil
}

func (c cmdgo_buildCompiler) String() string {
	return cmdgo_buildContext.Compiler
}

func init() {
	switch build.Default.Compiler {
	case "gc":
		cmdgo_buildToolchain = cmdgo_gcToolchain{}
	case "gccgo":
		cmdgo_buildToolchain = cmdgo_gccgoToolchain{}
	case "gopherjs":
		exe, err := osext.Executable()
		if err != nil {
			log.Fatalln("osext.Executable:", err)
		}
		cmdgo_buildToolchain = cmdgo_gopherjsToolchain{binaryPath: exe}
	}
}

// addBuildFlags adds the flags common to the build, clean, get,
// install, list, run, and test commands.
func cmdgo_addBuildFlags(cmd *cmdgo_Command) {
	cmd.Flag.BoolVar(&cmdgo_buildA, "a", false, "")
	cmd.Flag.BoolVar(&cmdgo_buildN, "n", false, "")
	cmd.Flag.IntVar(&cmdgo_buildP, "p", cmdgo_buildP, "")
	cmd.Flag.BoolVar(&cmdgo_buildV, "v", false, "")
	cmd.Flag.BoolVar(&cmdgo_buildX, "x", false, "")

	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildAsmflags), "asmflags", "")
	cmd.Flag.Var(cmdgo_buildCompiler{}, "compiler", "")
	cmd.Flag.StringVar(&cmdgo_buildBuildmode, "buildmode", "default", "")
	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildGcflags), "gcflags", "")
	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildGccgoflags), "gccgoflags", "")
	cmd.Flag.StringVar(&cmdgo_buildContext.InstallSuffix, "installsuffix", "", "")
	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildLdflags), "ldflags", "")
	cmd.Flag.BoolVar(&cmdgo_buildLinkshared, "linkshared", false, "")
	cmd.Flag.StringVar(&cmdgo_buildPkgdir, "pkgdir", "", "")
	cmd.Flag.BoolVar(&cmdgo_buildRace, "race", false, "")
	cmd.Flag.BoolVar(&cmdgo_buildMSan, "msan", false, "")
	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildContext.BuildTags), "tags", "")
	cmd.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_buildToolExec), "toolexec", "")
	cmd.Flag.BoolVar(&cmdgo_buildWork, "work", false, "")
}

func cmdgo_addBuildFlagsNX(cmd *cmdgo_Command) {
	cmd.Flag.BoolVar(&cmdgo_buildN, "n", false, "")
	cmd.Flag.BoolVar(&cmdgo_buildX, "x", false, "")
}

func cmdgo_isSpaceByte(c byte) bool {
	return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

// fileExtSplit expects a filename and returns the name
// and ext (without the dot). If the file has no
// extension, ext will be empty.
func cmdgo_fileExtSplit(file string) (name, ext string) {
	dotExt := filepath.Ext(file)
	name = file[:len(file)-len(dotExt)]
	if dotExt != "" {
		ext = dotExt[1:]
	}
	return
}

type cmdgo_stringsFlag []string

func (v *cmdgo_stringsFlag) Set(s string) error {
	var err error
	*v, err = cmdgo_splitQuotedFields(s)
	if *v == nil {
		*v = []string{}
	}
	return err
}

func cmdgo_splitQuotedFields(s string) ([]string, error) {
	// Split fields allowing '' or "" around elements.
	// Quotes further inside the string do not count.
	var f []string
	for len(s) > 0 {
		for len(s) > 0 && cmdgo_isSpaceByte(s[0]) {
			s = s[1:]
		}
		if len(s) == 0 {
			break
		}

		if s[0] == '"' || s[0] == '\'' {
			quote := s[0]
			s = s[1:]
			i := 0
			for i < len(s) && s[i] != quote {
				i++
			}
			if i >= len(s) {
				return nil, fmt.Errorf("unterminated %c string", quote)
			}
			f = append(f, s[:i])
			s = s[i+1:]
			continue
		}
		i := 0
		for i < len(s) && !cmdgo_isSpaceByte(s[i]) {
			i++
		}
		f = append(f, s[:i])
		s = s[i:]
	}
	return f, nil
}

func (v *cmdgo_stringsFlag) String() string {
	return "<stringsFlag>"
}

func cmdgo_pkgsMain(pkgs []*cmdgo_Package) (res []*cmdgo_Package) {
	for _, p := range pkgs {
		if p.Name == "main" {
			res = append(res, p)
		}
	}
	return res
}

func cmdgo_pkgsNotMain(pkgs []*cmdgo_Package) (res []*cmdgo_Package) {
	for _, p := range pkgs {
		if p.Name != "main" {
			res = append(res, p)
		}
	}
	return res
}

var cmdgo_pkgsFilter = func(pkgs []*cmdgo_Package) []*cmdgo_Package { return pkgs }

func cmdgo_buildModeInit() {
	_, gccgo := cmdgo_buildToolchain.(cmdgo_gccgoToolchain)
	var codegenArg string
	platform := cmdgo_goos + "/" + cmdgo_goarch
	switch cmdgo_buildBuildmode {
	case "archive":
		cmdgo_pkgsFilter = cmdgo_pkgsNotMain
	case "c-archive":
		cmdgo_pkgsFilter = func(p []*cmdgo_Package) []*cmdgo_Package {
			if len(p) != 1 || p[0].Name != "main" {
				cmdgo_fatalf("-buildmode=c-archive requires exactly one main package")
			}
			return p
		}
		switch platform {
		case "darwin/arm", "darwin/arm64":
			codegenArg = "-shared"
		default:
		}
		cmdgo_exeSuffix = ".a"
		cmdgo_ldBuildmode = "c-archive"
	case "c-shared":
		cmdgo_pkgsFilter = cmdgo_pkgsMain
		if gccgo {
			codegenArg = "-fPIC"
		} else {
			switch platform {
			case "linux/amd64", "linux/arm", "linux/arm64", "linux/386",
				"android/amd64", "android/arm", "android/arm64", "android/386":
				codegenArg = "-shared"
			case "darwin/amd64", "darwin/386":
			default:
				cmdgo_fatalf("-buildmode=c-shared not supported on %s\n", platform)
			}
		}
		cmdgo_ldBuildmode = "c-shared"
	case "default":
		switch platform {
		case "android/arm", "android/arm64", "android/amd64", "android/386":
			codegenArg = "-shared"
			cmdgo_ldBuildmode = "pie"
		case "darwin/arm", "darwin/arm64":
			codegenArg = "-shared"
			fallthrough
		default:
			cmdgo_ldBuildmode = "exe"
		}
	case "exe":
		cmdgo_pkgsFilter = cmdgo_pkgsMain
		cmdgo_ldBuildmode = "exe"
	case "pie":
		if gccgo {
			cmdgo_fatalf("-buildmode=pie not supported by gccgo")
		} else {
			switch platform {
			case "linux/386", "linux/amd64", "linux/arm", "linux/arm64", "linux/ppc64le", "linux/s390x",
				"android/amd64", "android/arm", "android/arm64", "android/386":
				codegenArg = "-shared"
			default:
				cmdgo_fatalf("-buildmode=pie not supported on %s\n", platform)
			}
		}
		cmdgo_ldBuildmode = "pie"
	case "shared":
		cmdgo_pkgsFilter = cmdgo_pkgsNotMain
		if gccgo {
			codegenArg = "-fPIC"
		} else {
			switch platform {
			case "linux/386", "linux/amd64", "linux/arm", "linux/arm64", "linux/ppc64le", "linux/s390x":
			default:
				cmdgo_fatalf("-buildmode=shared not supported on %s\n", platform)
			}
			codegenArg = "-dynlink"
		}
		if *cmdgo_buildO != "" {
			cmdgo_fatalf("-buildmode=shared and -o not supported together")
		}
		cmdgo_ldBuildmode = "shared"
	default:
		cmdgo_fatalf("buildmode=%s not supported", cmdgo_buildBuildmode)
	}
	if cmdgo_buildLinkshared {
		if gccgo {
			codegenArg = "-fPIC"
		} else {
			switch platform {
			case "linux/386", "linux/amd64", "linux/arm", "linux/arm64", "linux/ppc64le", "linux/s390x":
				cmdgo_buildAsmflags = append(cmdgo_buildAsmflags, "-D=GOBUILDMODE_shared=1")
			default:
				cmdgo_fatalf("-linkshared not supported on %s\n", platform)
			}
			codegenArg = "-dynlink"

			cmdgo_buildLdflags = append(cmdgo_buildLdflags, "-linkshared", "-w")
		}
	}
	if codegenArg != "" {
		if gccgo {
			cmdgo_buildGccgoflags = append(cmdgo_buildGccgoflags, codegenArg)
		} else {
			cmdgo_buildAsmflags = append(cmdgo_buildAsmflags, codegenArg)
			cmdgo_buildGcflags = append(cmdgo_buildGcflags, codegenArg)
		}
		if cmdgo_buildContext.InstallSuffix != "" {
			cmdgo_buildContext.InstallSuffix += "_"
		}
		cmdgo_buildContext.InstallSuffix += codegenArg[1:]
	}
}

func cmdgo_runBuild(cmd *cmdgo_Command, args []string) {
	cmdgo_instrumentInit()
	cmdgo_buildModeInit()
	var b cmdgo_builder
	b.init()

	pkgs := cmdgo_packagesForBuild(args)

	if len(pkgs) == 1 && pkgs[0].Name == "main" && *cmdgo_buildO == "" {
		_, *cmdgo_buildO = path.Split(pkgs[0].ImportPath)
		*cmdgo_buildO += cmdgo_exeSuffix
	}

	switch cmdgo_buildContext.Compiler {
	case "gccgo":
		if len(cmdgo_buildGcflags) != 0 {
			fmt.Println("go build: when using gccgo toolchain, please pass compiler flags using -gccgoflags, not -gcflags")
		}
		if len(cmdgo_buildLdflags) != 0 {
			fmt.Println("go build: when using gccgo toolchain, please pass linker flags using -gccgoflags, not -ldflags")
		}
	case "gc":
		if len(cmdgo_buildGccgoflags) != 0 {
			fmt.Println("go build: when using gc toolchain, please pass compile flags using -gcflags, and linker flags using -ldflags")
		}
	}

	depMode := cmdgo_modeBuild
	if cmdgo_buildI {
		depMode = cmdgo_modeInstall
	}

	if *cmdgo_buildO != "" {
		if len(pkgs) > 1 {
			cmdgo_fatalf("go build: cannot use -o with multiple packages")
		} else if len(pkgs) == 0 {
			cmdgo_fatalf("no packages to build")
		}
		p := pkgs[0]
		p.target = *cmdgo_buildO
		p.Stale = true
		p.StaleReason = "build -o flag in use"
		a := b.action(cmdgo_modeInstall, depMode, p)
		b.do(a)
		return
	}

	var a *cmdgo_action
	if cmdgo_buildBuildmode == "shared" {
		pkgs := cmdgo_pkgsFilter(cmdgo_packages(args))
		if libName, err := cmdgo_libname(args, pkgs); err != nil {
			cmdgo_fatalf("%s", err.Error())
		} else {
			a = b.libaction(libName, pkgs, cmdgo_modeBuild, depMode)
		}
	} else {
		a = &cmdgo_action{}
		for _, p := range cmdgo_pkgsFilter(cmdgo_packages(args)) {
			a.deps = append(a.deps, b.action(cmdgo_modeBuild, depMode, p))
		}
	}
	b.do(a)
}

var cmdgo_cmdInstall = &cmdgo_Command{
	UsageLine: "install [build flags] [packages]",
	Short:     "compile and install packages and dependencies",
	Long: `
Install compiles and installs the packages named by the import paths,
along with their dependencies.

For more about the build flags, see 'go help build'.
For more about specifying packages, see 'go help packages'.

See also: go build, go get, go clean.
	`,
}

// isMetaPackage checks if name is a reserved package name that expands to multiple packages
func cmdgo_isMetaPackage(name string) bool {
	return name == "std" || name == "cmd" || name == "all"
}

// libname returns the filename to use for the shared library when using
// -buildmode=shared. The rules we use are:
// Use arguments for special 'meta' packages:
//	std --> libstd.so
//	std cmd --> libstd,cmd.so
// A single non-meta argument with trailing "/..." is special cased:
//	foo/... --> libfoo.so
//	(A relative path like "./..."  expands the "." first)
// Use import paths for other cases, changing '/' to '-':
//	somelib --> libsubdir-somelib.so
//	./ or ../ --> libsubdir-somelib.so
//	gopkg.in/tomb.v2 -> libgopkg.in-tomb.v2.so
//	a/... b/... ---> liba/c,b/d.so - all matching import paths
// Name parts are joined with ','.
func cmdgo_libname(args []string, pkgs []*cmdgo_Package) (string, error) {
	var libname string
	appendName := func(arg string) {
		if libname == "" {
			libname = arg
		} else {
			libname += "," + arg
		}
	}
	var haveNonMeta bool
	for _, arg := range args {
		if cmdgo_isMetaPackage(arg) {
			appendName(arg)
		} else {
			haveNonMeta = true
		}
	}
	if len(libname) == 0 {
		if len(args) == 1 && strings.HasSuffix(args[0], "/...") {

			arg := strings.TrimSuffix(args[0], "/...")
			if build.IsLocalImport(arg) {
				cwd, _ := os.Getwd()
				bp, _ := cmdgo_buildContext.ImportDir(filepath.Join(cwd, arg), build.FindOnly)
				if bp.ImportPath != "" && bp.ImportPath != "." {
					arg = bp.ImportPath
				}
			}
			appendName(strings.Replace(arg, "/", "-", -1))
		} else {
			for _, pkg := range pkgs {
				appendName(strings.Replace(pkg.ImportPath, "/", "-", -1))
			}
		}
	} else if haveNonMeta {
		return "", errors.New("mixing of meta and non-meta packages is not allowed")
	}

	return "lib" + libname + ".so", nil
}

func cmdgo_runInstall(cmd *cmdgo_Command, args []string) {
	if cmdgo_gobin != "" && !filepath.IsAbs(cmdgo_gobin) {
		cmdgo_fatalf("cannot install, GOBIN must be an absolute path")
	}

	cmdgo_instrumentInit()
	cmdgo_buildModeInit()
	pkgs := cmdgo_pkgsFilter(cmdgo_packagesForBuild(args))

	for _, p := range pkgs {
		if p.Target == "" && (!p.Standard || p.ImportPath != "unsafe") {
			switch {
			case p.gobinSubdir:
				cmdgo_errorf("go install: cannot install cross-compiled binaries when GOBIN is set")
			case p.cmdline:
				cmdgo_errorf("go install: no install location for .go files listed on command line (GOBIN not set)")
			case p.ConflictDir != "":
				cmdgo_errorf("go install: no install location for %s: hidden by %s", p.Dir, p.ConflictDir)
			default:
				cmdgo_errorf("go install: no install location for directory %s outside GOPATH\n"+
					"\tFor more details see: go help gopath", p.Dir)
			}
		}
	}
	cmdgo_exitIfErrors()

	var b cmdgo_builder
	b.init()
	var a *cmdgo_action
	if cmdgo_buildBuildmode == "shared" {
		if libName, err := cmdgo_libname(args, pkgs); err != nil {
			cmdgo_fatalf("%s", err.Error())
		} else {
			a = b.libaction(libName, pkgs, cmdgo_modeInstall, cmdgo_modeInstall)
		}
	} else {
		a = &cmdgo_action{}
		var tools []*cmdgo_action
		for _, p := range pkgs {

			action := b.action(cmdgo_modeInstall, cmdgo_modeInstall, p)
			if cmdgo_goTools[p.ImportPath] == cmdgo_toTool && p.ImportPath != "cmd/cgo" {
				a.deps = append(a.deps, action.deps...)
				action.deps = append(action.deps, a)
				tools = append(tools, action)
				continue
			}
			a.deps = append(a.deps, action)
		}
		if len(tools) > 0 {
			a = &cmdgo_action{
				deps: tools,
			}
		}
	}
	b.do(a)
	cmdgo_exitIfErrors()

	if len(args) == 0 && len(pkgs) == 1 && pkgs[0].Name == "main" {

		_, targ := filepath.Split(pkgs[0].ImportPath)
		targ += cmdgo_exeSuffix
		if filepath.Join(pkgs[0].Dir, targ) != pkgs[0].Target {
			fi, err := os.Stat(targ)
			if err == nil {
				m := fi.Mode()
				if m.IsRegular() {
					if m&0111 != 0 || cmdgo_goos == "windows" {
						os.Remove(targ)
					}
				}
			}
		}
	}
}

// Global build parameters (used during package load)
var (
	cmdgo_goarch    string
	cmdgo_goos      string
	cmdgo_exeSuffix string
	cmdgo_gopath    []string
)

func init() {
	cmdgo_goarch = cmdgo_buildContext.GOARCH
	cmdgo_goos = cmdgo_buildContext.GOOS

	if cmdgo_goos == "windows" {
		cmdgo_exeSuffix = ".exe"
	}
	cmdgo_gopath = filepath.SplitList(cmdgo_buildContext.GOPATH)
}

// A builder holds global state about a build.
// It does not hold per-package state, because we
// build packages in parallel, and the builder is shared.
type cmdgo_builder struct {
	work        string                           // the temporary work directory (ends in filepath.Separator)
	actionCache map[cmdgo_cacheKey]*cmdgo_action // a cache of already-constructed actions
	mkdirCache  map[string]bool                  // a cache of created directories
	flagCache   map[string]bool                  // a cache of supported compiler flags
	print       func(args ...interface{}) (int, error)

	output    sync.Mutex
	scriptDir string // current directory in printed script

	exec      sync.Mutex
	readySema chan bool
	ready     cmdgo_actionQueue
}

// An action represents a single action in the action graph.
type cmdgo_action struct {
	p          *cmdgo_Package  // the package this action works on
	deps       []*cmdgo_action // actions that must happen before this one
	triggers   []*cmdgo_action // inverse of deps
	cgo        *cmdgo_action   // action for cgo binary if needed
	args       []string        // additional args for runProgram
	testOutput *bytes.Buffer   // test output buffer

	f          func(*cmdgo_builder, *cmdgo_action) error // the action itself (nil = no-op)
	ignoreFail bool                                      // whether to run f even if dependencies fail

	// Generated files, directories.
	link   bool   // target is executable, not just package
	pkgdir string // the -I or -L argument to use when importing this package
	objdir string // directory for intermediate objects
	objpkg string // the intermediate package .a file created during the action
	target string // goal of the action: the created package or executable

	// Execution state.
	pending  int  // number of deps yet to complete
	priority int  // relative execution priority
	failed   bool // whether the action failed
}

// cacheKey is the key for the action cache.
type cmdgo_cacheKey struct {
	mode  cmdgo_buildMode
	p     *cmdgo_Package
	shlib string
}

// buildMode specifies the build mode:
// are we just building things or also installing the results?
type cmdgo_buildMode int

const (
	cmdgo_modeBuild cmdgo_buildMode = iota
	cmdgo_modeInstall
)

var (
	cmdgo_goroot    = filepath.Clean(runtime.GOROOT())
	cmdgo_gobin     = os.Getenv("GOBIN")
	cmdgo_gorootBin = filepath.Join(cmdgo_goroot, "bin")
	cmdgo_gorootPkg = filepath.Join(cmdgo_goroot, "pkg")
	cmdgo_gorootSrc = filepath.Join(cmdgo_goroot, "src")
)

func (b *cmdgo_builder) init() {
	var err error
	b.print = func(a ...interface{}) (int, error) {
		return fmt.Fprint(os.Stderr, a...)
	}
	b.actionCache = make(map[cmdgo_cacheKey]*cmdgo_action)
	b.mkdirCache = make(map[string]bool)

	if cmdgo_buildN {
		b.work = "$WORK"
	} else {
		b.work, err = ioutil.TempDir("", "go-build")
		if err != nil {
			cmdgo_fatalf("%s", err)
		}
		if cmdgo_buildX || cmdgo_buildWork {
			fmt.Fprintf(os.Stderr, "WORK=%s\n", b.work)
		}
		if !cmdgo_buildWork {
			workdir := b.work
			cmdgo_atexit(func() { os.RemoveAll(workdir) })
		}
	}
}

// goFilesPackage creates a package for building a collection of Go files
// (typically named on the command line).  The target is named p.a for
// package p or named after the first Go file for package main.
func cmdgo_goFilesPackage(gofiles []string) *cmdgo_Package {

	for _, f := range gofiles {
		if !strings.HasSuffix(f, ".go") {
			cmdgo_fatalf("named files must be .go files")
		}
	}

	var stk cmdgo_importStack
	ctxt := cmdgo_buildContext
	ctxt.UseAllFiles = true

	// Synthesize fake "directory" that only shows the named files,
	// to make it look like this is a standard package or
	// command directory. So that local imports resolve
	// consistently, the files must all be in the same directory.
	var dirent []os.FileInfo
	var dir string
	for _, file := range gofiles {
		fi, err := os.Stat(file)
		if err != nil {
			cmdgo_fatalf("%s", err)
		}
		if fi.IsDir() {
			cmdgo_fatalf("%s is a directory, should be a Go file", file)
		}
		dir1, _ := filepath.Split(file)
		if dir1 == "" {
			dir1 = "./"
		}
		if dir == "" {
			dir = dir1
		} else if dir != dir1 {
			cmdgo_fatalf("named files must all be in one directory; have %s and %s", dir, dir1)
		}
		dirent = append(dirent, fi)
	}
	ctxt.ReadDir = func(string) ([]os.FileInfo, error) { return dirent, nil }

	var err error
	if dir == "" {
		dir = cmdgo_cwd
	}
	dir, err = filepath.Abs(dir)
	if err != nil {
		cmdgo_fatalf("%s", err)
	}

	bp, err := ctxt.ImportDir(dir, 0)
	pkg := new(cmdgo_Package)
	pkg.local = true
	pkg.cmdline = true
	stk.push("main")
	pkg.load(&stk, bp, err)
	stk.pop()
	pkg.localPrefix = cmdgo_dirToImportPath(dir)
	pkg.ImportPath = "command-line-arguments"
	pkg.target = ""

	if pkg.Name == "main" {
		_, elem := filepath.Split(gofiles[0])
		exe := elem[:len(elem)-len(".go")] + cmdgo_exeSuffix
		if *cmdgo_buildO == "" {
			*cmdgo_buildO = exe
		}
		if cmdgo_gobin != "" {
			pkg.target = filepath.Join(cmdgo_gobin, exe)
		}
	}

	pkg.Target = pkg.target
	pkg.Stale = true
	pkg.StaleReason = "files named on command line"

	cmdgo_computeStale(pkg)
	return pkg
}

// readpkglist returns the list of packages that were built into the shared library
// at shlibpath. For the native toolchain this list is stored, newline separated, in
// an ELF note with name "Go\x00\x00" and type 1. For GCCGO it is extracted from the
// .go_export section.
func cmdgo_readpkglist(shlibpath string) (pkgs []*cmdgo_Package) {
	var stk cmdgo_importStack
	if _, gccgo := cmdgo_buildToolchain.(cmdgo_gccgoToolchain); gccgo {
		f, _ := elf.Open(shlibpath)
		sect := f.Section(".go_export")
		data, _ := sect.Data()
		scanner := bufio.NewScanner(bytes.NewBuffer(data))
		for scanner.Scan() {
			t := scanner.Text()
			if strings.HasPrefix(t, "pkgpath ") {
				t = strings.TrimPrefix(t, "pkgpath ")
				t = strings.TrimSuffix(t, ";")
				pkgs = append(pkgs, cmdgo_loadPackage(t, &stk))
			}
		}
	} else {
		pkglistbytes, err := cmdgo_readELFNote(shlibpath, "Go\x00\x00", 1)
		if err != nil {
			cmdgo_fatalf("readELFNote failed: %v", err)
		}
		scanner := bufio.NewScanner(bytes.NewBuffer(pkglistbytes))
		for scanner.Scan() {
			t := scanner.Text()
			pkgs = append(pkgs, cmdgo_loadPackage(t, &stk))
		}
	}
	return
}

// action returns the action for applying the given operation (mode) to the package.
// depMode is the action to use when building dependencies.
// action never looks for p in a shared library, but may find p's dependencies in a
// shared library if buildLinkshared is true.
func (b *cmdgo_builder) action(mode cmdgo_buildMode, depMode cmdgo_buildMode, p *cmdgo_Package) *cmdgo_action {
	return b.action1(mode, depMode, p, false, "")
}

// action1 returns the action for applying the given operation (mode) to the package.
// depMode is the action to use when building dependencies.
// action1 will look for p in a shared library if lookshared is true.
// forShlib is the shared library that p will become part of, if any.
func (b *cmdgo_builder) action1(mode cmdgo_buildMode, depMode cmdgo_buildMode, p *cmdgo_Package, lookshared bool, forShlib string) *cmdgo_action {
	shlib := ""
	if lookshared {
		shlib = p.Shlib
	}
	key := cmdgo_cacheKey{mode, p, shlib}

	a := b.actionCache[key]
	if a != nil {
		return a
	}
	if shlib != "" {
		key2 := cmdgo_cacheKey{cmdgo_modeInstall, nil, shlib}
		a = b.actionCache[key2]
		if a != nil {
			b.actionCache[key] = a
			return a
		}
		pkgs := cmdgo_readpkglist(shlib)
		a = b.libaction(filepath.Base(shlib), pkgs, cmdgo_modeInstall, depMode)
		b.actionCache[key2] = a
		b.actionCache[key] = a
		return a
	}

	a = &cmdgo_action{p: p, pkgdir: p.build.PkgRoot}
	if p.pkgdir != "" {
		a.pkgdir = p.pkgdir
	}
	b.actionCache[key] = a

	for _, p1 := range p.imports {
		if forShlib != "" {

			if p1.Shlib != "" && p1.Shlib != forShlib {

				a.deps = append(a.deps, b.action1(depMode, depMode, p1, true, p1.Shlib))
			} else {

				a.deps = append(a.deps, b.action1(depMode, depMode, p1, false, forShlib))
			}
		} else {

			a.deps = append(a.deps, b.action1(depMode, depMode, p1, cmdgo_buildLinkshared, p1.Shlib))
		}
	}

	if cmdgo_goos == runtime.GOOS && cmdgo_goarch == runtime.GOARCH && !cmdgo_buildRace && !cmdgo_buildMSan {
		if (len(p.CgoFiles) > 0 || p.Standard && p.ImportPath == "runtime/cgo") && !cmdgo_buildLinkshared && cmdgo_buildBuildmode != "shared" {
			var stk cmdgo_importStack
			p1 := cmdgo_loadPackage("cmd/cgo", &stk)
			if p1.Error != nil {
				cmdgo_fatalf("load cmd/cgo: %v", p1.Error)
			}
			a.cgo = b.action(depMode, depMode, p1)
			a.deps = append(a.deps, a.cgo)
		}
	}

	if p.Standard {
		switch p.ImportPath {
		case "builtin", "unsafe":

			return a
		}

		if _, ok := cmdgo_buildToolchain.(cmdgo_gccgoToolchain); ok {

			a.target = p.target
			return a
		}
	}

	if !p.Stale && p.target != "" {

		a.target = p.target
		return a
	}

	if p.local && p.target == "" {

		mode = cmdgo_modeBuild
	}
	work := p.pkgdir
	if work == "" {
		work = b.work
	}
	a.objdir = filepath.Join(work, a.p.ImportPath, "_obj") + string(filepath.Separator)
	a.objpkg = cmdgo_buildToolchain.pkgpath(work, a.p)
	a.link = p.Name == "main"

	switch mode {
	case cmdgo_modeInstall:
		a.f = (*cmdgo_builder).install
		a.deps = []*cmdgo_action{b.action1(cmdgo_modeBuild, depMode, p, lookshared, forShlib)}
		a.target = a.p.target

		if p.usesCgo() && (cmdgo_buildBuildmode == "c-archive" || cmdgo_buildBuildmode == "c-shared") {
			hdrTarget := a.target[:len(a.target)-len(filepath.Ext(a.target))] + ".h"
			if cmdgo_buildContext.Compiler == "gccgo" {

				dir, file := filepath.Split(hdrTarget)
				file = strings.TrimPrefix(file, "lib")
				hdrTarget = filepath.Join(dir, file)
			}
			ah := &cmdgo_action{
				p:      a.p,
				deps:   []*cmdgo_action{a.deps[0]},
				f:      (*cmdgo_builder).installHeader,
				pkgdir: a.pkgdir,
				objdir: a.objdir,
				target: hdrTarget,
			}
			a.deps = append(a.deps, ah)
		}

	case cmdgo_modeBuild:
		a.f = (*cmdgo_builder).build
		a.target = a.objpkg
		if a.link {

			name := "a.out"
			if p.exeName != "" {
				name = p.exeName
			} else if cmdgo_goos == "darwin" && cmdgo_buildBuildmode == "c-shared" && p.target != "" {

				_, name = filepath.Split(p.target)
			}
			a.target = a.objdir + filepath.Join("exe", name) + cmdgo_exeSuffix
		}
	}

	return a
}

func (b *cmdgo_builder) libaction(libname string, pkgs []*cmdgo_Package, mode, depMode cmdgo_buildMode) *cmdgo_action {
	a := &cmdgo_action{}
	switch mode {
	default:
		cmdgo_fatalf("unrecognized mode %v", mode)

	case cmdgo_modeBuild:
		a.f = (*cmdgo_builder).linkShared
		a.target = filepath.Join(b.work, libname)
		for _, p := range pkgs {
			if p.target == "" {
				continue
			}
			a.deps = append(a.deps, b.action(depMode, depMode, p))
		}

	case cmdgo_modeInstall:

		_, gccgo := cmdgo_buildToolchain.(cmdgo_gccgoToolchain)
		if !gccgo {
			seencgo := false
			for _, p := range pkgs {
				seencgo = seencgo || (p.Standard && p.ImportPath == "runtime/cgo")
			}
			if !seencgo {
				var stk cmdgo_importStack
				p := cmdgo_loadPackage("runtime/cgo", &stk)
				if p.Error != nil {
					cmdgo_fatalf("load runtime/cgo: %v", p.Error)
				}
				cmdgo_computeStale(p)

				if p.Shlib == "" || p.Shlib == libname {
					pkgs = append([]*cmdgo_Package{}, pkgs...)
					pkgs = append(pkgs, p)
				}
			}
			if cmdgo_goarch == "arm" {
				seenmath := false
				for _, p := range pkgs {
					seenmath = seenmath || (p.Standard && p.ImportPath == "math")
				}
				if !seenmath {
					var stk cmdgo_importStack
					p := cmdgo_loadPackage("math", &stk)
					if p.Error != nil {
						cmdgo_fatalf("load math: %v", p.Error)
					}
					cmdgo_computeStale(p)

					if p.Shlib == "" || p.Shlib == libname {
						pkgs = append([]*cmdgo_Package{}, pkgs...)
						pkgs = append(pkgs, p)
					}
				}
			}
		}

		// Figure out where the library will go.
		var libdir string
		for _, p := range pkgs {
			plibdir := p.build.PkgTargetRoot
			if gccgo {
				plibdir = filepath.Join(plibdir, "shlibs")
			}
			if libdir == "" {
				libdir = plibdir
			} else if libdir != plibdir {
				cmdgo_fatalf("multiple roots %s & %s", libdir, plibdir)
			}
		}
		a.target = filepath.Join(libdir, libname)

		stale := false
		var built time.Time
		if fi, err := os.Stat(a.target); err == nil {
			built = fi.ModTime()
		}
		for _, p := range pkgs {
			if p.target == "" {
				continue
			}
			stale = stale || p.Stale
			lstat, err := os.Stat(p.target)
			if err != nil || lstat.ModTime().After(built) {
				stale = true
			}
			a.deps = append(a.deps, b.action1(depMode, depMode, p, false, a.target))
		}

		if stale {
			a.f = (*cmdgo_builder).install
			buildAction := b.libaction(libname, pkgs, cmdgo_modeBuild, depMode)
			a.deps = []*cmdgo_action{buildAction}
			for _, p := range pkgs {
				if p.target == "" {
					continue
				}
				shlibnameaction := &cmdgo_action{}
				shlibnameaction.f = (*cmdgo_builder).installShlibname
				shlibnameaction.target = p.target[:len(p.target)-2] + ".shlibname"
				a.deps = append(a.deps, shlibnameaction)
				shlibnameaction.deps = append(shlibnameaction.deps, buildAction)
			}
		}
	}
	return a
}

// actionList returns the list of actions in the dag rooted at root
// as visited in a depth-first post-order traversal.
func cmdgo_actionList(root *cmdgo_action) []*cmdgo_action {
	seen := map[*cmdgo_action]bool{}
	all := []*cmdgo_action{}
	var walk func(*cmdgo_action)
	walk = func(a *cmdgo_action) {
		if seen[a] {
			return
		}
		seen[a] = true
		for _, a1 := range a.deps {
			walk(a1)
		}
		all = append(all, a)
	}
	walk(root)
	return all
}

// allArchiveActions returns a list of the archive dependencies of root.
// This is needed because if package p depends on package q that is in libr.so, the
// action graph looks like p->libr.so->q and so just scanning through p's
// dependencies does not find the import dir for q.
func cmdgo_allArchiveActions(root *cmdgo_action) []*cmdgo_action {
	seen := map[*cmdgo_action]bool{}
	r := []*cmdgo_action{}
	var walk func(*cmdgo_action)
	walk = func(a *cmdgo_action) {
		if seen[a] {
			return
		}
		seen[a] = true
		if strings.HasSuffix(a.target, ".so") || a == root {
			for _, a1 := range a.deps {
				walk(a1)
			}
		} else if strings.HasSuffix(a.target, ".a") {
			r = append(r, a)
		}
	}
	walk(root)
	return r
}

// do runs the action graph rooted at root.
func (b *cmdgo_builder) do(root *cmdgo_action) {
	if _, ok := cmdgo_osArchSupportsCgo[cmdgo_goos+"/"+cmdgo_goarch]; !ok && cmdgo_buildContext.Compiler == "gc" {
		fmt.Fprintf(os.Stderr, "cmd/go: unsupported GOOS/GOARCH pair %s/%s\n", cmdgo_goos, cmdgo_goarch)
		os.Exit(2)
	}

	all := cmdgo_actionList(root)
	for i, a := range all {
		a.priority = i
	}

	b.readySema = make(chan bool, len(all))

	for _, a := range all {
		for _, a1 := range a.deps {
			a1.triggers = append(a1.triggers, a)
		}
		a.pending = len(a.deps)
		if a.pending == 0 {
			b.ready.push(a)
			b.readySema <- true
		}
	}

	handle := func(a *cmdgo_action) {
		var err error
		if a.f != nil && (!a.failed || a.ignoreFail) {
			err = a.f(b, a)
		}

		b.exec.Lock()
		defer b.exec.Unlock()

		if err != nil {
			if err == cmdgo_errPrintedOutput {
				cmdgo_setExitStatus(2)
			} else {
				cmdgo_errorf("%s", err)
			}
			a.failed = true
		}

		for _, a0 := range a.triggers {
			if a.failed {
				a0.failed = true
			}
			if a0.pending--; a0.pending == 0 {
				b.ready.push(a0)
				b.readySema <- true
			}
		}

		if a == root {
			close(b.readySema)
		}
	}

	var wg sync.WaitGroup

	par := cmdgo_buildP
	if cmdgo_buildN {
		par = 1
	}
	for i := 0; i < par; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for {
				select {
				case _, ok := <-b.readySema:
					if !ok {
						return
					}

					b.exec.Lock()
					a := b.ready.pop()
					b.exec.Unlock()
					handle(a)
				case <-cmdgo_interrupted:
					cmdgo_setExitStatus(1)
					return
				}
			}
		}()
	}

	wg.Wait()
}

// build is the action for building a single package or command.
func (b *cmdgo_builder) build(a *cmdgo_action) (err error) {

	if a.p.BinaryOnly {
		return fmt.Errorf("missing or invalid package binary for binary-only package %s", a.p.ImportPath)
	}

	if len(a.p.CXXFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {
		return fmt.Errorf("can't build package %s because it contains C++ files (%s) but it's not using cgo nor SWIG",
			a.p.ImportPath, strings.Join(a.p.CXXFiles, ","))
	}

	if len(a.p.MFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {
		return fmt.Errorf("can't build package %s because it contains Objective-C files (%s) but it's not using cgo nor SWIG",
			a.p.ImportPath, strings.Join(a.p.MFiles, ","))
	}

	if len(a.p.FFiles) > 0 && !a.p.usesCgo() && !a.p.usesSwig() {
		return fmt.Errorf("can't build package %s because it contains Fortran files (%s) but it's not using cgo nor SWIG",
			a.p.ImportPath, strings.Join(a.p.FFiles, ","))
	}

	defer func() {
		if err != nil && err != cmdgo_errPrintedOutput {
			err = fmt.Errorf("go build %s: %v", a.p.ImportPath, err)
		}
	}()
	if cmdgo_buildN {

		b.print("\n#\n# " + a.p.ImportPath + "\n#\n\n")
	}

	if cmdgo_buildV {
		b.print(a.p.ImportPath + "\n")
	}

	obj := a.objdir
	if err := b.mkdir(obj); err != nil {
		return err
	}

	dir, _ := filepath.Split(a.target)
	if dir != "" {
		if err := b.mkdir(dir); err != nil {
			return err
		}
	}

	var gofiles, cgofiles, cfiles, sfiles, cxxfiles, objects, cgoObjects, pcCFLAGS, pcLDFLAGS []string

	gofiles = append(gofiles, a.p.GoFiles...)
	cgofiles = append(cgofiles, a.p.CgoFiles...)
	cfiles = append(cfiles, a.p.CFiles...)
	sfiles = append(sfiles, a.p.SFiles...)
	cxxfiles = append(cxxfiles, a.p.CXXFiles...)

	if a.p.usesCgo() || a.p.usesSwig() {
		if pcCFLAGS, pcLDFLAGS, err = b.getPkgConfigFlags(a.p); err != nil {
			return
		}
	}

	if a.p.usesSwig() {
		outGo, outC, outCXX, err := b.swig(a.p, obj, pcCFLAGS)
		if err != nil {
			return err
		}
		cgofiles = append(cgofiles, outGo...)
		cfiles = append(cfiles, outC...)
		cxxfiles = append(cxxfiles, outCXX...)
	}

	if a.p.usesCgo() || a.p.usesSwig() {
		// In a package using cgo, cgo compiles the C, C++ and assembly files with gcc.
		// There is one exception: runtime/cgo's job is to bridge the
		// cgo and non-cgo worlds, so it necessarily has files in both.
		// In that case gcc only gets the gcc_* files.
		var gccfiles []string
		gccfiles = append(gccfiles, cfiles...)
		cfiles = nil
		if a.p.Standard && a.p.ImportPath == "runtime/cgo" {
			filter := func(files, nongcc, gcc []string) ([]string, []string) {
				for _, f := range files {
					if strings.HasPrefix(f, "gcc_") {
						gcc = append(gcc, f)
					} else {
						nongcc = append(nongcc, f)
					}
				}
				return nongcc, gcc
			}
			sfiles, gccfiles = filter(sfiles, sfiles[:0], gccfiles)
		} else {
			gccfiles = append(gccfiles, sfiles...)
			sfiles = nil
		}

		cgoExe := cmdgo_tool("cgo")
		if a.cgo != nil && a.cgo.target != "" {
			cgoExe = a.cgo.target
		}
		outGo, outObj, err := b.cgo(a.p, cgoExe, obj, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, cxxfiles, a.p.MFiles, a.p.FFiles)
		if err != nil {
			return err
		}
		if _, ok := cmdgo_buildToolchain.(cmdgo_gccgoToolchain); ok {
			cgoObjects = append(cgoObjects, filepath.Join(a.objdir, "_cgo_flags"))
		}
		cgoObjects = append(cgoObjects, outObj...)
		gofiles = append(gofiles, outGo...)
	}

	if len(gofiles) == 0 {
		return &build.NoGoError{Dir: a.p.Dir}
	}

	if a.p.coverMode != "" {
		for i, file := range gofiles {
			var sourceFile string
			var coverFile string
			var key string
			if strings.HasSuffix(file, ".cgo1.go") {

				base := filepath.Base(file)
				sourceFile = file
				coverFile = filepath.Join(obj, base)
				key = strings.TrimSuffix(base, ".cgo1.go") + ".go"
			} else {
				sourceFile = filepath.Join(a.p.Dir, file)
				coverFile = filepath.Join(obj, file)
				key = file
			}
			cover := a.p.coverVars[key]
			if cover == nil || cmdgo_isTestFile(file) {

				continue
			}
			if err := b.cover(a, coverFile, sourceFile, 0666, cover.Var); err != nil {
				return err
			}
			gofiles[i] = coverFile
		}
	}

	inc := b.includeArgs("-I", cmdgo_allArchiveActions(a))

	ofile, out, err := cmdgo_buildToolchain.gc(b, a.p, a.objpkg, obj, len(sfiles) > 0, inc, gofiles)
	if len(out) > 0 {
		b.showOutput(a.p.Dir, a.p.ImportPath, b.processOutput(out))
		if err != nil {
			return cmdgo_errPrintedOutput
		}
	}
	if err != nil {
		return err
	}
	if ofile != a.objpkg {
		objects = append(objects, ofile)
	}

	_goos_goarch := "_" + cmdgo_goos + "_" + cmdgo_goarch
	_goos := "_" + cmdgo_goos
	_goarch := "_" + cmdgo_goarch
	for _, file := range a.p.HFiles {
		name, ext := cmdgo_fileExtSplit(file)
		switch {
		case strings.HasSuffix(name, _goos_goarch):
			targ := file[:len(name)-len(_goos_goarch)] + "_GOOS_GOARCH." + ext
			if err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0666, true); err != nil {
				return err
			}
		case strings.HasSuffix(name, _goarch):
			targ := file[:len(name)-len(_goarch)] + "_GOARCH." + ext
			if err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0666, true); err != nil {
				return err
			}
		case strings.HasSuffix(name, _goos):
			targ := file[:len(name)-len(_goos)] + "_GOOS." + ext
			if err := b.copyFile(a, obj+targ, filepath.Join(a.p.Dir, file), 0666, true); err != nil {
				return err
			}
		}
	}

	for _, file := range cfiles {
		out := file[:len(file)-len(".c")] + ".o"
		if err := cmdgo_buildToolchain.cc(b, a.p, obj, obj+out, file); err != nil {
			return err
		}
		objects = append(objects, out)
	}

	for _, file := range sfiles {
		out := file[:len(file)-len(".s")] + ".o"
		if err := cmdgo_buildToolchain.asm(b, a.p, obj, obj+out, file); err != nil {
			return err
		}
		objects = append(objects, out)
	}

	objects = append(objects, cgoObjects...)

	for _, syso := range a.p.SysoFiles {
		objects = append(objects, filepath.Join(a.p.Dir, syso))
	}

	if len(objects) > 0 {
		if err := cmdgo_buildToolchain.pack(b, a.p, obj, a.objpkg, objects); err != nil {
			return err
		}
	}

	if a.link {

		all := cmdgo_actionList(a)
		all = all[:len(all)-1]
		if err := cmdgo_buildToolchain.ld(b, a, a.target, all, a.objpkg, objects); err != nil {
			return err
		}
	}

	return nil
}

// Calls pkg-config if needed and returns the cflags/ldflags needed to build the package.
func (b *cmdgo_builder) getPkgConfigFlags(p *cmdgo_Package) (cflags, ldflags []string, err error) {
	if pkgs := p.CgoPkgConfig; len(pkgs) > 0 {
		var out []byte
		out, err = b.runOut(p.Dir, p.ImportPath, nil, "pkg-config", "--cflags", pkgs)
		if err != nil {
			b.showOutput(p.Dir, "pkg-config --cflags "+strings.Join(pkgs, " "), string(out))
			b.print(err.Error() + "\n")
			err = cmdgo_errPrintedOutput
			return
		}
		if len(out) > 0 {
			cflags = strings.Fields(string(out))
		}
		out, err = b.runOut(p.Dir, p.ImportPath, nil, "pkg-config", "--libs", pkgs)
		if err != nil {
			b.showOutput(p.Dir, "pkg-config --libs "+strings.Join(pkgs, " "), string(out))
			b.print(err.Error() + "\n")
			err = cmdgo_errPrintedOutput
			return
		}
		if len(out) > 0 {
			ldflags = strings.Fields(string(out))
		}
	}
	return
}

func (b *cmdgo_builder) installShlibname(a *cmdgo_action) error {
	a1 := a.deps[0]
	err := ioutil.WriteFile(a.target, []byte(filepath.Base(a1.target)+"\n"), 0666)
	if err != nil {
		return err
	}
	if cmdgo_buildX {
		b.showcmd("", "echo '%s' > %s # internal", filepath.Base(a1.target), a.target)
	}
	return nil
}

func (b *cmdgo_builder) linkShared(a *cmdgo_action) (err error) {
	allactions := cmdgo_actionList(a)
	allactions = allactions[:len(allactions)-1]
	return cmdgo_buildToolchain.ldShared(b, a.deps, a.target, allactions)
}

// install is the action for installing a single package or executable.
func (b *cmdgo_builder) install(a *cmdgo_action) (err error) {
	defer func() {
		if err != nil && err != cmdgo_errPrintedOutput {
			err = fmt.Errorf("go install %s: %v", a.p.ImportPath, err)
		}
	}()
	a1 := a.deps[0]
	perm := os.FileMode(0666)
	if a1.link {
		switch cmdgo_buildBuildmode {
		case "c-archive", "c-shared":
		default:
			perm = 0777
		}
	}

	dir, _ := filepath.Split(a.target)
	if dir != "" {
		if err := b.mkdir(dir); err != nil {
			return err
		}
	}

	if !cmdgo_buildWork {
		defer os.RemoveAll(a1.objdir)
		defer os.Remove(a1.target)
	}

	return b.moveOrCopyFile(a, a.target, a1.target, perm, false)
}

// includeArgs returns the -I or -L directory list for access
// to the results of the list of actions.
func (b *cmdgo_builder) includeArgs(flag string, all []*cmdgo_action) []string {
	inc := []string{}
	incMap := map[string]bool{
		b.work:          true,
		cmdgo_gorootPkg: true,
		"":              true,
	}

	for _, a1 := range all {
		if a1.p == nil {
			continue
		}
		if dir := a1.pkgdir; dir != a1.p.build.PkgRoot && !incMap[dir] {
			incMap[dir] = true
			inc = append(inc, flag, dir)
		}
	}

	inc = append(inc, flag, b.work)

	need := map[string]*build.Package{}
	for _, a1 := range all {
		if a1.p != nil && a1.pkgdir == a1.p.build.PkgRoot {
			need[a1.p.build.Root] = a1.p.build
		}
	}
	for _, root := range cmdgo_gopath {
		if p := need[root]; p != nil && !incMap[p.PkgRoot] {
			incMap[p.PkgRoot] = true
			inc = append(inc, flag, p.PkgTargetRoot)
		}
	}

	for _, a1 := range all {
		if a1.p == nil {
			continue
		}
		if dir := a1.pkgdir; dir == a1.p.build.PkgRoot && !incMap[dir] {
			incMap[dir] = true
			inc = append(inc, flag, a1.p.build.PkgTargetRoot)
		}
	}

	return inc
}

// moveOrCopyFile is like 'mv src dst' or 'cp src dst'.
func (b *cmdgo_builder) moveOrCopyFile(a *cmdgo_action, dst, src string, perm os.FileMode, force bool) error {
	if cmdgo_buildN {
		b.showcmd("", "mv %s %s", src, dst)
		return nil
	}

	mode := perm
	f, err := os.OpenFile(filepath.Clean(dst)+"-go-tmp-umask", os.O_WRONLY|os.O_CREATE|os.O_EXCL, perm)
	if err == nil {
		fi, err := f.Stat()
		if err == nil {
			mode = fi.Mode() & 0777
		}
		name := f.Name()
		f.Close()
		os.Remove(name)
	}

	if err := os.Chmod(src, mode); err == nil {
		if err := os.Rename(src, dst); err == nil {
			if cmdgo_buildX {
				b.showcmd("", "mv %s %s", src, dst)
			}
			return nil
		}
	}

	return b.copyFile(a, dst, src, perm, force)
}

// copyFile is like 'cp src dst'.
func (b *cmdgo_builder) copyFile(a *cmdgo_action, dst, src string, perm os.FileMode, force bool) error {
	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd("", "cp %s %s", src, dst)
		if cmdgo_buildN {
			return nil
		}
	}

	sf, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sf.Close()

	if fi, err := os.Stat(dst); err == nil {
		if fi.IsDir() {
			return fmt.Errorf("build output %q already exists and is a directory", dst)
		}
		if !force && fi.Mode().IsRegular() && !cmdgo_isObject(dst) {
			return fmt.Errorf("build output %q already exists and is not an object file", dst)
		}
	}

	if cmdgo_toolIsWindows {
		if _, err := os.Stat(dst + "~"); err == nil {
			os.Remove(dst + "~")
		}
	}

	cmdgo_mayberemovefile(dst)
	df, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	if err != nil && cmdgo_toolIsWindows {

		if err := os.Rename(dst, dst+"~"); err == nil {
			os.Remove(dst + "~")
		}
		df, err = os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)
	}
	if err != nil {
		return err
	}

	_, err = io.Copy(df, sf)
	df.Close()
	if err != nil {
		cmdgo_mayberemovefile(dst)
		return fmt.Errorf("copying %s to %s: %v", src, dst, err)
	}
	return nil
}

// Install the cgo export header file, if there is one.
func (b *cmdgo_builder) installHeader(a *cmdgo_action) error {
	src := a.objdir + "_cgo_install.h"
	if _, err := os.Stat(src); os.IsNotExist(err) {

		return nil
	}

	dir, _ := filepath.Split(a.target)
	if dir != "" {
		if err := b.mkdir(dir); err != nil {
			return err
		}
	}

	return b.moveOrCopyFile(a, a.target, src, 0666, true)
}

// cover runs, in effect,
//	go tool cover -mode=b.coverMode -var="varName" -o dst.go src.go
func (b *cmdgo_builder) cover(a *cmdgo_action, dst, src string, perm os.FileMode, varName string) error {
	return b.run(a.objdir, "cover "+a.p.ImportPath, nil,
		cmdgo_buildToolExec,
		cmdgo_tool("cover"),
		"-mode", a.p.coverMode,
		"-var", varName,
		"-o", dst,
		src)
}

var cmdgo_objectMagic = [][]byte{
	{'!', '<', 'a', 'r', 'c', 'h', '>', '\n'},
	{'\x7F', 'E', 'L', 'F'},
	{0xFE, 0xED, 0xFA, 0xCE},
	{0xFE, 0xED, 0xFA, 0xCF},
	{0xCE, 0xFA, 0xED, 0xFE},
	{0xCF, 0xFA, 0xED, 0xFE},
	{0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00},
	{0x00, 0x00, 0x01, 0xEB},
	{0x00, 0x00, 0x8a, 0x97},
	{0x00, 0x00, 0x06, 0x47},
}

func cmdgo_isObject(s string) bool {
	f, err := os.Open(s)
	if err != nil {
		return false
	}
	defer f.Close()
	buf := make([]byte, 64)
	io.ReadFull(f, buf)
	for _, magic := range cmdgo_objectMagic {
		if bytes.HasPrefix(buf, magic) {
			return true
		}
	}
	return false
}

// mayberemovefile removes a file only if it is a regular file
// When running as a user with sufficient privileges, we may delete
// even device files, for example, which is not intended.
func cmdgo_mayberemovefile(s string) {
	if fi, err := os.Lstat(s); err == nil && !fi.Mode().IsRegular() {
		return
	}
	os.Remove(s)
}

// fmtcmd formats a command in the manner of fmt.Sprintf but also:
//
//	If dir is non-empty and the script is not in dir right now,
//	fmtcmd inserts "cd dir\n" before the command.
//
//	fmtcmd replaces the value of b.work with $WORK.
//	fmtcmd replaces the value of goroot with $GOROOT.
//	fmtcmd replaces the value of b.gobin with $GOBIN.
//
//	fmtcmd replaces the name of the current directory with dot (.)
//	but only when it is at the beginning of a space-separated token.
//
func (b *cmdgo_builder) fmtcmd(dir string, format string, args ...interface{}) string {
	cmd := fmt.Sprintf(format, args...)
	if dir != "" && dir != "/" {
		cmd = strings.Replace(" "+cmd, " "+dir, " .", -1)[1:]
		if b.scriptDir != dir {
			b.scriptDir = dir
			cmd = "cd " + dir + "\n" + cmd
		}
	}
	if b.work != "" {
		cmd = strings.Replace(cmd, b.work, "$WORK", -1)
	}
	return cmd
}

// showcmd prints the given command to standard output
// for the implementation of -n or -x.
func (b *cmdgo_builder) showcmd(dir string, format string, args ...interface{}) {
	b.output.Lock()
	defer b.output.Unlock()
	b.print(b.fmtcmd(dir, format, args...) + "\n")
}

// showOutput prints "# desc" followed by the given output.
// The output is expected to contain references to 'dir', usually
// the source directory for the package that has failed to build.
// showOutput rewrites mentions of dir with a relative path to dir
// when the relative path is shorter. This is usually more pleasant.
// For example, if fmt doesn't compile and we are in src/html,
// the output is
//
//	$ go build
//	# fmt
//	../fmt/print.go:1090: undefined: asdf
//	$
//
// instead of
//
//	$ go build
//	# fmt
//	/usr/gopher/go/src/fmt/print.go:1090: undefined: asdf
//	$
//
// showOutput also replaces references to the work directory with $WORK.
//
func (b *cmdgo_builder) showOutput(dir, desc, out string) {
	prefix := "# " + desc
	suffix := "\n" + out
	if reldir := cmdgo_shortPath(dir); reldir != dir {
		suffix = strings.Replace(suffix, " "+dir, " "+reldir, -1)
		suffix = strings.Replace(suffix, "\n"+dir, "\n"+reldir, -1)
	}
	suffix = strings.Replace(suffix, " "+b.work, " $WORK", -1)

	b.output.Lock()
	defer b.output.Unlock()
	b.print(prefix, suffix)
}

// shortPath returns an absolute or relative name for path, whatever is shorter.
func cmdgo_shortPath(path string) string {
	if rel, err := filepath.Rel(cmdgo_cwd, path); err == nil && len(rel) < len(path) {
		return rel
	}
	return path
}

// relPaths returns a copy of paths with absolute paths
// made relative to the current directory if they would be shorter.
func cmdgo_relPaths(paths []string) []string {
	var out []string
	pwd, _ := os.Getwd()
	for _, p := range paths {
		rel, err := filepath.Rel(pwd, p)
		if err == nil && len(rel) < len(p) {
			p = rel
		}
		out = append(out, p)
	}
	return out
}

// errPrintedOutput is a special error indicating that a command failed
// but that it generated output as well, and that output has already
// been printed, so there's no point showing 'exit status 1' or whatever
// the wait status was. The main executor, builder.do, knows not to
// print this error.
var cmdgo_errPrintedOutput = errors.New("already printed output - no need to show error")

var cmdgo_cgoLine = regexp.MustCompile(`\[[^\[\]]+\.cgo1\.go:[0-9]+\]`)

var cmdgo_cgoTypeSigRe = regexp.MustCompile(`\b_Ctype_\B`)

// run runs the command given by cmdline in the directory dir.
// If the command fails, run prints information about the failure
// and returns a non-nil error.
func (b *cmdgo_builder) run(dir string, desc string, env []string, cmdargs ...interface{}) error {
	out, err := b.runOut(dir, desc, env, cmdargs...)
	if len(out) > 0 {
		if desc == "" {
			desc = b.fmtcmd(dir, "%s", strings.Join(cmdgo_stringList(cmdargs...), " "))
		}
		b.showOutput(dir, desc, b.processOutput(out))
		if err != nil {
			err = cmdgo_errPrintedOutput
		}
	}
	return err
}

// processOutput prepares the output of runOut to be output to the console.
func (b *cmdgo_builder) processOutput(out []byte) string {
	if out[len(out)-1] != '\n' {
		out = append(out, '\n')
	}
	messages := string(out)

	if !cmdgo_buildX && cmdgo_cgoLine.MatchString(messages) {
		messages = cmdgo_cgoLine.ReplaceAllString(messages, "")
		messages = cmdgo_cgoTypeSigRe.ReplaceAllString(messages, "C.")
	}
	return messages
}

// runOut runs the command given by cmdline in the directory dir.
// It returns the command output and any errors that occurred.
func (b *cmdgo_builder) runOut(dir string, desc string, env []string, cmdargs ...interface{}) ([]byte, error) {
	cmdline := cmdgo_stringList(cmdargs...)
	if cmdgo_buildN || cmdgo_buildX {
		var envcmdline string
		for i := range env {
			envcmdline += env[i]
			envcmdline += " "
		}
		envcmdline += cmdgo_joinUnambiguously(cmdline)
		b.showcmd(dir, "%s", envcmdline)
		if cmdgo_buildN {
			return nil, nil
		}
	}

	nbusy := 0
	for {
		var buf bytes.Buffer
		cmd := exec.Command(cmdline[0], cmdline[1:]...)
		cmd.Stdout = &buf
		cmd.Stderr = &buf
		cmd.Dir = dir
		cmd.Env = cmdgo_mergeEnvLists(env, cmdgo_envForDir(cmd.Dir, os.Environ()))
		err := cmd.Run()

		if err != nil && nbusy < 3 && strings.Contains(err.Error(), "text file busy") {
			time.Sleep(100 * time.Millisecond << uint(nbusy))
			nbusy++
			continue
		}

		if err != nil {
			err = errors.New(cmdline[0] + ": " + err.Error())
		}
		return buf.Bytes(), err
	}
}

// joinUnambiguously prints the slice, quoting where necessary to make the
// output unambiguous.
// TODO: See issue 5279. The printing of commands needs a complete redo.
func cmdgo_joinUnambiguously(a []string) string {
	var buf bytes.Buffer
	for i, s := range a {
		if i > 0 {
			buf.WriteByte(' ')
		}
		q := strconv.Quote(s)
		if s == "" || strings.Contains(s, " ") || len(q) > len(s)+2 {
			buf.WriteString(q)
		} else {
			buf.WriteString(s)
		}
	}
	return buf.String()
}

// mkdir makes the named directory.
func (b *cmdgo_builder) mkdir(dir string) error {
	b.exec.Lock()
	defer b.exec.Unlock()

	if b.mkdirCache[dir] {
		return nil
	}
	b.mkdirCache[dir] = true

	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd("", "mkdir -p %s", dir)
		if cmdgo_buildN {
			return nil
		}
	}

	if err := os.MkdirAll(dir, 0777); err != nil {
		return err
	}
	return nil
}

// mkAbs returns an absolute path corresponding to
// evaluating f in the directory dir.
// We always pass absolute paths of source files so that
// the error messages will include the full path to a file
// in need of attention.
func cmdgo_mkAbs(dir, f string) string {

	if filepath.IsAbs(f) || strings.HasPrefix(f, "$WORK") {
		return f
	}
	return filepath.Join(dir, f)
}

type cmdgo_toolchain interface {
	// gc runs the compiler in a specific directory on a set of files
	// and returns the name of the generated output file.
	gc(b *cmdgo_builder, p *cmdgo_Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error)
	// cc runs the toolchain's C compiler in a directory on a C file
	// to produce an output file.
	cc(b *cmdgo_builder, p *cmdgo_Package, objdir, ofile, cfile string) error
	// asm runs the assembler in a specific directory on a specific file
	// to generate the named output file.
	asm(b *cmdgo_builder, p *cmdgo_Package, obj, ofile, sfile string) error
	// pkgpath builds an appropriate path for a temporary package file.
	pkgpath(basedir string, p *cmdgo_Package) string
	// pack runs the archive packer in a specific directory to create
	// an archive from a set of object files.
	// typically it is run in the object directory.
	pack(b *cmdgo_builder, p *cmdgo_Package, objDir, afile string, ofiles []string) error
	// ld runs the linker to create an executable starting at mainpkg.
	ld(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string) error
	// ldShared runs the linker to create a shared library containing the pkgs built by toplevelactions
	ldShared(b *cmdgo_builder, toplevelactions []*cmdgo_action, out string, allactions []*cmdgo_action) error

	compiler() string
	linker() string
}

type cmdgo_noToolchain struct{}

func cmdgo_noCompiler() error {
	log.Fatalf("unknown compiler %q", cmdgo_buildContext.Compiler)
	return nil
}

func (cmdgo_noToolchain) compiler() string {
	cmdgo_noCompiler()
	return ""
}

func (cmdgo_noToolchain) linker() string {
	cmdgo_noCompiler()
	return ""
}

func (cmdgo_noToolchain) gc(b *cmdgo_builder, p *cmdgo_Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error) {
	return "", nil, cmdgo_noCompiler()
}

func (cmdgo_noToolchain) asm(b *cmdgo_builder, p *cmdgo_Package, obj, ofile, sfile string) error {
	return cmdgo_noCompiler()
}

func (cmdgo_noToolchain) pkgpath(basedir string, p *cmdgo_Package) string {
	cmdgo_noCompiler()
	return ""
}

func (cmdgo_noToolchain) pack(b *cmdgo_builder, p *cmdgo_Package, objDir, afile string, ofiles []string) error {
	return cmdgo_noCompiler()
}

func (cmdgo_noToolchain) ld(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string) error {
	return cmdgo_noCompiler()
}

func (cmdgo_noToolchain) ldShared(b *cmdgo_builder, toplevelactions []*cmdgo_action, out string, allactions []*cmdgo_action) error {
	return cmdgo_noCompiler()
}

func (cmdgo_noToolchain) cc(b *cmdgo_builder, p *cmdgo_Package, objdir, ofile, cfile string) error {
	return cmdgo_noCompiler()
}

// The Go toolchain.
type cmdgo_gcToolchain struct{}

func (cmdgo_gcToolchain) compiler() string {
	return cmdgo_tool("compile")
}

func (cmdgo_gcToolchain) linker() string {
	return cmdgo_tool("link")
}

func (cmdgo_gcToolchain) gc(b *cmdgo_builder, p *cmdgo_Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {
	if archive != "" {
		ofile = archive
	} else {
		out := "_go_.o"
		ofile = obj + out
	}

	gcargs := []string{"-p", p.ImportPath}
	if p.Name == "main" {
		gcargs[1] = "main"
	}
	if p.Standard && (p.ImportPath == "runtime" || strings.HasPrefix(p.ImportPath, "runtime/internal")) {

		gcargs = append(gcargs, "-+")
	}

	extFiles := len(p.CgoFiles) + len(p.CFiles) + len(p.CXXFiles) + len(p.MFiles) + len(p.FFiles) + len(p.SFiles) + len(p.SysoFiles) + len(p.SwigFiles) + len(p.SwigCXXFiles)
	if p.Standard {
		switch p.ImportPath {
		case "bytes", "net", "os", "runtime/pprof", "sync", "time":
			extFiles++
		}
	}
	if extFiles == 0 {
		gcargs = append(gcargs, "-complete")
	}
	if cmdgo_buildContext.InstallSuffix != "" {
		gcargs = append(gcargs, "-installsuffix", cmdgo_buildContext.InstallSuffix)
	}
	if p.buildID != "" {
		gcargs = append(gcargs, "-buildid", p.buildID)
	}

	for _, path := range p.Imports {
		if i := strings.LastIndex(path, "/vendor/"); i >= 0 {
			gcargs = append(gcargs, "-importmap", path[i+len("/vendor/"):]+"="+path)
		} else if strings.HasPrefix(path, "vendor/") {
			gcargs = append(gcargs, "-importmap", path[len("vendor/"):]+"="+path)
		}
	}

	args := []interface{}{cmdgo_buildToolExec, cmdgo_tool("compile"), "-o", ofile, "-trimpath", b.work, cmdgo_buildGcflags, gcargs, "-D", p.localPrefix, importArgs}
	if ofile == archive {
		args = append(args, "-pack")
	}
	if asmhdr {
		args = append(args, "-asmhdr", obj+"go_asm.h")
	}
	for _, f := range gofiles {
		args = append(args, cmdgo_mkAbs(p.Dir, f))
	}

	output, err = b.runOut(p.Dir, p.ImportPath, nil, args...)
	return ofile, output, err
}

func (cmdgo_gcToolchain) asm(b *cmdgo_builder, p *cmdgo_Package, obj, ofile, sfile string) error {

	inc := filepath.Join(cmdgo_goroot, "pkg", "include")
	sfile = cmdgo_mkAbs(p.Dir, sfile)
	args := []interface{}{cmdgo_buildToolExec, cmdgo_tool("asm"), "-o", ofile, "-trimpath", b.work, "-I", obj, "-I", inc, "-D", "GOOS_" + cmdgo_goos, "-D", "GOARCH_" + cmdgo_goarch, cmdgo_buildAsmflags}
	if p.ImportPath == "runtime" && cmdgo_goarch == "386" {
		for _, arg := range cmdgo_buildAsmflags {
			if arg == "-dynlink" {
				args = append(args, "-D=GOBUILDMODE_shared=1")
			}
		}
	}
	args = append(args, sfile)
	if err := b.run(p.Dir, p.ImportPath, nil, args...); err != nil {
		return err
	}
	return nil
}

// toolVerify checks that the command line args writes the same output file
// if run using newTool instead.
// Unused now but kept around for future use.
func cmdgo_toolVerify(b *cmdgo_builder, p *cmdgo_Package, newTool string, ofile string, args []interface{}) error {
	newArgs := make([]interface{}, len(args))
	copy(newArgs, args)
	newArgs[1] = cmdgo_tool(newTool)
	newArgs[3] = ofile + ".new"
	if err := b.run(p.Dir, p.ImportPath, nil, newArgs...); err != nil {
		return err
	}
	data1, err := ioutil.ReadFile(ofile)
	if err != nil {
		return err
	}
	data2, err := ioutil.ReadFile(ofile + ".new")
	if err != nil {
		return err
	}
	if !bytes.Equal(data1, data2) {
		return fmt.Errorf("%s and %s produced different output files:\n%s\n%s", filepath.Base(args[1].(string)), newTool, strings.Join(cmdgo_stringList(args...), " "), strings.Join(cmdgo_stringList(newArgs...), " "))
	}
	os.Remove(ofile + ".new")
	return nil
}

func (cmdgo_gcToolchain) pkgpath(basedir string, p *cmdgo_Package) string {
	end := filepath.FromSlash(p.ImportPath + ".a")
	return filepath.Join(basedir, end)
}

func (cmdgo_gcToolchain) pack(b *cmdgo_builder, p *cmdgo_Package, objDir, afile string, ofiles []string) error {
	var absOfiles []string
	for _, f := range ofiles {
		absOfiles = append(absOfiles, cmdgo_mkAbs(objDir, f))
	}
	absAfile := cmdgo_mkAbs(objDir, afile)

	if !cmdgo_buildN {
		if _, err := os.Stat(absAfile); err != nil {
			cmdgo_fatalf("os.Stat of archive file failed: %v", err)
		}
	}

	if cmdgo_buildN || cmdgo_buildX {
		cmdline := cmdgo_stringList("pack", "r", absAfile, absOfiles)
		b.showcmd(p.Dir, "%s # internal", cmdgo_joinUnambiguously(cmdline))
	}
	if cmdgo_buildN {
		return nil
	}
	if err := cmdgo_packInternal(b, absAfile, absOfiles); err != nil {
		b.showOutput(p.Dir, p.ImportPath, err.Error()+"\n")
		return cmdgo_errPrintedOutput
	}
	return nil
}

func cmdgo_packInternal(b *cmdgo_builder, afile string, ofiles []string) error {
	dst, err := os.OpenFile(afile, os.O_WRONLY|os.O_APPEND, 0)
	if err != nil {
		return err
	}
	defer dst.Close()
	w := bufio.NewWriter(dst)

	for _, ofile := range ofiles {
		src, err := os.Open(ofile)
		if err != nil {
			return err
		}
		fi, err := src.Stat()
		if err != nil {
			src.Close()
			return err
		}

		name := fi.Name()
		if len(name) > 16 {
			name = name[:16]
		} else {
			name += strings.Repeat(" ", 16-len(name))
		}
		size := fi.Size()
		fmt.Fprintf(w, "%s%-12d%-6d%-6d%-8o%-10d`\n",
			name, 0, 0, 0, 0644, size)
		n, err := io.Copy(w, src)
		src.Close()
		if err == nil && n < size {
			err = io.ErrUnexpectedEOF
		} else if err == nil && n > size {
			err = fmt.Errorf("file larger than size reported by stat")
		}
		if err != nil {
			return fmt.Errorf("copying %s to %s: %v", ofile, afile, err)
		}
		if size&1 != 0 {
			w.WriteByte(0)
		}
	}

	if err := w.Flush(); err != nil {
		return err
	}
	return dst.Close()
}

// setextld sets the appropriate linker flags for the specified compiler.
func cmdgo_setextld(ldflags []string, compiler []string) []string {
	for _, f := range ldflags {
		if f == "-extld" || strings.HasPrefix(f, "-extld=") {

			return ldflags
		}
	}
	ldflags = append(ldflags, "-extld="+compiler[0])
	if len(compiler) > 1 {
		extldflags := false
		add := strings.Join(compiler[1:], " ")
		for i, f := range ldflags {
			if f == "-extldflags" && i+1 < len(ldflags) {
				ldflags[i+1] = add + " " + ldflags[i+1]
				extldflags = true
				break
			} else if strings.HasPrefix(f, "-extldflags=") {
				ldflags[i] = "-extldflags=" + add + " " + ldflags[i][len("-extldflags="):]
				extldflags = true
				break
			}
		}
		if !extldflags {
			ldflags = append(ldflags, "-extldflags="+add)
		}
	}
	return ldflags
}

func (cmdgo_gcToolchain) ld(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string) error {
	importArgs := b.includeArgs("-L", allactions)
	cxx := len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0
	for _, a := range allactions {
		if a.p != nil && (len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0) {
			cxx = true
		}
	}
	var ldflags []string
	if cmdgo_buildContext.InstallSuffix != "" {
		ldflags = append(ldflags, "-installsuffix", cmdgo_buildContext.InstallSuffix)
	}
	if root.p.omitDWARF {
		ldflags = append(ldflags, "-w")
	}

	// If the user has not specified the -extld option, then specify the
	// appropriate linker. In case of C++ code, use the compiler named
	// by the CXX environment variable or defaultCXX if CXX is not set.
	// Else, use the CC environment variable and defaultCC as fallback.
	var compiler []string
	if cxx {
		compiler = cmdgo_envList("CXX", cmdgo_defaultCXX)
	} else {
		compiler = cmdgo_envList("CC", cmdgo_defaultCC)
	}
	ldflags = cmdgo_setextld(ldflags, compiler)
	ldflags = append(ldflags, "-buildmode="+cmdgo_ldBuildmode)
	if root.p.buildID != "" {
		ldflags = append(ldflags, "-buildid="+root.p.buildID)
	}
	ldflags = append(ldflags, cmdgo_buildLdflags...)

	dir := "."
	if cmdgo_goos == "darwin" && cmdgo_buildBuildmode == "c-shared" {
		dir, out = filepath.Split(out)
	}

	return b.run(dir, root.p.ImportPath, nil, cmdgo_buildToolExec, cmdgo_tool("link"), "-o", out, importArgs, ldflags, mainpkg)
}

func (cmdgo_gcToolchain) ldShared(b *cmdgo_builder, toplevelactions []*cmdgo_action, out string, allactions []*cmdgo_action) error {
	importArgs := b.includeArgs("-L", allactions)
	ldflags := []string{"-installsuffix", cmdgo_buildContext.InstallSuffix}
	ldflags = append(ldflags, "-buildmode=shared")
	ldflags = append(ldflags, cmdgo_buildLdflags...)
	cxx := false
	for _, a := range allactions {
		if a.p != nil && (len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0) {
			cxx = true
		}
	}
	// If the user has not specified the -extld option, then specify the
	// appropriate linker. In case of C++ code, use the compiler named
	// by the CXX environment variable or defaultCXX if CXX is not set.
	// Else, use the CC environment variable and defaultCC as fallback.
	var compiler []string
	if cxx {
		compiler = cmdgo_envList("CXX", cmdgo_defaultCXX)
	} else {
		compiler = cmdgo_envList("CC", cmdgo_defaultCC)
	}
	ldflags = cmdgo_setextld(ldflags, compiler)
	for _, d := range toplevelactions {
		if !strings.HasSuffix(d.target, ".a") {
			continue
		}
		ldflags = append(ldflags, d.p.ImportPath+"="+d.target)
	}
	return b.run(".", out, nil, cmdgo_buildToolExec, cmdgo_tool("link"), "-o", out, importArgs, ldflags)
}

func (cmdgo_gcToolchain) cc(b *cmdgo_builder, p *cmdgo_Package, objdir, ofile, cfile string) error {
	return fmt.Errorf("%s: C source files not supported without cgo", cmdgo_mkAbs(p.Dir, cfile))
}

// The Gccgo toolchain.
type cmdgo_gccgoToolchain struct{}

var cmdgo_gccgoName, cmdgo_gccgoBin string

func init() {
	cmdgo_gccgoName = os.Getenv("GCCGO")
	if cmdgo_gccgoName == "" {
		cmdgo_gccgoName = "gccgo"
	}
	cmdgo_gccgoBin, _ = exec.LookPath(cmdgo_gccgoName)
}

func (cmdgo_gccgoToolchain) compiler() string {
	return cmdgo_gccgoBin
}

func (cmdgo_gccgoToolchain) linker() string {
	return cmdgo_gccgoBin
}

func (tools cmdgo_gccgoToolchain) gc(b *cmdgo_builder, p *cmdgo_Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, output []byte, err error) {
	out := "_go_.o"
	ofile = obj + out
	gcargs := []string{"-g"}
	gcargs = append(gcargs, b.gccArchArgs()...)
	if pkgpath := cmdgo_gccgoPkgpath(p); pkgpath != "" {
		gcargs = append(gcargs, "-fgo-pkgpath="+pkgpath)
	}
	if p.localPrefix != "" {
		gcargs = append(gcargs, "-fgo-relative-import-path="+p.localPrefix)
	}
	args := cmdgo_stringList(tools.compiler(), importArgs, "-c", gcargs, "-o", ofile, cmdgo_buildGccgoflags)
	for _, f := range gofiles {
		args = append(args, cmdgo_mkAbs(p.Dir, f))
	}

	output, err = b.runOut(p.Dir, p.ImportPath, nil, args)
	return ofile, output, err
}

func (tools cmdgo_gccgoToolchain) asm(b *cmdgo_builder, p *cmdgo_Package, obj, ofile, sfile string) error {
	sfile = cmdgo_mkAbs(p.Dir, sfile)
	defs := []string{"-D", "GOOS_" + cmdgo_goos, "-D", "GOARCH_" + cmdgo_goarch}
	if pkgpath := cmdgo_gccgoCleanPkgpath(p); pkgpath != "" {
		defs = append(defs, `-D`, `GOPKGPATH=`+pkgpath)
	}
	defs = tools.maybePIC(defs)
	defs = append(defs, b.gccArchArgs()...)
	return b.run(p.Dir, p.ImportPath, nil, tools.compiler(), "-xassembler-with-cpp", "-I", obj, "-c", "-o", ofile, defs, sfile)
}

func (cmdgo_gccgoToolchain) pkgpath(basedir string, p *cmdgo_Package) string {
	end := filepath.FromSlash(p.ImportPath + ".a")
	afile := filepath.Join(basedir, end)

	return filepath.Join(filepath.Dir(afile), "lib"+filepath.Base(afile))
}

func (cmdgo_gccgoToolchain) pack(b *cmdgo_builder, p *cmdgo_Package, objDir, afile string, ofiles []string) error {
	var absOfiles []string
	for _, f := range ofiles {
		absOfiles = append(absOfiles, cmdgo_mkAbs(objDir, f))
	}
	return b.run(p.Dir, p.ImportPath, nil, "ar", "rc", cmdgo_mkAbs(objDir, afile), absOfiles)
}

func (tools cmdgo_gccgoToolchain) link(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string, buildmode, desc string) error {

	apackagePathsSeen := make(map[string]bool)
	afiles := []string{}
	shlibs := []string{}
	ldflags := b.gccArchArgs()
	cgoldflags := []string{}
	usesCgo := false
	cxx := false
	objc := false
	fortran := false
	if root.p != nil {
		cxx = len(root.p.CXXFiles) > 0 || len(root.p.SwigCXXFiles) > 0
		objc = len(root.p.MFiles) > 0
		fortran = len(root.p.FFiles) > 0
	}

	readCgoFlags := func(flagsFile string) error {
		flags, err := ioutil.ReadFile(flagsFile)
		if err != nil {
			return err
		}
		const ldflagsPrefix = "_CGO_LDFLAGS="
		for _, line := range strings.Split(string(flags), "\n") {
			if strings.HasPrefix(line, ldflagsPrefix) {
				newFlags := strings.Fields(line[len(ldflagsPrefix):])
				for _, flag := range newFlags {

					if flag != "-g" && !strings.HasPrefix(flag, "-O") {
						cgoldflags = append(cgoldflags, flag)
					}
				}
			}
		}
		return nil
	}

	readAndRemoveCgoFlags := func(archive string) (string, error) {
		newa, err := ioutil.TempFile(b.work, filepath.Base(archive))
		if err != nil {
			return "", err
		}
		olda, err := os.Open(archive)
		if err != nil {
			return "", err
		}
		_, err = io.Copy(newa, olda)
		if err != nil {
			return "", err
		}
		err = olda.Close()
		if err != nil {
			return "", err
		}
		err = newa.Close()
		if err != nil {
			return "", err
		}

		newarchive := newa.Name()
		err = b.run(b.work, desc, nil, "ar", "x", newarchive, "_cgo_flags")
		if err != nil {
			return "", err
		}
		err = b.run(".", desc, nil, "ar", "d", newarchive, "_cgo_flags")
		if err != nil {
			return "", err
		}
		err = readCgoFlags(filepath.Join(b.work, "_cgo_flags"))
		if err != nil {
			return "", err
		}
		return newarchive, nil
	}

	actionsSeen := make(map[*cmdgo_action]bool)
	// Make a pre-order depth-first traversal of the action graph, taking note of
	// whether a shared library action has been seen on the way to an action (the
	// construction of the graph means that if any path to a node passes through
	// a shared library action, they all do).
	var walk func(a *cmdgo_action, seenShlib bool)
	var err error
	walk = func(a *cmdgo_action, seenShlib bool) {
		if actionsSeen[a] {
			return
		}
		actionsSeen[a] = true
		if a.p != nil && !seenShlib {
			if a.p.Standard {
				return
			}

			if !apackagePathsSeen[a.p.ImportPath] {
				apackagePathsSeen[a.p.ImportPath] = true
				target := a.target
				if len(a.p.CgoFiles) > 0 {
					target, err = readAndRemoveCgoFlags(target)
					if err != nil {
						return
					}
				}
				afiles = append(afiles, target)
			}
		}
		if strings.HasSuffix(a.target, ".so") {
			shlibs = append(shlibs, a.target)
			seenShlib = true
		}
		for _, a1 := range a.deps {
			walk(a1, seenShlib)
			if err != nil {
				return
			}
		}
	}
	for _, a1 := range root.deps {
		walk(a1, false)
		if err != nil {
			return err
		}
	}

	for _, a := range allactions {

		if a.p == nil {
			continue
		}
		if !a.p.Standard {
			cgoldflags = append(cgoldflags, a.p.CgoLDFLAGS...)
		}
		if len(a.p.CgoFiles) > 0 {
			usesCgo = true
		}
		if a.p.usesSwig() {
			usesCgo = true
		}
		if len(a.p.CXXFiles) > 0 || len(a.p.SwigCXXFiles) > 0 {
			cxx = true
		}
		if len(a.p.MFiles) > 0 {
			objc = true
		}
		if len(a.p.FFiles) > 0 {
			fortran = true
		}
	}

	for i, o := range ofiles {
		if filepath.Base(o) == "_cgo_flags" {
			readCgoFlags(o)
			ofiles = append(ofiles[:i], ofiles[i+1:]...)
			break
		}
	}

	ldflags = append(ldflags, "-Wl,--whole-archive")
	ldflags = append(ldflags, afiles...)
	ldflags = append(ldflags, "-Wl,--no-whole-archive")

	ldflags = append(ldflags, cgoldflags...)
	ldflags = append(ldflags, cmdgo_envList("CGO_LDFLAGS", "")...)
	if root.p != nil {
		ldflags = append(ldflags, root.p.CgoLDFLAGS...)
	}

	ldflags = cmdgo_stringList("-Wl,-(", ldflags, "-Wl,-)")

	for _, shlib := range shlibs {
		ldflags = append(
			ldflags,
			"-L"+filepath.Dir(shlib),
			"-Wl,-rpath="+filepath.Dir(shlib),
			"-l"+strings.TrimSuffix(
				strings.TrimPrefix(filepath.Base(shlib), "lib"),
				".so"))
	}

	var realOut string
	switch buildmode {
	case "exe":
		if usesCgo && cmdgo_goos == "linux" {
			ldflags = append(ldflags, "-Wl,-E")
		}

	case "c-archive":

		ldflags = append(ldflags, "-Wl,-r", "-nostdlib", "-Wl,--whole-archive", "-lgolibbegin", "-Wl,--no-whole-archive")

		if b.gccSupportsNoPie() {
			ldflags = append(ldflags, "-no-pie")
		}

		ldflags = b.disableBuildID(ldflags)

		realOut = out
		out = out + ".o"

	case "c-shared":
		ldflags = append(ldflags, "-shared", "-nostdlib", "-Wl,--whole-archive", "-lgolibbegin", "-Wl,--no-whole-archive", "-lgo", "-lgcc_s", "-lgcc", "-lc", "-lgcc")
	case "shared":
		ldflags = append(ldflags, "-zdefs", "-shared", "-nostdlib", "-lgo", "-lgcc_s", "-lgcc", "-lc")

	default:
		cmdgo_fatalf("-buildmode=%s not supported for gccgo", buildmode)
	}

	switch buildmode {
	case "exe", "c-shared":
		if cxx {
			ldflags = append(ldflags, "-lstdc++")
		}
		if objc {
			ldflags = append(ldflags, "-lobjc")
		}
		if fortran {
			fc := os.Getenv("FC")
			if fc == "" {
				fc = "gfortran"
			}

			if strings.Contains(fc, "gfortran") {
				ldflags = append(ldflags, "-lgfortran")
			}
		}
	}

	if err := b.run(".", desc, nil, tools.linker(), "-o", out, ofiles, ldflags, cmdgo_buildGccgoflags); err != nil {
		return err
	}

	switch buildmode {
	case "c-archive":
		if err := b.run(".", desc, nil, "ar", "rc", realOut, out); err != nil {
			return err
		}
	}
	return nil
}

func (tools cmdgo_gccgoToolchain) ld(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string) error {
	return tools.link(b, root, out, allactions, mainpkg, ofiles, cmdgo_ldBuildmode, root.p.ImportPath)
}

func (tools cmdgo_gccgoToolchain) ldShared(b *cmdgo_builder, toplevelactions []*cmdgo_action, out string, allactions []*cmdgo_action) error {
	fakeRoot := &cmdgo_action{}
	fakeRoot.deps = toplevelactions
	return tools.link(b, fakeRoot, out, allactions, "", nil, "shared", out)
}

func (tools cmdgo_gccgoToolchain) cc(b *cmdgo_builder, p *cmdgo_Package, objdir, ofile, cfile string) error {
	inc := filepath.Join(cmdgo_goroot, "pkg", "include")
	cfile = cmdgo_mkAbs(p.Dir, cfile)
	defs := []string{"-D", "GOOS_" + cmdgo_goos, "-D", "GOARCH_" + cmdgo_goarch}
	defs = append(defs, b.gccArchArgs()...)
	if pkgpath := cmdgo_gccgoCleanPkgpath(p); pkgpath != "" {
		defs = append(defs, `-D`, `GOPKGPATH="`+pkgpath+`"`)
	}
	switch cmdgo_goarch {
	case "386", "amd64":
		defs = append(defs, "-fsplit-stack")
	}
	defs = tools.maybePIC(defs)
	return b.run(p.Dir, p.ImportPath, nil, cmdgo_envList("CC", cmdgo_defaultCC), "-Wall", "-g",
		"-I", objdir, "-I", inc, "-o", ofile, defs, "-c", cfile)
}

// maybePIC adds -fPIC to the list of arguments if needed.
func (tools cmdgo_gccgoToolchain) maybePIC(args []string) []string {
	switch cmdgo_buildBuildmode {
	case "c-shared", "shared":
		args = append(args, "-fPIC")
	}
	return args
}

func cmdgo_gccgoPkgpath(p *cmdgo_Package) string {
	if p.build.IsCommand() && !p.forceLibrary {
		return ""
	}
	return p.ImportPath
}

func cmdgo_gccgoCleanPkgpath(p *cmdgo_Package) string {
	clean := func(r rune) rune {
		switch {
		case 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',
			'0' <= r && r <= '9':
			return r
		}
		return '_'
	}
	return strings.Map(clean, cmdgo_gccgoPkgpath(p))
}

// gcc runs the gcc C compiler to create an object from a single C file.
func (b *cmdgo_builder) gcc(p *cmdgo_Package, out string, flags []string, cfile string) error {
	return b.ccompile(p, out, flags, cfile, b.gccCmd(p.Dir))
}

// gxx runs the g++ C++ compiler to create an object from a single C++ file.
func (b *cmdgo_builder) gxx(p *cmdgo_Package, out string, flags []string, cxxfile string) error {
	return b.ccompile(p, out, flags, cxxfile, b.gxxCmd(p.Dir))
}

// gfortran runs the gfortran Fortran compiler to create an object from a single Fortran file.
func (b *cmdgo_builder) gfortran(p *cmdgo_Package, out string, flags []string, ffile string) error {
	return b.ccompile(p, out, flags, ffile, b.gfortranCmd(p.Dir))
}

// ccompile runs the given C or C++ compiler and creates an object from a single source file.
func (b *cmdgo_builder) ccompile(p *cmdgo_Package, out string, flags []string, file string, compiler []string) error {
	file = cmdgo_mkAbs(p.Dir, file)
	return b.run(p.Dir, p.ImportPath, nil, compiler, flags, "-o", out, "-c", file)
}

// gccld runs the gcc linker to create an executable from a set of object files.
func (b *cmdgo_builder) gccld(p *cmdgo_Package, out string, flags []string, obj []string) error {
	var cmd []string
	if len(p.CXXFiles) > 0 || len(p.SwigCXXFiles) > 0 {
		cmd = b.gxxCmd(p.Dir)
	} else {
		cmd = b.gccCmd(p.Dir)
	}
	return b.run(p.Dir, p.ImportPath, nil, cmd, "-o", out, obj, flags)
}

// gccCmd returns a gcc command line prefix
// defaultCC is defined in zdefaultcc.go, written by cmd/dist.
func (b *cmdgo_builder) gccCmd(objdir string) []string {
	return b.ccompilerCmd("CC", cmdgo_defaultCC, objdir)
}

// gxxCmd returns a g++ command line prefix
// defaultCXX is defined in zdefaultcc.go, written by cmd/dist.
func (b *cmdgo_builder) gxxCmd(objdir string) []string {
	return b.ccompilerCmd("CXX", cmdgo_defaultCXX, objdir)
}

// gfortranCmd returns a gfortran command line prefix.
func (b *cmdgo_builder) gfortranCmd(objdir string) []string {
	return b.ccompilerCmd("FC", "gfortran", objdir)
}

// ccompilerCmd returns a command line prefix for the given environment
// variable and using the default command when the variable is empty.
func (b *cmdgo_builder) ccompilerCmd(envvar, defcmd, objdir string) []string {

	compiler := cmdgo_envList(envvar, defcmd)
	a := []string{compiler[0], "-I", objdir}
	a = append(a, compiler[1:]...)

	if cmdgo_goos != "windows" {
		a = append(a, "-fPIC")
	}
	a = append(a, b.gccArchArgs()...)

	if cmdgo_buildContext.CgoEnabled {
		switch cmdgo_goos {
		case "windows":
			a = append(a, "-mthreads")
		default:
			a = append(a, "-pthread")
		}
	}

	if strings.Contains(a[0], "clang") {

		a = append(a, "-fno-caret-diagnostics")

		a = append(a, "-Qunused-arguments")
	}

	a = append(a, "-fmessage-length=0")

	if b.gccSupportsFlag("-fdebug-prefix-map=a=b") {
		a = append(a, "-fdebug-prefix-map="+b.work+"=/tmp/go-build")
	}

	if b.gccSupportsFlag("-gno-record-gcc-switches") {
		a = append(a, "-gno-record-gcc-switches")
	}

	if cmdgo_goos == "darwin" {
		a = append(a, "-fno-common")
	}

	return a
}

// On systems with PIE (position independent executables) enabled by default,
// -no-pie must be passed when doing a partial link with -Wl,-r. But -no-pie is
// not supported by all compilers.
func (b *cmdgo_builder) gccSupportsNoPie() bool {
	return b.gccSupportsFlag("-no-pie")
}

// gccSupportsFlag checks to see if the compiler supports a flag.
func (b *cmdgo_builder) gccSupportsFlag(flag string) bool {
	b.exec.Lock()
	defer b.exec.Unlock()
	if b, ok := b.flagCache[flag]; ok {
		return b
	}
	if b.flagCache == nil {
		src := filepath.Join(b.work, "trivial.c")
		if err := ioutil.WriteFile(src, []byte{}, 0666); err != nil {
			return false
		}
		b.flagCache = make(map[string]bool)
	}
	cmdArgs := append(cmdgo_envList("CC", cmdgo_defaultCC), flag, "-c", "trivial.c")
	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd(b.work, "%s", cmdgo_joinUnambiguously(cmdArgs))
		if cmdgo_buildN {
			return false
		}
	}
	cmd := exec.Command(cmdArgs[0], cmdArgs[1:]...)
	cmd.Dir = b.work
	cmd.Env = cmdgo_mergeEnvLists([]string{"LC_ALL=C"}, cmdgo_envForDir(cmd.Dir, os.Environ()))
	out, err := cmd.CombinedOutput()
	supported := err == nil && !bytes.Contains(out, []byte("unrecognized"))
	b.flagCache[flag] = supported
	return supported
}

// gccArchArgs returns arguments to pass to gcc based on the architecture.
func (b *cmdgo_builder) gccArchArgs() []string {
	switch cmdgo_goarch {
	case "386":
		return []string{"-m32"}
	case "amd64", "amd64p32":
		return []string{"-m64"}
	case "arm":
		return []string{"-marm"}
	case "s390x":
		return []string{"-m64", "-march=z196"}
	case "mips64", "mips64le":
		return []string{"-mabi=64"}
	}
	return nil
}

// envList returns the value of the given environment variable broken
// into fields, using the default value when the variable is empty.
func cmdgo_envList(key, def string) []string {
	v := os.Getenv(key)
	if v == "" {
		v = def
	}
	return strings.Fields(v)
}

// Return the flags to use when invoking the C, C++ or Fortran compilers, or cgo.
func (b *cmdgo_builder) cflags(p *cmdgo_Package, def bool) (cppflags, cflags, cxxflags, fflags, ldflags []string) {
	var defaults string
	if def {
		defaults = "-g -O2"
	}

	cppflags = cmdgo_stringList(cmdgo_envList("CGO_CPPFLAGS", ""), p.CgoCPPFLAGS)
	cflags = cmdgo_stringList(cmdgo_envList("CGO_CFLAGS", defaults), p.CgoCFLAGS)
	cxxflags = cmdgo_stringList(cmdgo_envList("CGO_CXXFLAGS", defaults), p.CgoCXXFLAGS)
	fflags = cmdgo_stringList(cmdgo_envList("CGO_FFLAGS", defaults), p.CgoFFLAGS)
	ldflags = cmdgo_stringList(cmdgo_envList("CGO_LDFLAGS", defaults), p.CgoLDFLAGS)
	return
}

var cmdgo_cgoRe = regexp.MustCompile(`[/\\:]`)

func (b *cmdgo_builder) cgo(p *cmdgo_Package, cgoExe, obj string, pcCFLAGS, pcLDFLAGS, cgofiles, gccfiles, gxxfiles, mfiles, ffiles []string) (outGo, outObj []string, err error) {
	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, cgoFFLAGS, cgoLDFLAGS := b.cflags(p, true)
	_, cgoexeCFLAGS, _, _, _ := b.cflags(p, false)
	cgoCPPFLAGS = append(cgoCPPFLAGS, pcCFLAGS...)
	cgoLDFLAGS = append(cgoLDFLAGS, pcLDFLAGS...)

	if len(mfiles) > 0 {
		cgoLDFLAGS = append(cgoLDFLAGS, "-lobjc")
	}

	if len(ffiles) > 0 {
		fc := os.Getenv("FC")
		if fc == "" {
			fc = "gfortran"
		}
		if strings.Contains(fc, "gfortran") {
			cgoLDFLAGS = append(cgoLDFLAGS, "-lgfortran")
		}
	}

	if cmdgo_buildMSan && p.ImportPath != "runtime/cgo" {
		cgoCFLAGS = append([]string{"-fsanitize=memory"}, cgoCFLAGS...)
		cgoLDFLAGS = append([]string{"-fsanitize=memory"}, cgoLDFLAGS...)
	}

	cgoCPPFLAGS = append(cgoCPPFLAGS, "-I", obj)

	gofiles := []string{obj + "_cgo_gotypes.go"}
	cfiles := []string{"_cgo_main.c", "_cgo_export.c"}
	for _, fn := range cgofiles {
		f := cmdgo_cgoRe.ReplaceAllString(fn[:len(fn)-2], "_")
		gofiles = append(gofiles, obj+f+"cgo1.go")
		cfiles = append(cfiles, f+"cgo2.c")
	}
	defunC := obj + "_cgo_defun.c"

	cgoflags := []string{}

	if p.Standard && p.ImportPath == "runtime/cgo" {
		cgoflags = append(cgoflags, "-import_runtime_cgo=false")
	}
	if p.Standard && (p.ImportPath == "runtime/race" || p.ImportPath == "runtime/msan" || p.ImportPath == "runtime/cgo") {
		cgoflags = append(cgoflags, "-import_syscall=false")
	}

	// Update $CGO_LDFLAGS with p.CgoLDFLAGS.
	var cgoenv []string
	if len(cgoLDFLAGS) > 0 {
		flags := make([]string, len(cgoLDFLAGS))
		for i, f := range cgoLDFLAGS {
			flags[i] = strconv.Quote(f)
		}
		cgoenv = []string{"CGO_LDFLAGS=" + strings.Join(flags, " ")}
	}

	if _, ok := cmdgo_buildToolchain.(cmdgo_gccgoToolchain); ok {
		switch cmdgo_goarch {
		case "386", "amd64":
			cgoCFLAGS = append(cgoCFLAGS, "-fsplit-stack")
		}
		cgoflags = append(cgoflags, "-gccgo")
		if pkgpath := cmdgo_gccgoPkgpath(p); pkgpath != "" {
			cgoflags = append(cgoflags, "-gccgopkgpath="+pkgpath)
		}
	}

	switch cmdgo_buildBuildmode {
	case "c-archive", "c-shared":

		cgoflags = append(cgoflags, "-exportheader="+obj+"_cgo_install.h")
	}

	if err := b.run(p.Dir, p.ImportPath, cgoenv, cmdgo_buildToolExec, cgoExe, "-objdir", obj, "-importpath", p.ImportPath, cgoflags, "--", cgoCPPFLAGS, cgoexeCFLAGS, cgofiles); err != nil {
		return nil, nil, err
	}
	outGo = append(outGo, gofiles...)

	_, gccgo := cmdgo_buildToolchain.(cmdgo_gccgoToolchain)
	if gccgo {
		defunObj := obj + "_cgo_defun.o"
		if err := cmdgo_buildToolchain.cc(b, p, obj, defunObj, defunC); err != nil {
			return nil, nil, err
		}
		outObj = append(outObj, defunObj)
	}

	// gcc
	var linkobj []string

	var bareLDFLAGS []string

	for i := 0; i < len(cgoLDFLAGS); i++ {
		f := cgoLDFLAGS[i]
		switch {

		case strings.HasPrefix(f, "-l"):
			if f == "-l" {
				i++
			}

		case cmdgo_goos == "darwin" && f == "-framework":
			i++

		case strings.HasSuffix(f, ".dylib"),
			strings.HasSuffix(f, ".so"),
			strings.HasSuffix(f, ".dll"):

		case strings.HasPrefix(f, "-fsanitize="):
			continue

		case strings.HasPrefix(f, "-Wl,-rpath"):
			if f == "-Wl,-rpath" || f == "-Wl,-rpath-link" {

				i++
			}
		default:
			bareLDFLAGS = append(bareLDFLAGS, f)
		}
	}

	var staticLibs []string
	if cmdgo_goos == "windows" {

		staticLibs = []string{"-Wl,--start-group", "-lmingwex", "-lmingw32", "-Wl,--end-group"}
	}

	cflags := cmdgo_stringList(cgoCPPFLAGS, cgoCFLAGS)
	for _, cfile := range cfiles {
		ofile := obj + cfile[:len(cfile)-1] + "o"
		if err := b.gcc(p, ofile, cflags, obj+cfile); err != nil {
			return nil, nil, err
		}
		linkobj = append(linkobj, ofile)
		if !strings.HasSuffix(ofile, "_cgo_main.o") {
			outObj = append(outObj, ofile)
		}
	}

	for _, file := range gccfiles {
		ofile := obj + cmdgo_cgoRe.ReplaceAllString(file[:len(file)-1], "_") + "o"
		if err := b.gcc(p, ofile, cflags, file); err != nil {
			return nil, nil, err
		}
		linkobj = append(linkobj, ofile)
		outObj = append(outObj, ofile)
	}

	cxxflags := cmdgo_stringList(cgoCPPFLAGS, cgoCXXFLAGS)
	for _, file := range gxxfiles {

		ofile := obj + cmdgo_cgoRe.ReplaceAllString(file, "_") + ".o"
		if err := b.gxx(p, ofile, cxxflags, file); err != nil {
			return nil, nil, err
		}
		linkobj = append(linkobj, ofile)
		outObj = append(outObj, ofile)
	}

	for _, file := range mfiles {

		ofile := obj + cmdgo_cgoRe.ReplaceAllString(file, "_") + ".o"
		if err := b.gcc(p, ofile, cflags, file); err != nil {
			return nil, nil, err
		}
		linkobj = append(linkobj, ofile)
		outObj = append(outObj, ofile)
	}

	fflags := cmdgo_stringList(cgoCPPFLAGS, cgoFFLAGS)
	for _, file := range ffiles {

		ofile := obj + cmdgo_cgoRe.ReplaceAllString(file, "_") + ".o"
		if err := b.gfortran(p, ofile, fflags, file); err != nil {
			return nil, nil, err
		}
		linkobj = append(linkobj, ofile)
		outObj = append(outObj, ofile)
	}

	linkobj = append(linkobj, p.SysoFiles...)
	dynobj := obj + "_cgo_.o"
	pie := (cmdgo_goarch == "arm" && cmdgo_goos == "linux") || cmdgo_goos == "android"
	if pie {
		cgoLDFLAGS = append(cgoLDFLAGS, "-pie")
	}
	if err := b.gccld(p, dynobj, cgoLDFLAGS, linkobj); err != nil {
		return nil, nil, err
	}
	if pie {
		cgoLDFLAGS = cgoLDFLAGS[0 : len(cgoLDFLAGS)-1]
	}

	if _, ok := cmdgo_buildToolchain.(cmdgo_gccgoToolchain); ok {

		return outGo, outObj, nil
	}

	importGo := obj + "_cgo_import.go"
	cgoflags = []string{}
	if p.Standard && p.ImportPath == "runtime/cgo" {
		cgoflags = append(cgoflags, "-dynlinker")
	}
	if err := b.run(p.Dir, p.ImportPath, nil, cmdgo_buildToolExec, cgoExe, "-objdir", obj, "-dynpackage", p.Name, "-dynimport", dynobj, "-dynout", importGo, cgoflags); err != nil {
		return nil, nil, err
	}
	outGo = append(outGo, importGo)

	ofile := obj + "_all.o"
	var gccObjs, nonGccObjs []string
	for _, f := range outObj {
		if strings.HasSuffix(f, ".o") {
			gccObjs = append(gccObjs, f)
		} else {
			nonGccObjs = append(nonGccObjs, f)
		}
	}
	ldflags := cmdgo_stringList(bareLDFLAGS, "-Wl,-r", "-nostdlib", staticLibs)

	if b.gccSupportsNoPie() {
		ldflags = append(ldflags, "-no-pie")
	}

	ldflags = b.disableBuildID(ldflags)

	if err := b.gccld(p, ofile, ldflags, gccObjs); err != nil {
		return nil, nil, err
	}

	outObj = cmdgo_stringList(nonGccObjs, ofile)

	return outGo, outObj, nil
}

// Run SWIG on all SWIG input files.
// TODO: Don't build a shared library, once SWIG emits the necessary
// pragmas for external linking.
func (b *cmdgo_builder) swig(p *cmdgo_Package, obj string, pcCFLAGS []string) (outGo, outC, outCXX []string, err error) {
	if err := b.swigVersionCheck(); err != nil {
		return nil, nil, nil, err
	}

	intgosize, err := b.swigIntSize(obj)
	if err != nil {
		return nil, nil, nil, err
	}

	for _, f := range p.SwigFiles {
		goFile, cFile, err := b.swigOne(p, f, obj, pcCFLAGS, false, intgosize)
		if err != nil {
			return nil, nil, nil, err
		}
		if goFile != "" {
			outGo = append(outGo, goFile)
		}
		if cFile != "" {
			outC = append(outC, cFile)
		}
	}
	for _, f := range p.SwigCXXFiles {
		goFile, cxxFile, err := b.swigOne(p, f, obj, pcCFLAGS, true, intgosize)
		if err != nil {
			return nil, nil, nil, err
		}
		if goFile != "" {
			outGo = append(outGo, goFile)
		}
		if cxxFile != "" {
			outCXX = append(outCXX, cxxFile)
		}
	}
	return outGo, outC, outCXX, nil
}

// Make sure SWIG is new enough.
var (
	cmdgo_swigCheckOnce sync.Once
	cmdgo_swigCheck     error
)

func (b *cmdgo_builder) swigDoVersionCheck() error {
	out, err := b.runOut("", "", nil, "swig", "-version")
	if err != nil {
		return err
	}
	re := regexp.MustCompile(`[vV]ersion +([\d]+)([.][\d]+)?([.][\d]+)?`)
	matches := re.FindSubmatch(out)
	if matches == nil {

		return nil
	}

	major, err := strconv.Atoi(string(matches[1]))
	if err != nil {

		return nil
	}
	const errmsg = "must have SWIG version >= 3.0.6"
	if major < 3 {
		return errors.New(errmsg)
	}
	if major > 3 {

		return nil
	}

	if len(matches[2]) > 0 {
		minor, err := strconv.Atoi(string(matches[2][1:]))
		if err != nil {
			return nil
		}
		if minor > 0 {

			return nil
		}
	}

	if len(matches[3]) > 0 {
		patch, err := strconv.Atoi(string(matches[3][1:]))
		if err != nil {
			return nil
		}
		if patch < 6 {

			return errors.New(errmsg)
		}
	}

	return nil
}

func (b *cmdgo_builder) swigVersionCheck() error {
	cmdgo_swigCheckOnce.Do(func() {
		cmdgo_swigCheck = b.swigDoVersionCheck()
	})
	return cmdgo_swigCheck
}

// Find the value to pass for the -intgosize option to swig.
var (
	cmdgo_swigIntSizeOnce  sync.Once
	cmdgo_swigIntSize      string
	cmdgo_swigIntSizeError error
)

// This code fails to build if sizeof(int) <= 32
const cmdgo_swigIntSizeCode = `
package main
const i int = 1 << 32
`

// Determine the size of int on the target system for the -intgosize option
// of swig >= 2.0.9.  Run only once.
func (b *cmdgo_builder) swigDoIntSize(obj string) (intsize string, err error) {
	if cmdgo_buildN {
		return "$INTBITS", nil
	}
	src := filepath.Join(b.work, "swig_intsize.go")
	if err = ioutil.WriteFile(src, []byte(cmdgo_swigIntSizeCode), 0666); err != nil {
		return
	}
	srcs := []string{src}

	p := cmdgo_goFilesPackage(srcs)

	if _, _, e := cmdgo_buildToolchain.gc(b, p, "", obj, false, nil, srcs); e != nil {
		return "32", nil
	}
	return "64", nil
}

// Determine the size of int on the target system for the -intgosize option
// of swig >= 2.0.9.
func (b *cmdgo_builder) swigIntSize(obj string) (intsize string, err error) {
	cmdgo_swigIntSizeOnce.Do(func() {
		cmdgo_swigIntSize, cmdgo_swigIntSizeError = b.swigDoIntSize(obj)
	})
	return cmdgo_swigIntSize, cmdgo_swigIntSizeError
}

// Run SWIG on one SWIG input file.
func (b *cmdgo_builder) swigOne(p *cmdgo_Package, file, obj string, pcCFLAGS []string, cxx bool, intgosize string) (outGo, outC string, err error) {
	cgoCPPFLAGS, cgoCFLAGS, cgoCXXFLAGS, _, _ := b.cflags(p, true)
	var cflags []string
	if cxx {
		cflags = cmdgo_stringList(cgoCPPFLAGS, pcCFLAGS, cgoCXXFLAGS)
	} else {
		cflags = cmdgo_stringList(cgoCPPFLAGS, pcCFLAGS, cgoCFLAGS)
	}

	n := 5
	if cxx {
		n = 8
	}
	base := file[:len(file)-n]
	goFile := base + ".go"
	gccBase := base + "_wrap."
	gccExt := "c"
	if cxx {
		gccExt = "cxx"
	}

	_, gccgo := cmdgo_buildToolchain.(cmdgo_gccgoToolchain)

	args := []string{
		"-go",
		"-cgo",
		"-intgosize", intgosize,
		"-module", base,
		"-o", obj + gccBase + gccExt,
		"-outdir", obj,
	}

	for _, f := range cflags {
		if len(f) > 3 && f[:2] == "-I" {
			args = append(args, f)
		}
	}

	if gccgo {
		args = append(args, "-gccgo")
		if pkgpath := cmdgo_gccgoPkgpath(p); pkgpath != "" {
			args = append(args, "-go-pkgpath", pkgpath)
		}
	}
	if cxx {
		args = append(args, "-c++")
	}

	out, err := b.runOut(p.Dir, p.ImportPath, nil, "swig", args, file)
	if err != nil {
		if len(out) > 0 {
			if bytes.Contains(out, []byte("-intgosize")) || bytes.Contains(out, []byte("-cgo")) {
				return "", "", errors.New("must have SWIG version >= 3.0.6")
			}
			b.showOutput(p.Dir, p.ImportPath, b.processOutput(out))
			return "", "", cmdgo_errPrintedOutput
		}
		return "", "", err
	}
	if len(out) > 0 {
		b.showOutput(p.Dir, p.ImportPath, b.processOutput(out))
	}

	return obj + goFile, obj + gccBase + gccExt, nil
}

// disableBuildID adjusts a linker command line to avoid creating a
// build ID when creating an object file rather than an executable or
// shared library. Some systems, such as Ubuntu, always add
// --build-id to every link, but we don't want a build ID when we are
// producing an object file. On some of those system a plain -r (not
// -Wl,-r) will turn off --build-id, but clang 3.0 doesn't support a
// plain -r. I don't know how to turn off --build-id when using clang
// other than passing a trailing --build-id=none. So that is what we
// do, but only on systems likely to support it, which is to say,
// systems that normally use gold or the GNU linker.
func (b *cmdgo_builder) disableBuildID(ldflags []string) []string {
	switch cmdgo_goos {
	case "android", "dragonfly", "linux", "netbsd":
		ldflags = append(ldflags, "-Wl,--build-id=none")
	}
	return ldflags
}

// An actionQueue is a priority queue of actions.
type cmdgo_actionQueue []*cmdgo_action

// Implement heap.Interface
func (q *cmdgo_actionQueue) Len() int { return len(*q) }

func (q *cmdgo_actionQueue) Swap(i, j int) { (*q)[i], (*q)[j] = (*q)[j], (*q)[i] }

func (q *cmdgo_actionQueue) Less(i, j int) bool { return (*q)[i].priority < (*q)[j].priority }

func (q *cmdgo_actionQueue) Push(x interface{}) { *q = append(*q, x.(*cmdgo_action)) }

func (q *cmdgo_actionQueue) Pop() interface{} {
	n := len(*q) - 1
	x := (*q)[n]
	*q = (*q)[:n]
	return x
}

func (q *cmdgo_actionQueue) push(a *cmdgo_action) {
	heap.Push(q, a)
}

func (q *cmdgo_actionQueue) pop() *cmdgo_action {
	return heap.Pop(q).(*cmdgo_action)
}

func cmdgo_instrumentInit() {
	if !cmdgo_buildRace && !cmdgo_buildMSan {
		return
	}
	if cmdgo_buildRace && cmdgo_buildMSan {
		fmt.Fprintf(os.Stderr, "go %s: may not use -race and -msan simultaneously", flag.Args()[0])
		os.Exit(2)
	}
	if cmdgo_goarch != "amd64" || cmdgo_goos != "linux" && cmdgo_goos != "freebsd" && cmdgo_goos != "darwin" && cmdgo_goos != "windows" {
		fmt.Fprintf(os.Stderr, "go %s: -race and -msan are only supported on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64\n", flag.Args()[0])
		os.Exit(2)
	}
	if !cmdgo_buildContext.CgoEnabled {
		fmt.Fprintf(os.Stderr, "go %s: -race requires cgo; enable cgo by setting CGO_ENABLED=1\n", flag.Args()[0])
		os.Exit(2)
	}
	if cmdgo_buildRace {
		cmdgo_buildGcflags = append(cmdgo_buildGcflags, "-race")
		cmdgo_buildLdflags = append(cmdgo_buildLdflags, "-race")
	} else {
		cmdgo_buildGcflags = append(cmdgo_buildGcflags, "-msan")
		cmdgo_buildLdflags = append(cmdgo_buildLdflags, "-msan")
	}
	if cmdgo_buildContext.InstallSuffix != "" {
		cmdgo_buildContext.InstallSuffix += "_"
	}

	if cmdgo_buildRace {
		cmdgo_buildContext.InstallSuffix += "race"
		cmdgo_buildContext.BuildTags = append(cmdgo_buildContext.BuildTags, "race")
	} else {
		cmdgo_buildContext.InstallSuffix += "msan"
		cmdgo_buildContext.BuildTags = append(cmdgo_buildContext.BuildTags, "msan")
	}
}

var cmdgo_cmdClean = &cmdgo_Command{
	UsageLine: "clean [-i] [-r] [-n] [-x] [build flags] [packages]",
	Short:     "remove object files",
	Long: `
Clean removes object files from package source directories.
The go command builds most objects in a temporary directory,
so go clean is mainly concerned with object files left by other
tools or by manual invocations of go build.

Specifically, clean removes the following files from each of the
source directories corresponding to the import paths:

	_obj/            old object directory, left from Makefiles
	_test/           old test directory, left from Makefiles
	_testmain.go     old gotest file, left from Makefiles
	test.out         old test log, left from Makefiles
	build.out        old test log, left from Makefiles
	*.[568ao]        object files, left from Makefiles

	DIR(.exe)        from go build
	DIR.test(.exe)   from go test -c
	MAINFILE(.exe)   from go build MAINFILE.go
	*.so             from SWIG

In the list, DIR represents the final path element of the
directory, and MAINFILE is the base name of any Go source
file in the directory that is not included when building
the package.

The -i flag causes clean to remove the corresponding installed
archive or binary (what 'go install' would create).

The -n flag causes clean to print the remove commands it would execute,
but not run them.

The -r flag causes clean to be applied recursively to all the
dependencies of the packages named by the import paths.

The -x flag causes clean to print remove commands as it executes them.

For more about build flags, see 'go help build'.

For more about specifying packages, see 'go help packages'.
	`,
}

var cmdgo_cleanI bool // clean -i flag

var cmdgo_cleanR bool // clean -r flag

func init() {

	cmdgo_cmdClean.Run = cmdgo_runClean

	cmdgo_cmdClean.Flag.BoolVar(&cmdgo_cleanI, "i", false, "")
	cmdgo_cmdClean.Flag.BoolVar(&cmdgo_cleanR, "r", false, "")

	cmdgo_addBuildFlags(cmdgo_cmdClean)
}

func cmdgo_runClean(cmd *cmdgo_Command, args []string) {
	for _, pkg := range cmdgo_packagesAndErrors(args) {
		cmdgo_clean(pkg)
	}
}

var cmdgo_cleaned = map[*cmdgo_Package]bool{}

// TODO: These are dregs left by Makefile-based builds.
// Eventually, can stop deleting these.
var cmdgo_cleanDir = map[string]bool{
	"_test": true,
	"_obj":  true,
}

var cmdgo_cleanFile = map[string]bool{
	"_testmain.go": true,
	"test.out":     true,
	"build.out":    true,
	"a.out":        true,
}

var cmdgo_cleanExt = map[string]bool{
	".5":  true,
	".6":  true,
	".8":  true,
	".a":  true,
	".o":  true,
	".so": true,
}

func cmdgo_clean(p *cmdgo_Package) {
	if cmdgo_cleaned[p] {
		return
	}
	cmdgo_cleaned[p] = true

	if p.Dir == "" {
		cmdgo_errorf("can't load package: %v", p.Error)
		return
	}
	dirs, err := ioutil.ReadDir(p.Dir)
	if err != nil {
		cmdgo_errorf("go clean %s: %v", p.Dir, err)
		return
	}

	var b cmdgo_builder
	b.print = fmt.Print

	packageFile := map[string]bool{}
	if p.Name != "main" {

		keep := func(list []string) {
			for _, f := range list {
				packageFile[f] = true
			}
		}
		keep(p.GoFiles)
		keep(p.CgoFiles)
		keep(p.TestGoFiles)
		keep(p.XTestGoFiles)
	}

	_, elem := filepath.Split(p.Dir)
	var allRemove []string

	if p.Name == "main" {
		allRemove = append(allRemove,
			elem,
			elem+".exe",
		)
	}

	allRemove = append(allRemove,
		elem+".test",
		elem+".test.exe",
	)

	for _, dir := range dirs {
		name := dir.Name()
		if packageFile[name] {
			continue
		}
		if !dir.IsDir() && strings.HasSuffix(name, ".go") {

			base := name[:len(name)-len(".go")]
			allRemove = append(allRemove, base, base+".exe")
		}
	}

	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd(p.Dir, "rm -f %s", strings.Join(allRemove, " "))
	}

	toRemove := map[string]bool{}
	for _, name := range allRemove {
		toRemove[name] = true
	}
	for _, dir := range dirs {
		name := dir.Name()
		if dir.IsDir() {

			if cmdgo_cleanDir[name] {
				if cmdgo_buildN || cmdgo_buildX {
					b.showcmd(p.Dir, "rm -r %s", name)
					if cmdgo_buildN {
						continue
					}
				}
				if err := os.RemoveAll(filepath.Join(p.Dir, name)); err != nil {
					cmdgo_errorf("go clean: %v", err)
				}
			}
			continue
		}

		if cmdgo_buildN {
			continue
		}

		if cmdgo_cleanFile[name] || cmdgo_cleanExt[filepath.Ext(name)] || toRemove[name] {
			cmdgo_removeFile(filepath.Join(p.Dir, name))
		}
	}

	if cmdgo_cleanI && p.target != "" {
		if cmdgo_buildN || cmdgo_buildX {
			b.showcmd("", "rm -f %s", p.target)
		}
		if !cmdgo_buildN {
			cmdgo_removeFile(p.target)
		}
	}

	if cmdgo_cleanR {
		for _, p1 := range p.imports {
			cmdgo_clean(p1)
		}
	}
}

// removeFile tries to remove file f, if error other than file doesn't exist
// occurs, it will report the error.
func cmdgo_removeFile(f string) {
	err := os.Remove(f)
	if err == nil || os.IsNotExist(err) {
		return
	}

	if cmdgo_toolIsWindows {

		if _, err2 := os.Stat(f + "~"); err2 == nil {
			os.Remove(f + "~")
		}

		if err2 := os.Rename(f, f+"~"); err2 == nil {
			os.Remove(f + "~")
			return
		}
	}
	cmdgo_errorf("go clean: %v", err)
}

type cmdgo_Context struct {
	GOARCH        string   `json:",omitempty"` // target architecture
	GOOS          string   `json:",omitempty"` // target operating system
	GOROOT        string   `json:",omitempty"` // Go root
	GOPATH        string   `json:",omitempty"` // Go path
	CgoEnabled    bool     `json:",omitempty"` // whether cgo can be used
	UseAllFiles   bool     `json:",omitempty"` // use files regardless of +build lines, file names
	Compiler      string   `json:",omitempty"` // compiler to assume when computing target paths
	BuildTags     []string `json:",omitempty"` // build constraints to match in +build lines
	ReleaseTags   []string `json:",omitempty"` // releases the current release is compatible with
	InstallSuffix string   `json:",omitempty"` // suffix to use in the name of the install dir
}

func cmdgo_newContext(c *build.Context) *cmdgo_Context {
	return &cmdgo_Context{
		GOARCH:        c.GOARCH,
		GOOS:          c.GOOS,
		GOROOT:        c.GOROOT,
		GOPATH:        c.GOPATH,
		CgoEnabled:    c.CgoEnabled,
		UseAllFiles:   c.UseAllFiles,
		Compiler:      c.Compiler,
		BuildTags:     c.BuildTags,
		ReleaseTags:   c.ReleaseTags,
		InstallSuffix: c.InstallSuffix,
	}
}

// charsetReader returns a reader for the given charset. Currently
// it only supports UTF-8 and ASCII. Otherwise, it returns a meaningful
// error which is printed by go get, so the user can find why the package
// wasn't downloaded if the encoding is not supported. Note that, in
// order to reduce potential errors, ASCII is treated as UTF-8 (i.e. characters
// greater than 0x7f are not rejected).
func cmdgo_charsetReader(charset string, input io.Reader) (io.Reader, error) {
	switch strings.ToLower(charset) {
	case "ascii":
		return input, nil
	default:
		return nil, fmt.Errorf("can't decode XML document using charset %q", charset)
	}
}

// parseMetaGoImports returns meta imports from the HTML in r.
// Parsing ends at the end of the <head> section or the beginning of the <body>.
func cmdgo_parseMetaGoImports(r io.Reader) (imports []cmdgo_metaImport, err error) {
	d := xml.NewDecoder(r)
	d.CharsetReader = cmdgo_charsetReader
	d.Strict = false
	var t xml.Token
	for {
		t, err = d.RawToken()
		if err != nil {
			if err == io.EOF || len(imports) > 0 {
				err = nil
			}
			return
		}
		if e, ok := t.(xml.StartElement); ok && strings.EqualFold(e.Name.Local, "body") {
			return
		}
		if e, ok := t.(xml.EndElement); ok && strings.EqualFold(e.Name.Local, "head") {
			return
		}
		e, ok := t.(xml.StartElement)
		if !ok || !strings.EqualFold(e.Name.Local, "meta") {
			continue
		}
		if cmdgo_attrValue(e.Attr, "name") != "go-import" {
			continue
		}
		if f := strings.Fields(cmdgo_attrValue(e.Attr, "content")); len(f) == 3 {
			imports = append(imports, cmdgo_metaImport{
				Prefix:   f[0],
				VCS:      f[1],
				RepoRoot: f[2],
			})
		}
	}
}

// attrValue returns the attribute value for the case-insensitive key
// `name', or the empty string if nothing is found.
func cmdgo_attrValue(attrs []xml.Attr, name string) string {
	for _, a := range attrs {
		if strings.EqualFold(a.Name.Local, name) {
			return a.Value
		}
	}
	return ""
}

var cmdgo_cmdDoc = &cmdgo_Command{
	Run:         cmdgo_runDoc,
	UsageLine:   "doc [-u] [-c] [package|[package.]symbol[.method]]",
	CustomFlags: true,
	Short:       "show documentation for package or symbol",
	Long: `
Doc prints the documentation comments associated with the item identified by its
arguments (a package, const, func, type, var, or method) followed by a one-line
summary of each of the first-level items "under" that item (package-level
declarations for a package, methods for a type, etc.).

Doc accepts zero, one, or two arguments.

Given no arguments, that is, when run as

	go doc

it prints the package documentation for the package in the current directory.
If the package is a command (package main), the exported symbols of the package
are elided from the presentation unless the -cmd flag is provided.

When run with one argument, the argument is treated as a Go-syntax-like
representation of the item to be documented. What the argument selects depends
on what is installed in GOROOT and GOPATH, as well as the form of the argument,
which is schematically one of these:

	go doc <pkg>
	go doc <sym>[.<method>]
	go doc [<pkg>.]<sym>[.<method>]
	go doc [<pkg>.][<sym>.]<method>

The first item in this list matched by the argument is the one whose documentation
is printed. (See the examples below.) However, if the argument starts with a capital
letter it is assumed to identify a symbol or method in the current directory.

For packages, the order of scanning is determined lexically in breadth-first order.
That is, the package presented is the one that matches the search and is nearest
the root and lexically first at its level of the hierarchy.  The GOROOT tree is
always scanned in its entirety before GOPATH.

If there is no package specified or matched, the package in the current
directory is selected, so "go doc Foo" shows the documentation for symbol Foo in
the current package.

The package path must be either a qualified path or a proper suffix of a
path. The go tool's usual package mechanism does not apply: package path
elements like . and ... are not implemented by go doc.

When run with two arguments, the first must be a full package path (not just a
suffix), and the second is a symbol or symbol and method; this is similar to the
syntax accepted by godoc:

	go doc <pkg> <sym>[.<method>]

In all forms, when matching symbols, lower-case letters in the argument match
either case but upper-case letters match exactly. This means that there may be
multiple matches of a lower-case argument in a package if different symbols have
different cases. If this occurs, documentation for all matches is printed.

Examples:
	go doc
		Show documentation for current package.
	go doc Foo
		Show documentation for Foo in the current package.
		(Foo starts with a capital letter so it cannot match
		a package path.)
	go doc encoding/json
		Show documentation for the encoding/json package.
	go doc json
		Shorthand for encoding/json.
	go doc json.Number (or go doc json.number)
		Show documentation and method summary for json.Number.
	go doc json.Number.Int64 (or go doc json.number.int64)
		Show documentation for json.Number's Int64 method.
	go doc cmd/doc
		Show package docs for the doc command.
	go doc -cmd cmd/doc
		Show package docs and exported symbols within the doc command.
	go doc template.new
		Show documentation for html/template's New function.
		(html/template is lexically before text/template)
	go doc text/template.new # One argument
		Show documentation for text/template's New function.
	go doc text/template new # Two arguments
		Show documentation for text/template's New function.

	At least in the current tree, these invocations all print the
	documentation for json.Decoder's Decode method:

	go doc json.Decoder.Decode
	go doc json.decoder.decode
	go doc json.decode
	cd go/src/encoding/json; go doc decode

Flags:
	-c
		Respect case when matching symbols.
	-cmd
		Treat a command (package main) like a regular package.
		Otherwise package main's exported symbols are hidden
		when showing the package's top-level documentation.
	-u
		Show documentation for unexported as well as exported
		symbols and methods.
`,
}

func cmdgo_runDoc(cmd *cmdgo_Command, args []string) {
	cmdgo_run(cmdgo_buildToolExec, cmdgo_tool("doc"), args)
}

var cmdgo_cmdEnv = &cmdgo_Command{
	Run:       cmdgo_runEnv,
	UsageLine: "env [var ...]",
	Short:     "print Go environment information",
	Long: `
Env prints Go environment information.

By default env prints information as a shell script
(on Windows, a batch file).  If one or more variable
names is given as arguments,  env prints the value of
each named variable on its own line.
	`,
}

type cmdgo_envVar struct {
	name, value string
}

func cmdgo_mkEnv() []cmdgo_envVar {
	var b cmdgo_builder
	b.init()

	env := []cmdgo_envVar{
		{"GOARCH", cmdgo_goarch},
		{"GOBIN", cmdgo_gobin},
		{"GOEXE", cmdgo_exeSuffix},
		{"GOHOSTARCH", runtime.GOARCH},
		{"GOHOSTOS", runtime.GOOS},
		{"GOOS", cmdgo_goos},
		{"GOPATH", os.Getenv("GOPATH")},
		{"GORACE", os.Getenv("GORACE")},
		{"GOROOT", cmdgo_goroot},
		{"GOTOOLDIR", cmdgo_toolDir},

		{"TERM", "dumb"},
	}

	if cmdgo_goos != "plan9" {
		cmd := b.gccCmd(".")
		env = append(env, cmdgo_envVar{"CC", cmd[0]})
		env = append(env, cmdgo_envVar{"GOGCCFLAGS", strings.Join(cmd[3:], " ")})
		cmd = b.gxxCmd(".")
		env = append(env, cmdgo_envVar{"CXX", cmd[0]})
	}

	if cmdgo_buildContext.CgoEnabled {
		env = append(env, cmdgo_envVar{"CGO_ENABLED", "1"})
	} else {
		env = append(env, cmdgo_envVar{"CGO_ENABLED", "0"})
	}

	return env
}

func cmdgo_findEnv(env []cmdgo_envVar, name string) string {
	for _, e := range env {
		if e.name == name {
			return e.value
		}
	}
	return ""
}

func cmdgo_runEnv(cmd *cmdgo_Command, args []string) {
	env := cmdgo_mkEnv()
	if len(args) > 0 {
		for _, name := range args {
			fmt.Printf("%s\n", cmdgo_findEnv(env, name))
		}
		return
	}

	for _, e := range env {
		if e.name != "TERM" {
			switch runtime.GOOS {
			default:
				fmt.Printf("%s=\"%s\"\n", e.name, e.value)
			case "plan9":
				if strings.IndexByte(e.value, '\x00') < 0 {
					fmt.Printf("%s='%s'\n", e.name, strings.Replace(e.value, "'", "''", -1))
				} else {
					v := strings.Split(e.value, "\x00")
					fmt.Printf("%s=(", e.name)
					for x, s := range v {
						if x > 0 {
							fmt.Printf(" ")
						}
						fmt.Printf("%s", s)
					}
					fmt.Printf(")\n")
				}
			case "windows":
				fmt.Printf("set %s=%s\n", e.name, e.value)
			}
		}
	}
}

var cmdgo_cmdFix = &cmdgo_Command{
	Run:       cmdgo_runFix,
	UsageLine: "fix [packages]",
	Short:     "run go tool fix on packages",
	Long: `
Fix runs the Go fix command on the packages named by the import paths.

For more about fix, see 'go doc cmd/fix'.
For more about specifying packages, see 'go help packages'.

To run fix with specific options, run 'go tool fix'.

See also: go fmt, go vet.
	`,
}

func cmdgo_runFix(cmd *cmdgo_Command, args []string) {
	for _, pkg := range cmdgo_packages(args) {

		cmdgo_run(cmdgo_stringList(cmdgo_buildToolExec, cmdgo_tool("fix"), cmdgo_relPaths(pkg.allgofiles)))
	}
}

func init() {
	cmdgo_addBuildFlagsNX(cmdgo_cmdFmt)
}

var cmdgo_cmdFmt = &cmdgo_Command{
	Run:       cmdgo_runFmt,
	UsageLine: "fmt [-n] [-x] [packages]",
	Short:     "run gofmt on package sources",
	Long: `
Fmt runs the command 'gofmt -l -w' on the packages named
by the import paths.  It prints the names of the files that are modified.

For more about gofmt, see 'go doc cmd/gofmt'.
For more about specifying packages, see 'go help packages'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

To run gofmt with specific options, run gofmt itself.

See also: go fix, go vet.
	`,
}

func cmdgo_runFmt(cmd *cmdgo_Command, args []string) {
	gofmt := cmdgo_gofmtPath()
	for _, pkg := range cmdgo_packages(args) {

		cmdgo_run(cmdgo_stringList(gofmt, "-l", "-w", cmdgo_relPaths(pkg.allgofiles)))
	}
}

func cmdgo_gofmtPath() string {
	gofmt := "gofmt"
	if cmdgo_toolIsWindows {
		gofmt += cmdgo_toolWindowsExtension
	}

	gofmtPath := filepath.Join(cmdgo_gobin, gofmt)
	if _, err := os.Stat(gofmtPath); err == nil {
		return gofmtPath
	}

	gofmtPath = filepath.Join(cmdgo_goroot, "bin", gofmt)
	if _, err := os.Stat(gofmtPath); err == nil {
		return gofmtPath
	}

	return "gofmt"
}

var cmdgo_cmdGenerate = &cmdgo_Command{
	Run:       cmdgo_runGenerate,
	UsageLine: "generate [-run regexp] [-n] [-v] [-x] [build flags] [file.go... | packages]",
	Short:     "generate Go files by processing source",
	Long: `
Generate runs commands described by directives within existing
files. Those commands can run any process but the intent is to
create or update Go source files, for instance by running yacc.

Go generate is never run automatically by go build, go get, go test,
and so on. It must be run explicitly.

Go generate scans the file for directives, which are lines of
the form,

	//go:generate command argument...

(note: no leading spaces and no space in "//go") where command
is the generator to be run, corresponding to an executable file
that can be run locally. It must either be in the shell path
(gofmt), a fully qualified path (/usr/you/bin/mytool), or a
command alias, described below.

Note that go generate does not parse the file, so lines that look
like directives in comments or multiline strings will be treated
as directives.

The arguments to the directive are space-separated tokens or
double-quoted strings passed to the generator as individual
arguments when it is run.

Quoted strings use Go syntax and are evaluated before execution; a
quoted string appears as a single argument to the generator.

Go generate sets several variables when it runs the generator:

	$GOARCH
		The execution architecture (arm, amd64, etc.)
	$GOOS
		The execution operating system (linux, windows, etc.)
	$GOFILE
		The base name of the file.
	$GOLINE
		The line number of the directive in the source file.
	$GOPACKAGE
		The name of the package of the file containing the directive.
	$DOLLAR
		A dollar sign.

Other than variable substitution and quoted-string evaluation, no
special processing such as "globbing" is performed on the command
line.

As a last step before running the command, any invocations of any
environment variables with alphanumeric names, such as $GOFILE or
$HOME, are expanded throughout the command line. The syntax for
variable expansion is $NAME on all operating systems.  Due to the
order of evaluation, variables are expanded even inside quoted
strings. If the variable NAME is not set, $NAME expands to the
empty string.

A directive of the form,

	//go:generate -command xxx args...

specifies, for the remainder of this source file only, that the
string xxx represents the command identified by the arguments. This
can be used to create aliases or to handle multiword generators.
For example,

	//go:generate -command yacc go tool yacc

specifies that the command "yacc" represents the generator
"go tool yacc".

Generate processes packages in the order given on the command line,
one at a time. If the command line lists .go files, they are treated
as a single package. Within a package, generate processes the
source files in a package in file name order, one at a time. Within
a source file, generate runs generators in the order they appear
in the file, one at a time.

If any generator returns an error exit status, "go generate" skips
all further processing for that package.

The generator is run in the package's source directory.

Go generate accepts one specific flag:

	-run=""
		if non-empty, specifies a regular expression to select
		directives whose full original source text (excluding
		any trailing spaces and final newline) matches the
		expression.

It also accepts the standard build flags including -v, -n, and -x.
The -v flag prints the names of packages and files as they are
processed.
The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

For more about build flags, see 'go help build'.

For more about specifying packages, see 'go help packages'.
	`,
}

var (
	cmdgo_generateRunFlag string         // generate -run flag
	cmdgo_generateRunRE   *regexp.Regexp // compiled expression for -run
)

func init() {
	cmdgo_addBuildFlags(cmdgo_cmdGenerate)
	cmdgo_cmdGenerate.Flag.StringVar(&cmdgo_generateRunFlag, "run", "", "")
}

func cmdgo_runGenerate(cmd *cmdgo_Command, args []string) {
	if cmdgo_generateRunFlag != "" {
		var err error
		cmdgo_generateRunRE, err = regexp.Compile(cmdgo_generateRunFlag)
		if err != nil {
			log.Fatalf("generate: %s", err)
		}
	}

	for _, pkg := range cmdgo_packages(args) {
		for _, file := range pkg.gofiles {
			if !cmdgo_generate(pkg.Name, file) {
				break
			}
		}
	}
}

// generate runs the generation directives for a single file.
func cmdgo_generate(pkg, absFile string) bool {
	fd, err := os.Open(absFile)
	if err != nil {
		log.Fatalf("generate: %s", err)
	}
	defer fd.Close()
	g := &cmdgo_Generator{
		r:        fd,
		path:     absFile,
		pkg:      pkg,
		commands: make(map[string][]string),
	}
	return g.run()
}

// A Generator represents the state of a single Go source file
// being scanned for generator commands.
type cmdgo_Generator struct {
	r        io.Reader
	path     string // full rooted path name.
	dir      string // full rooted directory of file.
	file     string // base name of file.
	pkg      string
	commands map[string][]string
	lineNum  int // current line number.
	env      []string
}

// run runs the generators in the current file.
func (g *cmdgo_Generator) run() (ok bool) {

	defer func() {
		e := recover()
		if e != nil {
			ok = false
			if e != cmdgo_stop {
				panic(e)
			}
			cmdgo_setExitStatus(1)
		}
	}()
	g.dir, g.file = filepath.Split(g.path)
	g.dir = filepath.Clean(g.dir)
	if cmdgo_buildV {
		fmt.Fprintf(os.Stderr, "%s\n", cmdgo_shortPath(g.path))
	}

	input := bufio.NewReader(g.r)
	var err error

	for {
		g.lineNum++
		var buf []byte
		buf, err = input.ReadSlice('\n')
		if err == bufio.ErrBufferFull {

			if cmdgo_isGoGenerate(buf) {
				g.errorf("directive too long")
			}
			for err == bufio.ErrBufferFull {
				_, err = input.ReadSlice('\n')
			}
			if err != nil {
				break
			}
			continue
		}

		if err != nil {

			if err == io.EOF && cmdgo_isGoGenerate(buf) {
				err = io.ErrUnexpectedEOF
			}
			break
		}

		if !cmdgo_isGoGenerate(buf) {
			continue
		}
		if cmdgo_generateRunFlag != "" {
			if !cmdgo_generateRunRE.Match(bytes.TrimSpace(buf)) {
				continue
			}
		}

		g.setEnv()
		words := g.split(string(buf))
		if len(words) == 0 {
			g.errorf("no arguments to directive")
		}
		if words[0] == "-command" {
			g.setShorthand(words)
			continue
		}

		if cmdgo_buildN || cmdgo_buildX {
			fmt.Fprintf(os.Stderr, "%s\n", strings.Join(words, " "))
		}
		if cmdgo_buildN {
			continue
		}
		g.exec(words)
	}
	if err != nil && err != io.EOF {
		g.errorf("error reading %s: %s", cmdgo_shortPath(g.path), err)
	}
	return true
}

func cmdgo_isGoGenerate(buf []byte) bool {
	return bytes.HasPrefix(buf, []byte("//go:generate ")) || bytes.HasPrefix(buf, []byte("//go:generate\t"))
}

// setEnv sets the extra environment variables used when executing a
// single go:generate command.
func (g *cmdgo_Generator) setEnv() {
	g.env = []string{
		"GOARCH=" + cmdgo_buildContext.GOARCH,
		"GOOS=" + cmdgo_buildContext.GOOS,
		"GOFILE=" + g.file,
		"GOLINE=" + strconv.Itoa(g.lineNum),
		"GOPACKAGE=" + g.pkg,
		"DOLLAR=" + "$",
	}
}

// split breaks the line into words, evaluating quoted
// strings and evaluating environment variables.
// The initial //go:generate element is present in line.
func (g *cmdgo_Generator) split(line string) []string {
	// Parse line, obeying quoted strings.
	var words []string
	line = line[len("//go:generate ") : len(line)-1]

	if len(line) > 0 && line[len(line)-1] == '\r' {
		line = line[:len(line)-1]
	}

Words:
	for {
		line = strings.TrimLeft(line, " \t")
		if len(line) == 0 {
			break
		}
		if line[0] == '"' {
			for i := 1; i < len(line); i++ {
				c := line[i]
				switch c {
				case '\\':
					if i+1 == len(line) {
						g.errorf("bad backslash")
					}
					i++
				case '"':
					word, err := strconv.Unquote(line[0 : i+1])
					if err != nil {
						g.errorf("bad quoted string")
					}
					words = append(words, word)
					line = line[i+1:]

					if len(line) > 0 && line[0] != ' ' && line[0] != '\t' {
						g.errorf("expect space after quoted argument")
					}
					continue Words
				}
			}
			g.errorf("mismatched quoted string")
		}
		i := strings.IndexAny(line, " \t")
		if i < 0 {
			i = len(line)
		}
		words = append(words, line[0:i])
		line = line[i:]
	}

	if len(words) > 0 && g.commands[words[0]] != nil {

		words = append(g.commands[words[0]], words[1:]...)
	}

	for i, word := range words {
		words[i] = os.Expand(word, g.expandVar)
	}
	return words
}

var cmdgo_stop = fmt.Errorf("error in generation")

// errorf logs an error message prefixed with the file and line number.
// It then exits the program (with exit status 1) because generation stops
// at the first error.
func (g *cmdgo_Generator) errorf(format string, args ...interface{}) {
	fmt.Fprintf(os.Stderr, "%s:%d: %s\n", cmdgo_shortPath(g.path), g.lineNum,
		fmt.Sprintf(format, args...))
	panic(cmdgo_stop)
}

// expandVar expands the $XXX invocation in word. It is called
// by os.Expand.
func (g *cmdgo_Generator) expandVar(word string) string {
	w := word + "="
	for _, e := range g.env {
		if strings.HasPrefix(e, w) {
			return e[len(w):]
		}
	}
	return os.Getenv(word)
}

// setShorthand installs a new shorthand as defined by a -command directive.
func (g *cmdgo_Generator) setShorthand(words []string) {

	if len(words) == 1 {
		g.errorf("no command specified for -command")
	}
	command := words[1]
	if g.commands[command] != nil {
		g.errorf("command %q defined multiply defined", command)
	}
	g.commands[command] = words[2:len(words):len(words)]
}

// exec runs the command specified by the argument. The first word is
// the command name itself.
func (g *cmdgo_Generator) exec(words []string) {
	cmd := exec.Command(words[0], words[1:]...)

	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr

	cmd.Dir = g.dir
	cmd.Env = cmdgo_mergeEnvLists(g.env, cmdgo_origEnv)
	err := cmd.Run()
	if err != nil {
		g.errorf("running %q: %s", words[0], err)
	}
}

var cmdgo_cmdGet = &cmdgo_Command{
	UsageLine: "get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]",
	Short:     "download and install packages and dependencies",
	Long: `
Get downloads the packages named by the import paths, along with their
dependencies. It then installs the named packages, like 'go install'.

The -d flag instructs get to stop after downloading the packages; that is,
it instructs get not to install the packages.

The -f flag, valid only when -u is set, forces get -u not to verify that
each package has been checked out from the source control repository
implied by its import path. This can be useful if the source is a local fork
of the original.

The -fix flag instructs get to run the fix tool on the downloaded packages
before resolving dependencies or building the code.

The -insecure flag permits fetching from repositories and resolving
custom domains using insecure schemes such as HTTP. Use with caution.

The -t flag instructs get to also download the packages required to build
the tests for the specified packages.

The -u flag instructs get to use the network to update the named packages
and their dependencies.  By default, get uses the network to check out
missing packages but does not use it to look for updates to existing packages.

Get also accepts build flags to control the installation. See 'go help build'.

When checking out a new package, get creates the target directory
GOPATH/src/<import-path>. If the GOPATH contains multiple entries,
get uses the first one. See 'go help gopath'.

When checking out or updating a package, get looks for a branch or tag
that matches the locally installed version of Go. The most important
rule is that if the local installation is running version "go1", get
searches for a branch or tag named "go1". If no such version exists it
retrieves the most recent version of the package.

When go get checks out or updates a Git repository,
it also updates any git submodules referenced by the repository.

Get never checks out or updates code stored in vendor directories.

For more about specifying packages, see 'go help packages'.

For more about how 'go get' finds source code to
download, see 'go help importpath'.

See also: go build, go install, go clean.
	`,
}

var cmdgo_getD = cmdgo_cmdGet.Flag.Bool("d", false, "")

var cmdgo_getF = cmdgo_cmdGet.Flag.Bool("f", false, "")

var cmdgo_getT = cmdgo_cmdGet.Flag.Bool("t", false, "")

var cmdgo_getU = cmdgo_cmdGet.Flag.Bool("u", false, "")

var cmdgo_getFix = cmdgo_cmdGet.Flag.Bool("fix", false, "")

var cmdgo_getInsecure = cmdgo_cmdGet.Flag.Bool("insecure", false, "")

func init() {
	cmdgo_addBuildFlags(cmdgo_cmdGet)
	cmdgo_cmdGet.Run = cmdgo_runGet
}

func cmdgo_runGet(cmd *cmdgo_Command, args []string) {
	if *cmdgo_getF && !*cmdgo_getU {
		cmdgo_fatalf("go get: cannot use -f flag without -u")
	}

	if os.Getenv("GIT_TERMINAL_PROMPT") == "" {
		os.Setenv("GIT_TERMINAL_PROMPT", "0")
	}

	// Phase 1.  Download/update.
	var stk cmdgo_importStack
	mode := 0
	if *cmdgo_getT {
		mode |= cmdgo_getTestDeps
	}
	for _, arg := range cmdgo_downloadPaths(args) {
		cmdgo_download(arg, nil, &stk, mode)
	}
	cmdgo_exitIfErrors()

	for name := range cmdgo_packageCache {
		delete(cmdgo_packageCache, name)
	}

	for name := range cmdgo_cmdCache {
		delete(cmdgo_cmdCache, name)
	}

	args = cmdgo_importPaths(args)
	cmdgo_packagesForBuild(args)

	if *cmdgo_getD {

		return
	}

	cmdgo_runInstall(cmd, args)
}

// downloadPaths prepares the list of paths to pass to download.
// It expands ... patterns that can be expanded. If there is no match
// for a particular pattern, downloadPaths leaves it in the result list,
// in the hope that we can figure out the repository from the
// initial ...-free prefix.
func cmdgo_downloadPaths(args []string) []string {
	args = cmdgo_importPathsNoDotExpansion(args)
	var out []string
	for _, a := range args {
		if strings.Contains(a, "...") {
			var expand []string

			if build.IsLocalImport(a) {
				expand = cmdgo_matchPackagesInFS(a)
			} else {
				expand = cmdgo_matchPackages(a)
			}
			if len(expand) > 0 {
				out = append(out, expand...)
				continue
			}
		}
		out = append(out, a)
	}
	return out
}

// downloadCache records the import paths we have already
// considered during the download, to avoid duplicate work when
// there is more than one dependency sequence leading to
// a particular package.
var cmdgo_downloadCache = map[string]bool{}

// downloadRootCache records the version control repository
// root directories we have already considered during the download.
// For example, all the packages in the code.google.com/p/codesearch repo
// share the same root (the directory for that path), and we only need
// to run the hg commands to consider each repository once.
var cmdgo_downloadRootCache = map[string]bool{}

// download runs the download half of the get command
// for the package named by the argument.
func cmdgo_download(arg string, parent *cmdgo_Package, stk *cmdgo_importStack, mode int) {
	load := func(path string, mode int) *cmdgo_Package {
		if parent == nil {
			return cmdgo_loadPackage(path, stk)
		}
		return cmdgo_loadImport(path, parent.Dir, parent, stk, nil, mode)
	}

	p := load(arg, mode)
	if p.Error != nil && p.Error.hard {
		cmdgo_errorf("%s", p.Error)
		return
	}

	arg = p.ImportPath

	if p.Standard {
		return
	}

	if cmdgo_downloadCache[arg] && mode&cmdgo_getTestDeps == 0 {
		return
	}
	cmdgo_downloadCache[arg] = true

	pkgs := []*cmdgo_Package{p}
	wildcardOkay := len(*stk) == 0
	isWildcard := false

	if p.Dir == "" || *cmdgo_getU {

		stk.push(arg)
		err := cmdgo_downloadPackage(p)
		if err != nil {
			cmdgo_errorf("%s", &cmdgo_PackageError{ImportStack: stk.copy(), Err: err.Error()})
			stk.pop()
			return
		}
		stk.pop()

		args := []string{arg}

		if wildcardOkay && strings.Contains(arg, "...") {
			if build.IsLocalImport(arg) {
				args = cmdgo_matchPackagesInFS(arg)
			} else {
				args = cmdgo_matchPackages(arg)
			}
			isWildcard = true
		}

		for _, arg := range args {
			p := cmdgo_packageCache[arg]
			if p != nil {
				delete(cmdgo_packageCache, p.Dir)
				delete(cmdgo_packageCache, p.ImportPath)
			}
		}

		pkgs = pkgs[:0]
		for _, arg := range args {

			p := load(arg, mode)
			if p.Error != nil {
				cmdgo_errorf("%s", p.Error)
				continue
			}
			pkgs = append(pkgs, p)
		}
	}

	for _, p := range pkgs {
		if *cmdgo_getFix {
			cmdgo_run(cmdgo_buildToolExec, cmdgo_stringList(cmdgo_tool("fix"), cmdgo_relPaths(p.allgofiles)))

			p = cmdgo_reloadPackage(arg, stk)
			if p.Error != nil {
				cmdgo_errorf("%s", p.Error)
				return
			}
		}

		if isWildcard {

			stk.push(p.ImportPath)
		}

		for _, path := range p.Imports {
			if path == "C" {
				continue
			}

			cmdgo_download(path, p, stk, 0)
		}
		if mode&cmdgo_getTestDeps != 0 {

			for _, path := range p.TestImports {
				if path == "C" {
					continue
				}
				cmdgo_download(path, p, stk, cmdgo_useVendor)
			}
			for _, path := range p.XTestImports {
				if path == "C" {
					continue
				}
				cmdgo_download(path, p, stk, cmdgo_useVendor)
			}
		}

		if isWildcard {
			stk.pop()
		}
	}
}

// downloadPackage runs the create or download command
// to make the first copy of or update a copy of the given package.
func cmdgo_downloadPackage(p *cmdgo_Package) error {
	var (
		vcs            *cmdgo_vcsCmd
		repo, rootPath string
		err            error
	)

	security := cmdgo_secure
	if *cmdgo_getInsecure {
		security = cmdgo_insecure
	}

	if p.build.SrcRoot != "" {

		vcs, rootPath, err = cmdgo_vcsFromDir(p.Dir, p.build.SrcRoot)
		if err != nil {
			return err
		}
		repo = "<local>"

		if *cmdgo_getU && vcs.remoteRepo != nil {
			dir := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))
			remote, err := vcs.remoteRepo(vcs, dir)
			if err != nil {
				return err
			}
			repo = remote
			if !*cmdgo_getF {
				if rr, err := cmdgo_repoRootForImportPath(p.ImportPath, security); err == nil {
					repo := rr.repo
					if rr.vcs.resolveRepo != nil {
						resolved, err := rr.vcs.resolveRepo(rr.vcs, dir, repo)
						if err == nil {
							repo = resolved
						}
					}
					if remote != repo && p.ImportComment != "" {
						return fmt.Errorf("%s is a custom import path for %s, but %s is checked out from %s", rr.root, repo, dir, remote)
					}
				}
			}
		}
	} else {

		rr, err := cmdgo_repoRootForImportPath(p.ImportPath, security)
		if err != nil {
			return err
		}
		vcs, repo, rootPath = rr.vcs, rr.repo, rr.root
	}
	if !vcs.isSecure(repo) && !*cmdgo_getInsecure {
		return fmt.Errorf("cannot download, %v uses insecure protocol", repo)
	}

	if p.build.SrcRoot == "" {

		list := filepath.SplitList(cmdgo_buildContext.GOPATH)
		if len(list) == 0 {
			return fmt.Errorf("cannot download, $GOPATH not set. For more details see: go help gopath")
		}

		if list[0] == cmdgo_goroot {
			return fmt.Errorf("cannot download, $GOPATH must not be set to $GOROOT. For more details see: go help gopath")
		}
		p.build.SrcRoot = filepath.Join(list[0], "src")
		p.build.PkgRoot = filepath.Join(list[0], "pkg")
	}
	root := filepath.Join(p.build.SrcRoot, filepath.FromSlash(rootPath))

	if cmdgo_downloadRootCache[root] {
		return nil
	}
	cmdgo_downloadRootCache[root] = true

	if cmdgo_buildV {
		fmt.Fprintf(os.Stderr, "%s (download)\n", rootPath)
	}

	meta := filepath.Join(root, "."+vcs.cmd)
	st, err := os.Stat(meta)
	if err == nil && !st.IsDir() {
		return fmt.Errorf("%s exists but is not a directory", meta)
	}
	if err != nil {

		if _, err := os.Stat(root); err == nil {
			return fmt.Errorf("%s exists but %s does not - stale checkout?", root, meta)
		}

		parent, _ := filepath.Split(root)
		if err = os.MkdirAll(parent, 0777); err != nil {
			return err
		}
		if err = vcs.create(root, repo); err != nil {
			return err
		}
	} else {

		if err = vcs.download(root); err != nil {
			return err
		}
	}

	if cmdgo_buildN {

		fmt.Fprintf(os.Stderr, "# cd %s; %s sync/update\n", root, vcs.cmd)
		return nil
	}

	tags, err := vcs.tags(root)
	if err != nil {
		return err
	}
	vers := runtime.Version()
	if i := strings.Index(vers, " "); i >= 0 {
		vers = vers[:i]
	}
	if err := vcs.tagSync(root, cmdgo_selectTag(vers, tags)); err != nil {
		return err
	}

	return nil
}

// goTag matches go release tags such as go1 and go1.2.3.
// The numbers involved must be small (at most 4 digits),
// have no unnecessary leading zeros, and the version cannot
// end in .0 - it is go1, not go1.0 or go1.0.0.
var cmdgo_goTag = regexp.MustCompile(
	`^go((0|[1-9][0-9]{0,3})\.)*([1-9][0-9]{0,3})$`,
)

// selectTag returns the closest matching tag for a given version.
// Closest means the latest one that is not after the current release.
// Version "goX" (or "goX.Y" or "goX.Y.Z") matches tags of the same form.
// Version "release.rN" matches tags of the form "go.rN" (N being a floating-point number).
// Version "weekly.YYYY-MM-DD" matches tags like "go.weekly.YYYY-MM-DD".
//
// NOTE(rsc): Eventually we will need to decide on some logic here.
// For now, there is only "go1".  This matches the docs in go help get.
func cmdgo_selectTag(goVersion string, tags []string) (match string) {
	for _, t := range tags {
		if t == "go1" {
			return "go1"
		}
	}
	return ""

}

// cmpGoVersion returns -1, 0, +1 reporting whether
// x < y, x == y, or x > y.
func cmdgo_cmpGoVersion(x, y string) int {

	if !cmdgo_goTag.MatchString(x) {
		return -1
	}
	if !cmdgo_goTag.MatchString(y) {
		return +1
	}

	xx := strings.Split(x[len("go"):], ".")
	yy := strings.Split(y[len("go"):], ".")

	for i := 0; i < len(xx) && i < len(yy); i++ {

		xi, _ := strconv.Atoi(xx[i])
		yi, _ := strconv.Atoi(yy[i])
		if xi < yi {
			return -1
		} else if xi > yi {
			return +1
		}
	}

	if len(xx) < len(yy) {
		return -1
	}
	if len(xx) > len(yy) {
		return +1
	}
	return 0
}

// Test that go1.1 tag above is included in builds. main.go refers to this definition.
const cmdgo_go11tag = true

// GopherJS toolchain.
type cmdgo_gopherjsToolchain struct {
	binaryPath string // Absolute path to the current binary.
}

// compiler and linker are used by isStale to determine if packages being built
// are stale because they're older than the compiler or linker binaries.
// To prevent isStale from always returning true, we must point (absolute path)
// to valid binaries that are otherwise unused. We'll use the current binary for this purpose.
func (t cmdgo_gopherjsToolchain) compiler() string {
	return t.binaryPath
}

func (t cmdgo_gopherjsToolchain) linker() string {
	return t.binaryPath
}

// gc runs the compiler in a specific directory on a set of files
// and returns the name of the generated output file.
func (cmdgo_gopherjsToolchain) gc(b *cmdgo_builder, p *cmdgo_Package, archive, obj string, asmhdr bool, importArgs []string, gofiles []string) (ofile string, out []byte, err error) {
	if archive != "" {
		ofile = archive
	} else {
		out := "_go_.o"
		ofile = obj + out
	}

	options := &gopherjsbuild.Options{

		Minify: true,
	}

	if p.build.IsCommand() && (!p.forceLibrary || p.ImportPath == "testmain") {

		p.ImportPath = "main"

		err := func() error {
			fset := token.NewFileSet()
			files := []*ast.File{}

			for _, goFile := range gofiles {
				f, err := parser.ParseFile(fset, filepath.Join(p.Dir, goFile), nil, 0)
				if err != nil {
					return err
				}
				files = append(files, f)
			}

			s := gopherjsbuild.NewSession(options)

			importFromDisk := func(path string) (*compiler.Archive, error) {

				if archive, ok := s.Archives[path]; ok {

					return archive, err
				}
				// TODO: Get rid of hardcoded paths.
				var (
					objFile io.ReadCloser
					err     = os.ErrNotExist
				)
				if os.IsNotExist(err) && (path == "github.com/gopherjs/gopherjs/js" || path == "github.com/gopherjs/gopherjs/nosync") {

					objFile, err = natives.FS.Open("/pkg/" + filepath.Base(path) + ".a")
				}

				if os.IsNotExist(err) {

					objFile, err = os.Open(importArgs[1] + "/" + path + ".a")
				}
				if len(importArgs) >= 4 {
					if os.IsNotExist(err) {

						objFile, err = os.Open(importArgs[3] + "/" + path + ".a")
					}
				}
				if os.IsNotExist(err) {
					objFile, err = os.Open("/usr/local/go/pkg/gopherjs_darwin_js/" + path + ".a")
				}
				if os.IsNotExist(err) {

					objFile, err = os.Open("/Users/Dmitri/Dropbox/Work/2013/GoLand/pkg/gopherjs_darwin_js/" + path + ".a")
				}
				if err != nil {
					return nil, fmt.Errorf("importFromDisk: archive for path %q missing: %v", path, err)
				}
				defer objFile.Close()
				archive, err := compiler.ReadArchive(path, objFile, s.Types)
				if err != nil {
					return nil, fmt.Errorf("importFromDisk: compiler.ReadArchive for path %q had problem: %v", path, err)
				}
				s.Archives[path] = archive
				return archive, nil
			}
			importContext := &compiler.ImportContext{
				Packages: s.Types,
				Import:   importFromDisk,
			}
			archive, err := compiler.Compile(p.ImportPath, files, fset, importContext, options.Minify)
			if err != nil {
				return fmt.Errorf("compiler.Compile: %v", err)
			}

			deps, err := compiler.ImportDependencies(archive, importFromDisk)
			if err != nil {
				return fmt.Errorf("compiler.ImportDependencies: %v", err)
			}

			target, err := os.OpenFile(ofile, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
			if err != nil {
				return err
			}
			defer target.Close()
			return compiler.WriteProgramCode(deps, &compiler.SourceMapFilter{Writer: target})
		}()
		if err != nil {
			return "", nil, err
		}
	} else {

		s := gopherjsbuild.NewSession(options)

		pkg, err := cmdgo_Import(p.ImportPath, 0, "", nil)
		if err != nil {
			return "", nil, err
		}

		importFromDisk := func(path string) (*compiler.Archive, error) {
			if archive, ok := s.Archives[path]; ok {
				return archive, err
			}
			// TODO: Get rid of hardcoded paths.
			var (
				objFile io.ReadCloser
				err     = os.ErrNotExist
			)
			if os.IsNotExist(err) && (path == "github.com/gopherjs/gopherjs/js" || path == "github.com/gopherjs/gopherjs/nosync") {

				objFile, err = natives.FS.Open("/pkg/" + filepath.Base(path) + ".a")
			}
			if os.IsNotExist(err) {

				objFile, err = os.Open(importArgs[1] + "/" + path + ".a")
			}
			if len(importArgs) >= 4 {
				if os.IsNotExist(err) {

					objFile, err = os.Open(importArgs[3] + "/" + path + ".a")
				}
			}
			if os.IsNotExist(err) {

				objFile, err = os.Open("/Users/Dmitri/Dropbox/Work/2013/GoLand/pkg/gopherjs_darwin_js/" + path + ".a")
			}
			if os.IsNotExist(err) {
				objFile, err = os.Open("/usr/local/go/pkg/gopherjs_darwin_js/" + path + ".a")
			}
			if err != nil {
				return nil, fmt.Errorf("importFromDisk: archive for path %q missing: %v", path, err)
			}
			defer objFile.Close()
			archive, err := compiler.ReadArchive(path, objFile, s.Types)
			if err != nil {
				return nil, fmt.Errorf("importFromDisk: compiler.ReadArchive for path %q had problem: %v", path, err)
			}
			s.Archives[path] = archive
			return archive, nil
		}

		for _, gofile := range gofiles {
			if strings.HasSuffix(gofile, "_test.go") {
				pkg.IsTest = true
				pkg.Package.GoFiles = gofiles

				switch p.ImportPath {
				case "runtime":
					pkg.GoFiles = []string{"error.go"}
				case "runtime/internal/sys":
					pkg.GoFiles = []string{fmt.Sprintf("zgoos_%s.go", cmdgo_buildContext.GOOS), "zversion.go"}
				case "runtime/pprof":
					pkg.GoFiles = nil
				case "crypto/rand":
					pkg.GoFiles = []string{"rand.go", "util.go", "rand_test.go"}
				case "crypto/x509":
					pkg.CgoFiles = nil
				case "hash/crc32":
					pkg.GoFiles = append(pkg.GoFiles, "crc32_generic.go")
				}
				break
			}
		}

		archive, err := cmdgo_BuildPackage(pkg, s, options, importFromDisk)
		if err != nil {
			return "", nil, fmt.Errorf("BuildPackage: %v", err)
		}

		writeLibraryPackage := func(archive *compiler.Archive, ofile string) error {
			objFile, err := os.Create(ofile)
			if err != nil {
				return err
			}
			defer objFile.Close()
			return compiler.WriteArchive(archive, objFile)
		}
		err = writeLibraryPackage(archive, ofile)
		if err != nil {
			return "", nil, err
		}
	}

	return ofile, nil, nil
}

// ld runs the linker to create an executable starting at mainpkg.
func (g cmdgo_gopherjsToolchain) ld(b *cmdgo_builder, root *cmdgo_action, out string, allactions []*cmdgo_action, mainpkg string, ofiles []string) error {
	if root.p.Name != "main" {
		return fmt.Errorf("expected package main but got %q", root.p.Name)
	}

	{
		src, err := os.Open(mainpkg)
		if err != nil {
			return err
		}
		defer src.Close()

		err = ioutil2.WriteFile(out, src)
		if err != nil {
			return err
		}
	}

	return nil
}

// ldShared runs the linker to create a shared library containing the pkgs built by toplevelactions
func (cmdgo_gopherjsToolchain) ldShared(b *cmdgo_builder, toplevelactions []*cmdgo_action, out string, allactions []*cmdgo_action) error {
	return fmt.Errorf("GopherJS has not implemented support for shared libraries")
}

func cmdgo_BuildPackage(pkg *gopherjsbuild.PackageData, s *gopherjsbuild.Session, options *gopherjsbuild.Options, importLoader func(path string) (*compiler.Archive, error)) (*compiler.Archive, error) {
	fileSet := token.NewFileSet()
	files, err := gopherjsbuild.Parse(pkg.Package, pkg.IsTest, fileSet)
	if err != nil {
		return nil, fmt.Errorf("gopherjsbuild.Parse (in BuildPackage): %v", err)
	}

	importContext := &compiler.ImportContext{
		Packages: s.Types,
		Import:   importLoader,
	}
	archive, err := compiler.Compile(pkg.ImportPath, files, fileSet, importContext, options.Minify)
	if err != nil {
		return nil, fmt.Errorf("compiler.Compile (in BuildPackage): %v", err)
	}

	return archive, nil
}

// Import returns details about the Go package named by the import path. If the
// path is a local import path naming a package that can be imported using
// a standard import path, the returned package will set p.ImportPath to
// that path.
//
// In the directory containing the package, .go and .inc.js files are
// considered part of the package except for:
//
//    - .go files in package documentation
//    - files starting with _ or . (likely editor temporary files)
//    - files with build constraints not satisfied by the context
//
// If an error occurs, Import returns a non-nil error and a nil
// *PackageData.
func cmdgo_Import(path string, mode build.ImportMode, installSuffix string, buildTags []string) (*gopherjsbuild.PackageData, error) {
	return cmdgo_importWithSrcDir(path, "", mode, installSuffix, buildTags)
}

func cmdgo_newBuildContext(installSuffix string, buildTags []string) *build.Context {
	return &build.Context{
		GOROOT:        build.Default.GOROOT,
		GOPATH:        build.Default.GOPATH,
		GOOS:          build.Default.GOOS,
		GOARCH:        "js",
		InstallSuffix: installSuffix,
		Compiler:      "gopherjs",
		BuildTags:     append(buildTags, "netgo"),
		ReleaseTags:   build.Default.ReleaseTags,
	}

}

func cmdgo_importWithSrcDir(path string, srcDir string, mode build.ImportMode, installSuffix string, buildTags []string) (*gopherjsbuild.PackageData, error) {
	buildContext := cmdgo_newBuildContext(installSuffix, buildTags)
	if path == "runtime" || path == "syscall" {
		buildContext.GOARCH = "amd64"

		if installSuffix != "" {
			buildContext.InstallSuffix += "_" + installSuffix
		}
	}

	// TODO, HACK: Import path can't have _test suffix or else buildContext.Import won't
	//             actually find it. So strip it here and re-attach to pkg.ImportPath after.
	//             There's gotta be a better way this should be done.
	var xTest bool
	if strings.HasSuffix(path, "_test") {
		path = path[:len(path)-5]
		xTest = true
	}

	pkg, err := buildContext.Import(path, srcDir, mode)
	if err != nil {
		return nil, err
	}

	if xTest {
		pkg.ImportPath += "_test"
	}

	switch path {
	case "runtime":
		pkg.GoFiles = []string{"error.go"}
	case "runtime/internal/sys":
		pkg.GoFiles = []string{fmt.Sprintf("zgoos_%s.go", buildContext.GOOS), "zversion.go"}
	case "runtime/pprof":
		pkg.GoFiles = nil
	case "crypto/rand":
		pkg.GoFiles = []string{"rand.go", "util.go"}
	case "crypto/x509":
		pkg.CgoFiles = nil
	case "hash/crc32":
		pkg.GoFiles = []string{"crc32.go", "crc32_generic.go"}
	}

	if len(pkg.CgoFiles) > 0 {
		return nil, &gopherjsbuild.ImportCError{}
	}

	return &gopherjsbuild.PackageData{Package: pkg}, nil
}

// asm runs the assembler in a specific directory on a specific file
// to generate the named output file.
func (cmdgo_gopherjsToolchain) asm(b *cmdgo_builder, p *cmdgo_Package, obj, ofile, sfile string) error {

	return nil
}

// pkgpath builds an appropriate path for a temporary package file.
func (cmdgo_gopherjsToolchain) pkgpath(basedir string, p *cmdgo_Package) string {

	end := filepath.FromSlash(p.ImportPath + ".a")
	return filepath.Join(basedir, end)
}

// pack runs the archive packer in a specific directory to create
// an archive from a set of object files.
// typically it is run in the object directory.
func (cmdgo_gopherjsToolchain) pack(b *cmdgo_builder, p *cmdgo_Package, objDir, afile string, ofiles []string) error {

	return nil
}

// cc runs the toolchain's C compiler in a directory on a C file
// to produce an output file.
func (cmdgo_gopherjsToolchain) cc(b *cmdgo_builder, p *cmdgo_Package, objdir, ofile, cfile string) error {
	return fmt.Errorf("GopherJS does not support C source files")
}

var cmdgo_helpC = &cmdgo_Command{
	UsageLine: "c",
	Short:     "calling between Go and C",
	Long: `
There are two different ways to call between Go and C/C++ code.

The first is the cgo tool, which is part of the Go distribution.  For
information on how to use it see the cgo documentation (go doc cmd/cgo).

The second is the SWIG program, which is a general tool for
interfacing between languages.  For information on SWIG see
http://swig.org/.  When running go build, any file with a .swig
extension will be passed to SWIG.  Any file with a .swigcxx extension
will be passed to SWIG with the -c++ option.

When either cgo or SWIG is used, go build will pass any .c, .m, .s,
or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++
compiler.  The CC or CXX environment variables may be set to determine
the C or C++ compiler, respectively, to use.
	`,
}

var cmdgo_helpPackages = &cmdgo_Command{
	UsageLine: "packages",
	Short:     "description of package lists",
	Long: `
Many commands apply to a set of packages:

	go action [packages]

Usually, [packages] is a list of import paths.

An import path that is a rooted path or that begins with
a . or .. element is interpreted as a file system path and
denotes the package in that directory.

Otherwise, the import path P denotes the package found in
the directory DIR/src/P for some DIR listed in the GOPATH
environment variable (see 'go help gopath').

If no import paths are given, the action applies to the
package in the current directory.

There are four reserved names for paths that should not be used
for packages to be built with the go tool:

- "main" denotes the top-level package in a stand-alone executable.

- "all" expands to all package directories found in all the GOPATH
trees. For example, 'go list all' lists all the packages on the local
system.

- "std" is like all but expands to just the packages in the standard
Go library.

- "cmd" expands to the Go repository's commands and their
internal libraries.

An import path is a pattern if it includes one or more "..." wildcards,
each of which can match any string, including the empty string and
strings containing slashes.  Such a pattern expands to all package
directories found in the GOPATH trees with names matching the
patterns.  As a special case, x/... matches x as well as x's subdirectories.
For example, net/... expands to net and packages in its subdirectories.

An import path can also name a package to be downloaded from
a remote repository.  Run 'go help importpath' for details.

Every package in a program must have a unique import path.
By convention, this is arranged by starting each path with a
unique prefix that belongs to you.  For example, paths used
internally at Google all begin with 'google', and paths
denoting remote repositories begin with the path to the code,
such as 'github.com/user/repo'.

Packages in a program need not have unique package names,
but there are two reserved package names with special meaning.
The name main indicates a command, not a library.
Commands are built into binaries and cannot be imported.
The name documentation indicates documentation for
a non-Go program in the directory. Files in package documentation
are ignored by the go command.

As a special case, if the package list is a list of .go files from a
single directory, the command is applied to a single synthesized
package made up of exactly those files, ignoring any build constraints
in those files and ignoring any other files in the directory.

Directory and file names that begin with "." or "_" are ignored
by the go tool, as are directories named "testdata".
	`,
}

var cmdgo_helpImportPath = &cmdgo_Command{
	UsageLine: "importpath",
	Short:     "import path syntax",
	Long: `

An import path (see 'go help packages') denotes a package
stored in the local file system.  In general, an import path denotes
either a standard package (such as "unicode/utf8") or a package
found in one of the work spaces (see 'go help gopath').

Relative import paths

An import path beginning with ./ or ../ is called a relative path.
The toolchain supports relative import paths as a shortcut in two ways.

First, a relative path can be used as a shorthand on the command line.
If you are working in the directory containing the code imported as
"unicode" and want to run the tests for "unicode/utf8", you can type
"go test ./utf8" instead of needing to specify the full path.
Similarly, in the reverse situation, "go test .." will test "unicode" from
the "unicode/utf8" directory. Relative patterns are also allowed, like
"go test ./..." to test all subdirectories. See 'go help packages' for details
on the pattern syntax.

Second, if you are compiling a Go program not in a work space,
you can use a relative path in an import statement in that program
to refer to nearby code also not in a work space.
This makes it easy to experiment with small multipackage programs
outside of the usual work spaces, but such programs cannot be
installed with "go install" (there is no work space in which to install them),
so they are rebuilt from scratch each time they are built.
To avoid ambiguity, Go programs cannot use relative import paths
within a work space.

Remote import paths

Certain import paths also
describe how to obtain the source code for the package using
a revision control system.

A few common code hosting sites have special syntax:

	Bitbucket (Git, Mercurial)

		import "bitbucket.org/user/project"
		import "bitbucket.org/user/project/sub/directory"

	GitHub (Git)

		import "github.com/user/project"
		import "github.com/user/project/sub/directory"

	Launchpad (Bazaar)

		import "launchpad.net/project"
		import "launchpad.net/project/series"
		import "launchpad.net/project/series/sub/directory"

		import "launchpad.net/~user/project/branch"
		import "launchpad.net/~user/project/branch/sub/directory"

	IBM DevOps Services (Git)

		import "hub.jazz.net/git/user/project"
		import "hub.jazz.net/git/user/project/sub/directory"

For code hosted on other servers, import paths may either be qualified
with the version control type, or the go tool can dynamically fetch
the import path over https/http and discover where the code resides
from a <meta> tag in the HTML.

To declare the code location, an import path of the form

	repository.vcs/path

specifies the given repository, with or without the .vcs suffix,
using the named version control system, and then the path inside
that repository.  The supported version control systems are:

	Bazaar      .bzr
	Git         .git
	Mercurial   .hg
	Subversion  .svn

For example,

	import "example.org/user/foo.hg"

denotes the root directory of the Mercurial repository at
example.org/user/foo or foo.hg, and

	import "example.org/repo.git/foo/bar"

denotes the foo/bar directory of the Git repository at
example.org/repo or repo.git.

When a version control system supports multiple protocols,
each is tried in turn when downloading.  For example, a Git
download tries https://, then git+ssh://.

If the import path is not a known code hosting site and also lacks a
version control qualifier, the go tool attempts to fetch the import
over https/http and looks for a <meta> tag in the document's HTML
<head>.

The meta tag has the form:

	<meta name="go-import" content="import-prefix vcs repo-root">

The import-prefix is the import path corresponding to the repository
root. It must be a prefix or an exact match of the package being
fetched with "go get". If it's not an exact match, another http
request is made at the prefix to verify the <meta> tags match.

The meta tag should appear as early in the file as possible.
In particular, it should appear before any raw JavaScript or CSS,
to avoid confusing the go command's restricted parser.

The vcs is one of "git", "hg", "svn", etc,

The repo-root is the root of the version control system
containing a scheme and not containing a .vcs qualifier.

For example,

	import "example.org/pkg/foo"

will result in the following requests:

	https://example.org/pkg/foo?go-get=1 (preferred)
	http://example.org/pkg/foo?go-get=1  (fallback, only with -insecure)

If that page contains the meta tag

	<meta name="go-import" content="example.org git https://code.org/r/p/exproj">

the go tool will verify that https://example.org/?go-get=1 contains the
same meta tag and then git clone https://code.org/r/p/exproj into
GOPATH/src/example.org.

New downloaded packages are written to the first directory
listed in the GOPATH environment variable (see 'go help gopath').

The go command attempts to download the version of the
package appropriate for the Go release being used.
Run 'go help get' for more.

Import path checking

When the custom import path feature described above redirects to a
known code hosting site, each of the resulting packages has two possible
import paths, using the custom domain or the known hosting site.

A package statement is said to have an "import comment" if it is immediately
followed (before the next newline) by a comment of one of these two forms:

	package math // import "path"
	package math /* import "path" */

The go command will refuse to install a package with an import comment
unless it is being referred to by that import path. In this way, import comments
let package authors make sure the custom import path is used and not a
direct path to the underlying code hosting site.

Import path checking is disabled for code found within vendor trees.
This makes it possible to copy code into alternate locations in vendor trees
without needing to update import comments.

See https://golang.org/s/go14customimport for details.
	`,
}

var cmdgo_helpGopath = &cmdgo_Command{
	UsageLine: "gopath",
	Short:     "GOPATH environment variable",
	Long: `
The Go path is used to resolve import statements.
It is implemented by and documented in the go/build package.

The GOPATH environment variable lists places to look for Go code.
On Unix, the value is a colon-separated string.
On Windows, the value is a semicolon-separated string.
On Plan 9, the value is a list.

GOPATH must be set to get, build and install packages outside the
standard Go tree.

Each directory listed in GOPATH must have a prescribed structure:

The src directory holds source code.  The path below src
determines the import path or executable name.

The pkg directory holds installed package objects.
As in the Go tree, each target operating system and
architecture pair has its own subdirectory of pkg
(pkg/GOOS_GOARCH).

If DIR is a directory listed in the GOPATH, a package with
source in DIR/src/foo/bar can be imported as "foo/bar" and
has its compiled form installed to "DIR/pkg/GOOS_GOARCH/foo/bar.a".

The bin directory holds compiled commands.
Each command is named for its source directory, but only
the final element, not the entire path.  That is, the
command with source in DIR/src/foo/quux is installed into
DIR/bin/quux, not DIR/bin/foo/quux.  The "foo/" prefix is stripped
so that you can add DIR/bin to your PATH to get at the
installed commands.  If the GOBIN environment variable is
set, commands are installed to the directory it names instead
of DIR/bin. GOBIN must be an absolute path.

Here's an example directory layout:

    GOPATH=/home/user/gocode

    /home/user/gocode/
        src/
            foo/
                bar/               (go code in package bar)
                    x.go
                quux/              (go code in package main)
                    y.go
        bin/
            quux                   (installed command)
        pkg/
            linux_amd64/
                foo/
                    bar.a          (installed package object)

Go searches each directory listed in GOPATH to find source code,
but new packages are always downloaded into the first directory
in the list.

See https://golang.org/doc/code.html for an example.

Internal Directories

Code in or below a directory named "internal" is importable only
by code in the directory tree rooted at the parent of "internal".
Here's an extended version of the directory layout above:

    /home/user/gocode/
        src/
            crash/
                bang/              (go code in package bang)
                    b.go
            foo/                   (go code in package foo)
                f.go
                bar/               (go code in package bar)
                    x.go
                internal/
                    baz/           (go code in package baz)
                        z.go
                quux/              (go code in package main)
                    y.go


The code in z.go is imported as "foo/internal/baz", but that
import statement can only appear in source files in the subtree
rooted at foo. The source files foo/f.go, foo/bar/x.go, and
foo/quux/y.go can all import "foo/internal/baz", but the source file
crash/bang/b.go cannot.

See https://golang.org/s/go14internal for details.

Vendor Directories

Go 1.6 includes support for using local copies of external dependencies
to satisfy imports of those dependencies, often referred to as vendoring.

Code below a directory named "vendor" is importable only
by code in the directory tree rooted at the parent of "vendor",
and only using an import path that omits the prefix up to and
including the vendor element.

Here's the example from the previous section,
but with the "internal" directory renamed to "vendor"
and a new foo/vendor/crash/bang directory added:

    /home/user/gocode/
        src/
            crash/
                bang/              (go code in package bang)
                    b.go
            foo/                   (go code in package foo)
                f.go
                bar/               (go code in package bar)
                    x.go
                vendor/
                    crash/
                        bang/      (go code in package bang)
                            b.go
                    baz/           (go code in package baz)
                        z.go
                quux/              (go code in package main)
                    y.go

The same visibility rules apply as for internal, but the code
in z.go is imported as "baz", not as "foo/vendor/baz".

Code in vendor directories deeper in the source tree shadows
code in higher directories. Within the subtree rooted at foo, an import
of "crash/bang" resolves to "foo/vendor/crash/bang", not the
top-level "crash/bang".

Code in vendor directories is not subject to import path
checking (see 'go help importpath').

When 'go get' checks out or updates a git repository, it now also
updates submodules.

Vendor directories do not affect the placement of new repositories
being checked out for the first time by 'go get': those are always
placed in the main GOPATH, never in a vendor subtree.

See https://golang.org/s/go15vendor for details.
	`,
}

var cmdgo_helpEnvironment = &cmdgo_Command{
	UsageLine: "environment",
	Short:     "environment variables",
	Long: `

The go command, and the tools it invokes, examine a few different
environment variables. For many of these, you can see the default
value of on your system by running 'go env NAME', where NAME is the
name of the variable.

General-purpose environment variables:

	GCCGO
		The gccgo command to run for 'go build -compiler=gccgo'.
	GOARCH
		The architecture, or processor, for which to compile code.
		Examples are amd64, 386, arm, ppc64.
	GOBIN
		The directory where 'go install' will install a command.
	GOOS
		The operating system for which to compile code.
		Examples are linux, darwin, windows, netbsd.
	GOPATH
		See 'go help gopath'.
	GORACE
		Options for the race detector.
		See https://golang.org/doc/articles/race_detector.html.
	GOROOT
		The root of the go tree.

Environment variables for use with cgo:

	CC
		The command to use to compile C code.
	CGO_ENABLED
		Whether the cgo command is supported.  Either 0 or 1.
	CGO_CFLAGS
		Flags that cgo will pass to the compiler when compiling
		C code.
	CGO_CPPFLAGS
		Flags that cgo will pass to the compiler when compiling
		C or C++ code.
	CGO_CXXFLAGS
		Flags that cgo will pass to the compiler when compiling
		C++ code.
	CGO_LDFLAGS
		Flags that cgo will pass to the compiler when linking.
	CXX
		The command to use to compile C++ code.

Architecture-specific environment variables:

	GOARM
		For GOARCH=arm, the ARM architecture for which to compile.
		Valid values are 5, 6, 7.
	GO386
		For GOARCH=386, the floating point instruction set.
		Valid values are 387, sse2.

Special-purpose environment variables:

	GOROOT_FINAL
		The root of the installed Go tree, when it is
		installed in a location other than where it is built.
		File names in stack traces are rewritten from GOROOT to
		GOROOT_FINAL.
	GO_EXTLINK_ENABLED
		Whether the linker should use external linking mode
		when using -linkmode=auto with code that uses cgo.
		Set to 0 to disable external linking mode, 1 to enable it.
	`,
}

var cmdgo_helpFileType = &cmdgo_Command{
	UsageLine: "filetype",
	Short:     "file types",
	Long: `
The go command examines the contents of a restricted set of files
in each directory. It identifies which files to examine based on
the extension of the file name. These extensions are:

	.go
		Go source files.
	.c, .h
		C source files.
		If the package uses cgo or SWIG, these will be compiled with the
		OS-native compiler (typically gcc); otherwise they will
		trigger an error.
	.cc, .cpp, .cxx, .hh, .hpp, .hxx
		C++ source files. Only useful with cgo or SWIG, and always
		compiled with the OS-native compiler.
	.m
		Objective-C source files. Only useful with cgo, and always
		compiled with the OS-native compiler.
	.s, .S
		Assembler source files.
		If the package uses cgo or SWIG, these will be assembled with the
		OS-native assembler (typically gcc (sic)); otherwise they
		will be assembled with the Go assembler.
	.swig, .swigcxx
		SWIG definition files.
	.syso
		System object files.
	.inc.js
		JavaScript source files.
		Automatically included when building the package.

Files of each of these types except .syso may contain build
constraints, but the go command stops scanning for build constraints
at the first item in the file that is not a blank line or //-style
line comment. See the go/build package documentation for
more details.

Non-test Go source files can also include a //go:binary-only-package
comment, indicating that the package sources are included
for documentation only and must not be used to build the
package binary. This enables distribution of Go packages in
their compiled form alone. See the go/build package documentation
for more details.
	`,
}

var cmdgo_helpBuildmode = &cmdgo_Command{
	UsageLine: "buildmode",
	Short:     "description of build modes",
	Long: `
The 'go build' and 'go install' commands take a -buildmode argument which
indicates which kind of object file is to be built. Currently supported values
are:

	-buildmode=archive
		Build the listed non-main packages into .a files. Packages named
		main are ignored.

	-buildmode=c-archive
		Build the listed main package, plus all packages it imports,
		into a C archive file. The only callable symbols will be those
		functions exported using a cgo //export comment. Requires
		exactly one main package to be listed.

	-buildmode=c-shared
		Build the listed main packages, plus all packages that they
		import, into C shared libraries. The only callable symbols will
		be those functions exported using a cgo //export comment.
		Non-main packages are ignored.

	-buildmode=default
		Listed main packages are built into executables and listed
		non-main packages are built into .a files (the default
		behavior).

	-buildmode=shared
		Combine all the listed non-main packages into a single shared
		library that will be used when building with the -linkshared
		option. Packages named main are ignored.

	-buildmode=exe
		Build the listed main packages and everything they import into
		executables. Packages not named main are ignored.

	-buildmode=pie
		Build the listed main packages and everything they import into
		position independent executables (PIE). Packages not named
		main are ignored.
`,
}

// httpClient is the default HTTP client, but a variable so it can be
// changed by tests, without modifying http.DefaultClient.
var cmdgo_httpClient = http.DefaultClient

// impatientInsecureHTTPClient is used in -insecure mode,
// when we're connecting to https servers that might not be there
// or might be using self-signed certificates.
var cmdgo_impatientInsecureHTTPClient = &http.Client{
	Timeout: 5 * time.Second,
	Transport: &http.Transport{
		TLSClientConfig: &tls.Config{
			InsecureSkipVerify: true,
		},
	},
}

type cmdgo_httpError struct {
	status     string
	statusCode int
	url        string
}

func (e *cmdgo_httpError) Error() string {
	return fmt.Sprintf("%s: %s", e.url, e.status)
}

// httpGET returns the data from an HTTP GET request for the given URL.
func cmdgo_httpGET(url string) ([]byte, error) {
	resp, err := cmdgo_httpClient.Get(url)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != 200 {
		err := &cmdgo_httpError{status: resp.Status, statusCode: resp.StatusCode, url: url}

		return nil, err
	}
	b, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("%s: %v", url, err)
	}
	return b, nil
}

// httpsOrHTTP returns the body of either the importPath's
// https resource or, if unavailable, the http resource.
func cmdgo_httpsOrHTTP(importPath string, security cmdgo_securityMode) (urlStr string, body io.ReadCloser, err error) {
	fetch := func(scheme string) (urlStr string, res *http.Response, err error) {
		u, err := url.Parse(scheme + "://" + importPath)
		if err != nil {
			return "", nil, err
		}
		u.RawQuery = "go-get=1"
		urlStr = u.String()
		if cmdgo_buildV {
			log.Printf("Fetching %s", urlStr)
		}
		if security == cmdgo_insecure && scheme == "https" {
			res, err = cmdgo_impatientInsecureHTTPClient.Get(urlStr)
		} else {
			res, err = cmdgo_httpClient.Get(urlStr)
		}
		return
	}
	closeBody := func(res *http.Response) {
		if res != nil {
			res.Body.Close()
		}
	}
	urlStr, res, err := fetch("https")
	if err != nil {
		if cmdgo_buildV {
			log.Printf("https fetch failed: %v", err)
		}
		if security == cmdgo_insecure {
			closeBody(res)
			urlStr, res, err = fetch("http")
		}
	}
	if err != nil {
		closeBody(res)
		return "", nil, err
	}

	if cmdgo_buildV {
		log.Printf("Parsing meta tags from %s (status code %d)", urlStr, res.StatusCode)
	}
	return urlStr, res.Body, nil
}

var cmdgo_cmdList = &cmdgo_Command{
	UsageLine: "list [-e] [-f format] [-json] [build flags] [packages]",
	Short:     "list packages",
	Long: `
List lists the packages named by the import paths, one per line.

The default output shows the package import path:

    bytes
    encoding/json
    github.com/gorilla/mux
    golang.org/x/net/html

The -f flag specifies an alternate format for the list, using the
syntax of package template.  The default output is equivalent to -f
'{{.ImportPath}}'. The struct being passed to the template is:

    type Package struct {
        Dir           string // directory containing package sources
        ImportPath    string // import path of package in dir
        ImportComment string // path in import comment on package statement
        Name          string // package name
        Doc           string // package documentation string
        Target        string // install path
        Shlib         string // the shared library that contains this package (only set when -linkshared)
        Goroot        bool   // is this package in the Go root?
        Standard      bool   // is this package part of the standard Go library?
        Stale         bool   // would 'go install' do anything for this package?
        StaleReason   string // explanation for Stale==true
        Root          string // Go root or Go path dir containing this package
        ConflictDir   string // this directory shadows Dir in $GOPATH
        BinaryOnly    bool   // binary-only package: cannot be recompiled from sources

        // Source files
        GoFiles        []string // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
        CgoFiles       []string // .go sources files that import "C"
        IgnoredGoFiles []string // .go sources ignored due to build constraints
        CFiles         []string // .c source files
        CXXFiles       []string // .cc, .cxx and .cpp source files
        MFiles         []string // .m source files
        HFiles         []string // .h, .hh, .hpp and .hxx source files
        FFiles         []string // .f, .F, .for and .f90 Fortran source files
        SFiles         []string // .s source files
        SwigFiles      []string // .swig files
        SwigCXXFiles   []string // .swigcxx files
        SysoFiles      []string // .syso object files to add to archive

        // Cgo directives
        CgoCFLAGS    []string // cgo: flags for C compiler
        CgoCPPFLAGS  []string // cgo: flags for C preprocessor
        CgoCXXFLAGS  []string // cgo: flags for C++ compiler
        CgoFFLAGS    []string // cgo: flags for Fortran compiler
        CgoLDFLAGS   []string // cgo: flags for linker
        CgoPkgConfig []string // cgo: pkg-config names

        // Dependency information
        Imports []string // import paths used by this package
        Deps    []string // all (recursively) imported dependencies

        // Error information
        Incomplete bool            // this package or a dependency has an error
        Error      *PackageError   // error loading package
        DepsErrors []*PackageError // errors loading dependencies

        TestGoFiles  []string // _test.go files in package
        TestImports  []string // imports from TestGoFiles
        XTestGoFiles []string // _test.go files outside package
        XTestImports []string // imports from XTestGoFiles
    }

The error information, if any, is

    type PackageError struct {
        ImportStack   []string // shortest path from package named on command line to this one
        Pos           string   // position of error (if present, file:line:col)
        Err           string   // the error itself
    }

The template function "join" calls strings.Join.

The template function "context" returns the build context, defined as:

	type Context struct {
		GOARCH        string   // target architecture
		GOOS          string   // target operating system
		GOROOT        string   // Go root
		GOPATH        string   // Go path
		CgoEnabled    bool     // whether cgo can be used
		UseAllFiles   bool     // use files regardless of +build lines, file names
		Compiler      string   // compiler to assume when computing target paths
		BuildTags     []string // build constraints to match in +build lines
		ReleaseTags   []string // releases the current release is compatible with
		InstallSuffix string   // suffix to use in the name of the install dir
	}

For more information about the meaning of these fields see the documentation
for the go/build package's Context type.

The -json flag causes the package data to be printed in JSON format
instead of using the template format.

The -e flag changes the handling of erroneous packages, those that
cannot be found or are malformed.  By default, the list command
prints an error to standard error for each erroneous package and
omits the packages from consideration during the usual printing.
With the -e flag, the list command never prints errors to standard
error and instead processes the erroneous packages with the usual
printing.  Erroneous packages will have a non-empty ImportPath and
a non-nil Error field; other information may or may not be missing
(zeroed).

For more about build flags, see 'go help build'.

For more about specifying packages, see 'go help packages'.
	`,
}

func init() {
	cmdgo_cmdList.Run = cmdgo_runList
	cmdgo_addBuildFlags(cmdgo_cmdList)
}

var cmdgo_listE = cmdgo_cmdList.Flag.Bool("e", false, "")

var cmdgo_listFmt = cmdgo_cmdList.Flag.String("f", "{{.ImportPath}}", "")

var cmdgo_listJson = cmdgo_cmdList.Flag.Bool("json", false, "")

var cmdgo_nl = []byte{'\n'}

func cmdgo_runList(cmd *cmdgo_Command, args []string) {
	cmdgo_buildModeInit()
	out := cmdgo_newTrackingWriter(os.Stdout)
	defer out.w.Flush()

	var do func(*cmdgo_Package)
	if *cmdgo_listJson {
		do = func(p *cmdgo_Package) {
			b, err := json.MarshalIndent(p, "", "\t")
			if err != nil {
				out.Flush()
				cmdgo_fatalf("%s", err)
			}
			out.Write(b)
			out.Write(cmdgo_nl)
		}
	} else {
		var cachedCtxt *cmdgo_Context
		context := func() *cmdgo_Context {
			if cachedCtxt == nil {
				cachedCtxt = cmdgo_newContext(&cmdgo_buildContext)
			}
			return cachedCtxt
		}
		fm := template.FuncMap{
			"join":    strings.Join,
			"context": context,
		}
		tmpl, err := template.New("main").Funcs(fm).Parse(*cmdgo_listFmt)
		if err != nil {
			cmdgo_fatalf("%s", err)
		}
		do = func(p *cmdgo_Package) {
			if err := tmpl.Execute(out, p); err != nil {
				out.Flush()
				cmdgo_fatalf("%s", err)
			}
			if out.NeedNL() {
				out.Write(cmdgo_nl)
			}
		}
	}

	load := cmdgo_packages
	if *cmdgo_listE {
		load = cmdgo_packagesAndErrors
	}

	for _, pkg := range load(args) {

		pkg.TestImports = pkg.vendored(pkg.TestImports)
		pkg.XTestImports = pkg.vendored(pkg.XTestImports)

		do(pkg)
	}
}

// TrackingWriter tracks the last byte written on every write so
// we can avoid printing a newline if one was already written or
// if there is no output at all.
type cmdgo_TrackingWriter struct {
	w    *bufio.Writer
	last byte
}

func cmdgo_newTrackingWriter(w io.Writer) *cmdgo_TrackingWriter {
	return &cmdgo_TrackingWriter{
		w:    bufio.NewWriter(w),
		last: '\n',
	}
}

func (t *cmdgo_TrackingWriter) Write(p []byte) (n int, err error) {
	n, err = t.w.Write(p)
	if n > 0 {
		t.last = p[n-1]
	}
	return
}

func (t *cmdgo_TrackingWriter) Flush() {
	t.w.Flush()
}

func (t *cmdgo_TrackingWriter) NeedNL() bool {
	return t.last != '\n'
}

// A Command is an implementation of a go command
// like go build or go fix.
type cmdgo_Command struct {
	// Run runs the command.
	// The args are the arguments after the command name.
	Run func(cmd *cmdgo_Command, args []string)

	// UsageLine is the one-line usage message.
	// The first word in the line is taken to be the command name.
	UsageLine string

	// Short is the short description shown in the 'go help' output.
	Short string

	// Long is the long message shown in the 'go help <this-command>' output.
	Long string

	// Flag is a set of flags specific to this command.
	Flag flag.FlagSet

	// CustomFlags indicates that the command will do its own
	// flag parsing.
	CustomFlags bool
}

// Name returns the command's name: the first word in the usage line.
func (c *cmdgo_Command) Name() string {
	name := c.UsageLine
	i := strings.Index(name, " ")
	if i >= 0 {
		name = name[:i]
	}
	return name
}

func (c *cmdgo_Command) Usage() {
	fmt.Fprintf(os.Stderr, "usage: %s\n\n", c.UsageLine)
	fmt.Fprintf(os.Stderr, "%s\n", strings.TrimSpace(c.Long))
	os.Exit(2)
}

// Runnable reports whether the command can be run; otherwise
// it is a documentation pseudo-command such as importpath.
func (c *cmdgo_Command) Runnable() bool {
	return c.Run != nil
}

// Commands lists the available commands and help topics.
// The order here is the order in which they are printed by 'go help'.
var cmdgo_commands = []*cmdgo_Command{
	cmdgo_cmdBuild,
	cmdgo_cmdClean,
	cmdgo_cmdDoc,
	cmdgo_cmdEnv,
	cmdgo_cmdFix,
	cmdgo_cmdFmt,
	cmdgo_cmdGenerate,
	cmdgo_cmdGet,
	cmdgo_cmdInstall,
	cmdgo_cmdList,
	cmdgo_cmdRun,
	cmdgo_cmdTest,
	cmdgo_cmdTool,
	cmdgo_cmdVersion,
	cmdgo_cmdVet,

	cmdgo_helpC,
	cmdgo_helpBuildmode,
	cmdgo_helpFileType,
	cmdgo_helpGopath,
	cmdgo_helpEnvironment,
	cmdgo_helpImportPath,
	cmdgo_helpPackages,
	cmdgo_helpTestflag,
	cmdgo_helpTestfunc,
}

var cmdgo_exitStatus = 0

var cmdgo_exitMu sync.Mutex

func cmdgo_setExitStatus(n int) {
	cmdgo_exitMu.Lock()
	if cmdgo_exitStatus < n {
		cmdgo_exitStatus = n
	}
	cmdgo_exitMu.Unlock()
}

var cmdgo_origEnv []string

func cmdgo_main() {
	_ = cmdgo_go11tag
	flag.Usage = cmdgo_usage
	flag.Parse()
	log.SetFlags(0)

	args := flag.Args()
	if len(args) < 1 {
		cmdgo_usage()
	}

	if args[0] == "help" {
		cmdgo_help(args[1:])
		return
	}

	if gopath := os.Getenv("GOPATH"); gopath == runtime.GOROOT() {
		fmt.Fprintf(os.Stderr, "warning: GOPATH set to GOROOT (%s) has no effect\n", gopath)
	} else {
		for _, p := range filepath.SplitList(gopath) {

			if strings.HasPrefix(p, "~") {
				fmt.Fprintf(os.Stderr, "go: GOPATH entry cannot start with shell metacharacter '~': %q\n", p)
				os.Exit(2)
			}
			if !filepath.IsAbs(p) {
				fmt.Fprintf(os.Stderr, "go: GOPATH entry is relative; must be absolute path: %q.\nRun 'go help gopath' for usage.\n", p)
				os.Exit(2)
			}
		}
	}

	if fi, err := os.Stat(cmdgo_goroot); err != nil || !fi.IsDir() {
		fmt.Fprintf(os.Stderr, "go: cannot find GOROOT directory: %v\n", cmdgo_goroot)
		os.Exit(2)
	}

	cmdgo_origEnv = os.Environ()
	for _, env := range cmdgo_mkEnv() {
		if os.Getenv(env.name) != env.value {
			os.Setenv(env.name, env.value)
		}
	}

	for _, cmd := range cmdgo_commands {
		if cmd.Name() == args[0] && cmd.Runnable() {
			cmd.Flag.Usage = func() { cmd.Usage() }
			if cmd.CustomFlags {
				args = args[1:]
			} else {
				cmd.Flag.Parse(args[1:])
				args = cmd.Flag.Args()
			}
			cmd.Run(cmd, args)
			cmdgo_exit()
			return
		}
	}

	fmt.Fprintf(os.Stderr, "go: unknown subcommand %q\nRun 'go help' for usage.\n", args[0])
	cmdgo_setExitStatus(2)
	cmdgo_exit()
}

var cmdgo_usageTemplate = `Go is a tool for managing Go source code.

Usage:

	go command [arguments]

The commands are:
{{range .}}{{if .Runnable}}
	{{.Name | printf "%-11s"}} {{.Short}}{{end}}{{end}}

Use "go help [command]" for more information about a command.

Additional help topics:
{{range .}}{{if not .Runnable}}
	{{.Name | printf "%-11s"}} {{.Short}}{{end}}{{end}}

Use "go help [topic]" for more information about that topic.

`

var cmdgo_helpTemplate = `{{if .Runnable}}usage: go {{.UsageLine}}

{{end}}{{.Long | trim}}
`

var cmdgo_documentationTemplate = `{{range .}}{{if .Short}}{{.Short | capitalize}}

{{end}}{{if .Runnable}}Usage:

	go {{.UsageLine}}

{{end}}{{.Long | trim}}


{{end}}`

// commentWriter writes a Go comment to the underlying io.Writer,
// using line comment form (//).
type cmdgo_commentWriter struct {
	W            io.Writer
	wroteSlashes bool // Wrote "//" at the beginning of the current line.
}

func (c *cmdgo_commentWriter) Write(p []byte) (int, error) {
	var n int
	for i, b := range p {
		if !c.wroteSlashes {
			s := "//"
			if b != '\n' {
				s = "// "
			}
			if _, err := io.WriteString(c.W, s); err != nil {
				return n, err
			}
			c.wroteSlashes = true
		}
		n0, err := c.W.Write(p[i : i+1])
		n += n0
		if err != nil {
			return n, err
		}
		if b == '\n' {
			c.wroteSlashes = false
		}
	}
	return len(p), nil
}

// An errWriter wraps a writer, recording whether a write error occurred.
type cmdgo_errWriter struct {
	w   io.Writer
	err error
}

func (w *cmdgo_errWriter) Write(b []byte) (int, error) {
	n, err := w.w.Write(b)
	if err != nil {
		w.err = err
	}
	return n, err
}

// tmpl executes the given template text on data, writing the result to w.
func cmdgo_tmpl(w io.Writer, text string, data interface{}) {
	t := template.New("top")
	t.Funcs(template.FuncMap{"trim": strings.TrimSpace, "capitalize": cmdgo_capitalize})
	template.Must(t.Parse(text))
	ew := &cmdgo_errWriter{w: w}
	err := t.Execute(ew, data)
	if ew.err != nil {

		if strings.Contains(ew.err.Error(), "pipe") {
			os.Exit(1)
		}
		cmdgo_fatalf("writing output: %v", ew.err)
	}
	if err != nil {
		panic(err)
	}
}

func cmdgo_capitalize(s string) string {
	if s == "" {
		return s
	}
	r, n := utf8.DecodeRuneInString(s)
	return string(unicode.ToTitle(r)) + s[n:]
}

func cmdgo_printUsage(w io.Writer) {
	bw := bufio.NewWriter(w)
	cmdgo_tmpl(bw, cmdgo_usageTemplate, cmdgo_commands)
	bw.Flush()
}

func cmdgo_usage() {

	if len(os.Args) > 1 && os.Args[1] == "test" {
		os.Stderr.WriteString(cmdgo_testUsage + "\n\n" +
			strings.TrimSpace(cmdgo_testFlag1) + "\n\n\t" +
			strings.TrimSpace(cmdgo_testFlag2) + "\n")
		os.Exit(2)
	}
	cmdgo_printUsage(os.Stderr)
	os.Exit(2)
}

// help implements the 'help' command.
func cmdgo_help(args []string) {
	if len(args) == 0 {
		cmdgo_printUsage(os.Stdout)

		return
	}
	if len(args) != 1 {
		fmt.Fprintf(os.Stderr, "usage: go help command\n\nToo many arguments given.\n")
		os.Exit(2)
	}

	arg := args[0]

	if arg == "documentation" {
		fmt.Println("// Copyright 2011 The Go Authors. All rights reserved.")
		fmt.Println("// Use of this source code is governed by a BSD-style")
		fmt.Println("// license that can be found in the LICENSE file.")
		fmt.Println()
		fmt.Println("// DO NOT EDIT THIS FILE. GENERATED BY mkalldocs.sh.")
		fmt.Println("// Edit the documentation in other files and rerun mkalldocs.sh to generate this one.")
		fmt.Println()
		buf := new(bytes.Buffer)
		cmdgo_printUsage(buf)
		usage := &cmdgo_Command{Long: buf.String()}
		cmdgo_tmpl(&cmdgo_commentWriter{W: os.Stdout}, cmdgo_documentationTemplate, append([]*cmdgo_Command{usage}, cmdgo_commands...))
		fmt.Println("package main")
		return
	}

	for _, cmd := range cmdgo_commands {
		if cmd.Name() == arg {
			cmdgo_tmpl(os.Stdout, cmdgo_helpTemplate, cmd)

			return
		}
	}

	fmt.Fprintf(os.Stderr, "Unknown help topic %#q.  Run 'go help'.\n", arg)
	os.Exit(2)
}

// importPathsNoDotExpansion returns the import paths to use for the given
// command line, but it does no ... expansion.
func cmdgo_importPathsNoDotExpansion(args []string) []string {
	if len(args) == 0 {
		return []string{"."}
	}
	var out []string
	for _, a := range args {

		if filepath.Separator == '\\' {
			a = strings.Replace(a, `\`, `/`, -1)
		}

		if strings.HasPrefix(a, "./") {
			a = "./" + path.Clean(a)
			if a == "./." {
				a = "."
			}
		} else {
			a = path.Clean(a)
		}
		if cmdgo_isMetaPackage(a) {
			out = append(out, cmdgo_allPackages(a)...)
			continue
		}
		out = append(out, a)
	}
	return out
}

// importPaths returns the import paths to use for the given command line.
func cmdgo_importPaths(args []string) []string {
	args = cmdgo_importPathsNoDotExpansion(args)
	var out []string
	for _, a := range args {
		if strings.Contains(a, "...") {
			if build.IsLocalImport(a) {
				out = append(out, cmdgo_allPackagesInFS(a)...)
			} else {
				out = append(out, cmdgo_allPackages(a)...)
			}
			continue
		}
		out = append(out, a)
	}
	return out
}

var cmdgo_atexitFuncs []func()

func cmdgo_atexit(f func()) {
	cmdgo_atexitFuncs = append(cmdgo_atexitFuncs, f)
}

func cmdgo_exit() {
	for _, f := range cmdgo_atexitFuncs {
		f()
	}
	os.Exit(cmdgo_exitStatus)
}

func cmdgo_fatalf(format string, args ...interface{}) {
	cmdgo_errorf(format, args...)
	cmdgo_exit()
}

func cmdgo_errorf(format string, args ...interface{}) {
	log.Printf(format, args...)
	cmdgo_setExitStatus(1)
}

func cmdgo_exitIfErrors() {
	if cmdgo_exitStatus != 0 {
		cmdgo_exit()
	}
}

func cmdgo_run(cmdargs ...interface{}) {
	cmdline := cmdgo_stringList(cmdargs...)
	if cmdgo_buildN || cmdgo_buildX {
		fmt.Printf("%s\n", strings.Join(cmdline, " "))
		if cmdgo_buildN {
			return
		}
	}

	cmd := exec.Command(cmdline[0], cmdline[1:]...)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	if err := cmd.Run(); err != nil {
		cmdgo_errorf("%v", err)
	}
}

// envForDir returns a copy of the environment
// suitable for running in the given directory.
// The environment is the current process's environment
// but with an updated $PWD, so that an os.Getwd in the
// child will be faster.
func cmdgo_envForDir(dir string, base []string) []string {

	return cmdgo_mergeEnvLists([]string{"PWD=" + dir}, base)
}

// mergeEnvLists merges the two environment lists such that
// variables with the same name in "in" replace those in "out".
// This always returns a newly allocated slice.
func cmdgo_mergeEnvLists(in, out []string) []string {
	out = append([]string(nil), out...)
NextVar:
	for _, inkv := range in {
		k := strings.SplitAfterN(inkv, "=", 2)[0]
		for i, outkv := range out {
			if strings.HasPrefix(outkv, k) {
				out[i] = inkv
				continue NextVar
			}
		}
		out = append(out, inkv)
	}
	return out
}

// matchPattern(pattern)(name) reports whether
// name matches pattern. Pattern is a limited glob
// pattern in which '...' means 'any string' and there
// is no other special syntax.
func cmdgo_matchPattern(pattern string) func(name string) bool {
	re := regexp.QuoteMeta(pattern)
	re = strings.Replace(re, `\.\.\.`, `.*`, -1)

	if strings.HasSuffix(re, `/.*`) {
		re = re[:len(re)-len(`/.*`)] + `(/.*)?`
	}
	reg := regexp.MustCompile(`^` + re + `$`)
	return func(name string) bool {
		return reg.MatchString(name)
	}
}

// hasPathPrefix reports whether the path s begins with the
// elements in prefix.
func cmdgo_hasPathPrefix(s, prefix string) bool {
	switch {
	default:
		return false
	case len(s) == len(prefix):
		return s == prefix
	case len(s) > len(prefix):
		if prefix != "" && prefix[len(prefix)-1] == '/' {
			return strings.HasPrefix(s, prefix)
		}
		return s[len(prefix)] == '/' && s[:len(prefix)] == prefix
	}
}

// hasFilePathPrefix reports whether the filesystem path s begins with the
// elements in prefix.
func cmdgo_hasFilePathPrefix(s, prefix string) bool {
	sv := strings.ToUpper(filepath.VolumeName(s))
	pv := strings.ToUpper(filepath.VolumeName(prefix))
	s = s[len(sv):]
	prefix = prefix[len(pv):]
	switch {
	default:
		return false
	case sv != pv:
		return false
	case len(s) == len(prefix):
		return s == prefix
	case len(s) > len(prefix):
		if prefix != "" && prefix[len(prefix)-1] == filepath.Separator {
			return strings.HasPrefix(s, prefix)
		}
		return s[len(prefix)] == filepath.Separator && s[:len(prefix)] == prefix
	}
}

// expandPath returns the symlink-expanded form of path.
func cmdgo_expandPath(p string) string {
	x, err := filepath.EvalSymlinks(p)
	if err == nil {
		return x
	}
	return p
}

// treeCanMatchPattern(pattern)(name) reports whether
// name or children of name can possibly match pattern.
// Pattern is the same limited glob accepted by matchPattern.
func cmdgo_treeCanMatchPattern(pattern string) func(name string) bool {
	wildCard := false
	if i := strings.Index(pattern, "..."); i >= 0 {
		wildCard = true
		pattern = pattern[:i]
	}
	return func(name string) bool {
		return len(name) <= len(pattern) && cmdgo_hasPathPrefix(pattern, name) ||
			wildCard && strings.HasPrefix(name, pattern)
	}
}

// allPackages returns all the packages that can be found
// under the $GOPATH directories and $GOROOT matching pattern.
// The pattern is either "all" (all packages), "std" (standard packages),
// "cmd" (standard commands), or a path including "...".
func cmdgo_allPackages(pattern string) []string {
	pkgs := cmdgo_matchPackages(pattern)
	if len(pkgs) == 0 {
		fmt.Fprintf(os.Stderr, "warning: %q matched no packages\n", pattern)
	}
	return pkgs
}

func cmdgo_matchPackages(pattern string) []string {
	match := func(string) bool { return true }
	treeCanMatch := func(string) bool { return true }
	if !cmdgo_isMetaPackage(pattern) {
		match = cmdgo_matchPattern(pattern)
		treeCanMatch = cmdgo_treeCanMatchPattern(pattern)
	}

	have := map[string]bool{
		"builtin": true,
	}
	if !cmdgo_buildContext.CgoEnabled {
		have["runtime/cgo"] = true
	}
	var pkgs []string

	for _, src := range cmdgo_buildContext.SrcDirs() {
		if (pattern == "std" || pattern == "cmd") && src != cmdgo_gorootSrc {
			continue
		}
		src = filepath.Clean(src) + string(filepath.Separator)
		root := src
		if pattern == "cmd" {
			root += "cmd" + string(filepath.Separator)
		}
		filepath.Walk(root, func(path string, fi os.FileInfo, err error) error {
			if err != nil || !fi.IsDir() || path == src {
				return nil
			}

			_, elem := filepath.Split(path)
			if strings.HasPrefix(elem, ".") || strings.HasPrefix(elem, "_") || elem == "testdata" {
				return filepath.SkipDir
			}

			name := filepath.ToSlash(path[len(src):])
			if pattern == "std" && (!cmdgo_isStandardImportPath(name) || name == "cmd") {

				return filepath.SkipDir
			}
			if !treeCanMatch(name) {
				return filepath.SkipDir
			}
			if have[name] {
				return nil
			}
			have[name] = true
			if !match(name) {
				return nil
			}
			_, err = cmdgo_buildContext.ImportDir(path, 0)
			if err != nil {
				if _, noGo := err.(*build.NoGoError); noGo {
					return nil
				}
			}
			pkgs = append(pkgs, name)
			return nil
		})
	}
	return pkgs
}

// allPackagesInFS is like allPackages but is passed a pattern
// beginning ./ or ../, meaning it should scan the tree rooted
// at the given directory. There are ... in the pattern too.
func cmdgo_allPackagesInFS(pattern string) []string {
	pkgs := cmdgo_matchPackagesInFS(pattern)
	if len(pkgs) == 0 {
		fmt.Fprintf(os.Stderr, "warning: %q matched no packages\n", pattern)
	}
	return pkgs
}

func cmdgo_matchPackagesInFS(pattern string) []string {

	i := strings.Index(pattern, "...")
	dir, _ := path.Split(pattern[:i])

	prefix := ""
	if strings.HasPrefix(pattern, "./") {
		prefix = "./"
	}
	match := cmdgo_matchPattern(pattern)

	var pkgs []string
	filepath.Walk(dir, func(path string, fi os.FileInfo, err error) error {
		if err != nil || !fi.IsDir() {
			return nil
		}
		if path == dir {

			path = filepath.Clean(path)
		}

		_, elem := filepath.Split(path)
		dot := strings.HasPrefix(elem, ".") && elem != "." && elem != ".."
		if dot || strings.HasPrefix(elem, "_") || elem == "testdata" {
			return filepath.SkipDir
		}

		name := prefix + filepath.ToSlash(path)
		if !match(name) {
			return nil
		}

		if p, err := cmdgo_buildContext.ImportDir(path, 0); err != nil && (p == nil || len(p.InvalidGoFiles) == 0) {
			if _, noGo := err.(*build.NoGoError); !noGo {
				log.Print(err)
			}
			return nil
		}
		pkgs = append(pkgs, name)
		return nil
	})
	return pkgs
}

// stringList's arguments should be a sequence of string or []string values.
// stringList flattens them into a single []string.
func cmdgo_stringList(args ...interface{}) []string {
	var x []string
	for _, arg := range args {
		switch arg := arg.(type) {
		case []string:
			x = append(x, arg...)
		case string:
			x = append(x, arg)
		default:
			panic("stringList: invalid argument of type " + fmt.Sprintf("%T", arg))
		}
	}
	return x
}

// toFold returns a string with the property that
//	strings.EqualFold(s, t) iff toFold(s) == toFold(t)
// This lets us test a large set of strings for fold-equivalent
// duplicates without making a quadratic number of calls
// to EqualFold. Note that strings.ToUpper and strings.ToLower
// have the desired property in some corner cases.
func cmdgo_toFold(s string) string {

	for i := 0; i < len(s); i++ {
		c := s[i]
		if c >= utf8.RuneSelf || 'A' <= c && c <= 'Z' {
			goto Slow
		}
	}
	return s

Slow:
	var buf bytes.Buffer
	for _, r := range s {

		for {
			r0 := r
			r = unicode.SimpleFold(r0)
			if r <= r0 {
				break
			}
		}

		if 'A' <= r && r <= 'Z' {
			r += 'a' - 'A'
		}
		buf.WriteRune(r)
	}
	return buf.String()
}

// foldDup reports a pair of strings from the list that are
// equal according to strings.EqualFold.
// It returns "", "" if there are no such strings.
func cmdgo_foldDup(list []string) (string, string) {
	clash := map[string]string{}
	for _, s := range list {
		fold := cmdgo_toFold(s)
		if t := clash[fold]; t != "" {
			if s > t {
				s, t = t, s
			}
			return s, t
		}
		clash[fold] = s
	}
	return "", ""
}

func cmdgo_readAligned4(r io.Reader, sz int32) ([]byte, error) {
	full := (sz + 3) &^ 3
	data := make([]byte, full)
	_, err := io.ReadFull(r, data)
	if err != nil {
		return nil, err
	}
	data = data[:sz]
	return data, nil
}

func cmdgo_readELFNote(filename, name string, typ int32) ([]byte, error) {
	f, err := elf.Open(filename)
	if err != nil {
		return nil, err
	}
	for _, sect := range f.Sections {
		if sect.Type != elf.SHT_NOTE {
			continue
		}
		r := sect.Open()
		for {
			var namesize, descsize, noteType int32
			err = binary.Read(r, f.ByteOrder, &namesize)
			if err != nil {
				if err == io.EOF {
					break
				}
				return nil, fmt.Errorf("read namesize failed: %v", err)
			}
			err = binary.Read(r, f.ByteOrder, &descsize)
			if err != nil {
				return nil, fmt.Errorf("read descsize failed: %v", err)
			}
			err = binary.Read(r, f.ByteOrder, &noteType)
			if err != nil {
				return nil, fmt.Errorf("read type failed: %v", err)
			}
			noteName, err := cmdgo_readAligned4(r, namesize)
			if err != nil {
				return nil, fmt.Errorf("read name failed: %v", err)
			}
			desc, err := cmdgo_readAligned4(r, descsize)
			if err != nil {
				return nil, fmt.Errorf("read desc failed: %v", err)
			}
			if name == string(noteName) && typ == noteType {
				return desc, nil
			}
		}
	}
	return nil, nil
}

var cmdgo_elfGoNote = []byte("Go\x00\x00")

// The Go build ID is stored in a note described by an ELF PT_NOTE prog
// header. The caller has already opened filename, to get f, and read
// at least 4 kB out, in data.
func cmdgo_readELFGoBuildID(filename string, f *os.File, data []byte) (buildid string, err error) {

	switch elf.Class(data[elf.EI_CLASS]) {
	case elf.ELFCLASS32:
		data[48] = 0
		data[49] = 0
	case elf.ELFCLASS64:
		data[60] = 0
		data[61] = 0
	}

	const elfGoBuildIDTag = 4

	ef, err := elf.NewFile(bytes.NewReader(data))
	if err != nil {
		return "", &os.PathError{Path: filename, Op: "parse", Err: err}
	}
	for _, p := range ef.Progs {
		if p.Type != elf.PT_NOTE || p.Filesz < 16 {
			continue
		}

		var note []byte
		if p.Off+p.Filesz < uint64(len(data)) {
			note = data[p.Off : p.Off+p.Filesz]
		} else {

			_, err = f.Seek(int64(p.Off), io.SeekStart)
			if err != nil {
				return "", err
			}

			note = make([]byte, p.Filesz)
			_, err = io.ReadFull(f, note)
			if err != nil {
				return "", err
			}
		}

		filesz := p.Filesz
		for filesz >= 16 {
			nameSize := ef.ByteOrder.Uint32(note)
			valSize := ef.ByteOrder.Uint32(note[4:])
			tag := ef.ByteOrder.Uint32(note[8:])
			name := note[12:16]
			if nameSize == 4 && 16+valSize <= uint32(len(note)) && tag == elfGoBuildIDTag && bytes.Equal(name, cmdgo_elfGoNote) {
				return string(note[16 : 16+valSize]), nil
			}

			nameSize = (nameSize + 3) &^ 3
			valSize = (valSize + 3) &^ 3
			notesz := uint64(12 + nameSize + valSize)
			if filesz <= notesz {
				break
			}
			filesz -= notesz
			note = note[notesz:]
		}
	}

	return "", nil
}

// The Go build ID is stored at the beginning of the Mach-O __text segment.
// The caller has already opened filename, to get f, and read a few kB out, in data.
// Sadly, that's not guaranteed to hold the note, because there is an arbitrary amount
// of other junk placed in the file ahead of the main text.
func cmdgo_readMachoGoBuildID(filename string, f *os.File, data []byte) (buildid string, err error) {

	if b, err := cmdgo_readRawGoBuildID(filename, data); b != "" && err == nil {
		return b, err
	}

	mf, err := macho.NewFile(f)
	if err != nil {
		return "", &os.PathError{Path: filename, Op: "parse", Err: err}
	}

	sect := mf.Section("__text")
	if sect == nil {

		return "", &os.PathError{Path: filename, Op: "parse", Err: fmt.Errorf("cannot find __text section")}
	}

	n := sect.Size
	if n > uint64(cmdgo_BuildIDReadSize) {
		n = uint64(cmdgo_BuildIDReadSize)
	}
	buf := make([]byte, n)
	if _, err := f.ReadAt(buf, int64(sect.Offset)); err != nil {
		return "", err
	}

	return cmdgo_readRawGoBuildID(filename, buf)
}

// A Package describes a single package found in a directory.
type cmdgo_Package struct {
	// Note: These fields are part of the go command's public API.
	// See list.go. It is okay to add fields, but not to change or
	// remove existing ones. Keep in sync with list.go
	Dir           string `json:",omitempty"` // directory containing package sources
	ImportPath    string `json:",omitempty"` // import path of package in dir
	ImportComment string `json:",omitempty"` // path in import comment on package statement
	Name          string `json:",omitempty"` // package name
	Doc           string `json:",omitempty"` // package documentation string
	Target        string `json:",omitempty"` // install path
	Shlib         string `json:",omitempty"` // the shared library that contains this package (only set when -linkshared)
	Goroot        bool   `json:",omitempty"` // is this package found in the Go root?
	Standard      bool   `json:",omitempty"` // is this package part of the standard Go library?
	Stale         bool   `json:",omitempty"` // would 'go install' do anything for this package?
	StaleReason   string `json:",omitempty"` // why is Stale true?
	Root          string `json:",omitempty"` // Go root or Go path dir containing this package
	ConflictDir   string `json:",omitempty"` // Dir is hidden by this other directory
	BinaryOnly    bool   `json:",omitempty"` // package cannot be recompiled

	// Source files
	GoFiles        []string `json:",omitempty"` // .go source files (excluding CgoFiles, TestGoFiles, XTestGoFiles)
	CgoFiles       []string `json:",omitempty"` // .go sources files that import "C"
	IgnoredGoFiles []string `json:",omitempty"` // .go sources ignored due to build constraints
	CFiles         []string `json:",omitempty"` // .c source files
	CXXFiles       []string `json:",omitempty"` // .cc, .cpp and .cxx source files
	MFiles         []string `json:",omitempty"` // .m source files
	HFiles         []string `json:",omitempty"` // .h, .hh, .hpp and .hxx source files
	FFiles         []string `json:",omitempty"` // .f, .F, .for and .f90 Fortran source files
	SFiles         []string `json:",omitempty"` // .s source files
	SwigFiles      []string `json:",omitempty"` // .swig files
	SwigCXXFiles   []string `json:",omitempty"` // .swigcxx files
	SysoFiles      []string `json:",omitempty"` // .syso system object files added to package

	// Cgo directives
	CgoCFLAGS    []string `json:",omitempty"` // cgo: flags for C compiler
	CgoCPPFLAGS  []string `json:",omitempty"` // cgo: flags for C preprocessor
	CgoCXXFLAGS  []string `json:",omitempty"` // cgo: flags for C++ compiler
	CgoFFLAGS    []string `json:",omitempty"` // cgo: flags for Fortran compiler
	CgoLDFLAGS   []string `json:",omitempty"` // cgo: flags for linker
	CgoPkgConfig []string `json:",omitempty"` // cgo: pkg-config names

	// Dependency information
	Imports []string `json:",omitempty"` // import paths used by this package
	Deps    []string `json:",omitempty"` // all (recursively) imported dependencies

	// Error information
	Incomplete bool                  `json:",omitempty"` // was there an error loading this package or dependencies?
	Error      *cmdgo_PackageError   `json:",omitempty"` // error loading this package (not dependencies)
	DepsErrors []*cmdgo_PackageError `json:",omitempty"` // errors loading dependencies

	// Test information
	TestGoFiles  []string `json:",omitempty"` // _test.go files in package
	TestImports  []string `json:",omitempty"` // imports from TestGoFiles
	XTestGoFiles []string `json:",omitempty"` // _test.go files outside package
	XTestImports []string `json:",omitempty"` // imports from XTestGoFiles

	// Unexported fields are not part of the public API.
	build        *build.Package
	pkgdir       string // overrides build.PkgDir
	imports      []*cmdgo_Package
	deps         []*cmdgo_Package
	gofiles      []string // GoFiles+CgoFiles+TestGoFiles+XTestGoFiles files, absolute paths
	sfiles       []string
	allgofiles   []string                   // gofiles + IgnoredGoFiles, absolute paths
	target       string                     // installed file for this package (may be executable)
	fake         bool                       // synthesized package
	external     bool                       // synthesized external test package
	forceLibrary bool                       // this package is a library (even if named "main")
	cmdline      bool                       // defined by files listed on command line
	local        bool                       // imported via local path (./ or ../)
	localPrefix  string                     // interpret ./ and ../ imports relative to this prefix
	exeName      string                     // desired name for temporary executable
	coverMode    string                     // preprocess Go source files with the coverage tool in this mode
	coverVars    map[string]*cmdgo_CoverVar // variables created by coverage analysis
	omitDWARF    bool                       // tell linker not to write DWARF information
	buildID      string                     // expected build ID for generated package
	gobinSubdir  bool                       // install target would be subdir of GOBIN
}

// vendored returns the vendor-resolved version of imports,
// which should be p.TestImports or p.XTestImports, NOT p.Imports.
// The imports in p.TestImports and p.XTestImports are not recursively
// loaded during the initial load of p, so they list the imports found in
// the source file, but most processing should be over the vendor-resolved
// import paths. We do this resolution lazily both to avoid file system work
// and because the eventual real load of the test imports (during 'go test')
// can produce better error messages if it starts with the original paths.
// The initial load of p loads all the non-test imports and rewrites
// the vendored paths, so nothing should ever call p.vendored(p.Imports).
func (p *cmdgo_Package) vendored(imports []string) []string {
	if len(imports) > 0 && len(p.Imports) > 0 && &imports[0] == &p.Imports[0] {
		panic("internal error: p.vendored(p.Imports) called")
	}
	seen := make(map[string]bool)
	var all []string
	for _, path := range imports {
		path = cmdgo_vendoredImportPath(p, path)
		if !seen[path] {
			seen[path] = true
			all = append(all, path)
		}
	}
	sort.Strings(all)
	return all
}

// CoverVar holds the name of the generated coverage variables targeting the named file.
type cmdgo_CoverVar struct {
	File string // local file name
	Var  string // name of count struct
}

func (p *cmdgo_Package) copyBuild(pp *build.Package) {
	p.build = pp

	if pp.PkgTargetRoot != "" && cmdgo_buildPkgdir != "" {
		old := pp.PkgTargetRoot
		pp.PkgRoot = cmdgo_buildPkgdir
		pp.PkgTargetRoot = cmdgo_buildPkgdir
		pp.PkgObj = filepath.Join(cmdgo_buildPkgdir, strings.TrimPrefix(pp.PkgObj, old))
	}

	p.Dir = pp.Dir
	p.ImportPath = pp.ImportPath
	p.ImportComment = pp.ImportComment
	p.Name = pp.Name
	p.Doc = pp.Doc
	p.Root = pp.Root
	p.ConflictDir = pp.ConflictDir
	p.BinaryOnly = pp.BinaryOnly

	p.Goroot = pp.Goroot
	p.Standard = p.Goroot && p.ImportPath != "" && cmdgo_isStandardImportPath(p.ImportPath)
	p.GoFiles = pp.GoFiles
	p.CgoFiles = pp.CgoFiles
	p.IgnoredGoFiles = pp.IgnoredGoFiles
	p.CFiles = pp.CFiles
	p.CXXFiles = pp.CXXFiles
	p.MFiles = pp.MFiles
	p.HFiles = pp.HFiles
	p.FFiles = pp.FFiles
	p.SFiles = pp.SFiles
	p.SwigFiles = pp.SwigFiles
	p.SwigCXXFiles = pp.SwigCXXFiles
	p.SysoFiles = pp.SysoFiles
	p.CgoCFLAGS = pp.CgoCFLAGS
	p.CgoCPPFLAGS = pp.CgoCPPFLAGS
	p.CgoCXXFLAGS = pp.CgoCXXFLAGS
	p.CgoLDFLAGS = pp.CgoLDFLAGS
	p.CgoPkgConfig = pp.CgoPkgConfig
	p.Imports = pp.Imports
	p.TestGoFiles = pp.TestGoFiles
	p.TestImports = pp.TestImports
	p.XTestGoFiles = pp.XTestGoFiles
	p.XTestImports = pp.XTestImports
}

// isStandardImportPath reports whether $GOROOT/src/path should be considered
// part of the standard distribution. For historical reasons we allow people to add
// their own code to $GOROOT instead of using $GOPATH, but we assume that
// code will start with a domain name (dot in the first element).
func cmdgo_isStandardImportPath(path string) bool {
	i := strings.Index(path, "/")
	if i < 0 {
		i = len(path)
	}
	elem := path[:i]
	return !strings.Contains(elem, ".")
}

// A PackageError describes an error loading information about a package.
type cmdgo_PackageError struct {
	ImportStack   []string // shortest path from package named on command line to this one
	Pos           string   // position of error
	Err           string   // the error itself
	isImportCycle bool     // the error is an import cycle
	hard          bool     // whether the error is soft or hard; soft errors are ignored in some places
}

func (p *cmdgo_PackageError) Error() string {

	if p.isImportCycle {
		return fmt.Sprintf("%s\npackage %s\n", p.Err, strings.Join(p.ImportStack, "\n\timports "))
	}
	if p.Pos != "" {

		return p.Pos + ": " + p.Err
	}
	if len(p.ImportStack) == 0 {
		return p.Err
	}
	return "package " + strings.Join(p.ImportStack, "\n\timports ") + ": " + p.Err
}

// An importStack is a stack of import paths.
type cmdgo_importStack []string

func (s *cmdgo_importStack) push(p string) {
	*s = append(*s, p)
}

func (s *cmdgo_importStack) pop() {
	*s = (*s)[0 : len(*s)-1]
}

func (s *cmdgo_importStack) copy() []string {
	return append([]string{}, *s...)
}

// shorterThan reports whether sp is shorter than t.
// We use this to record the shortest import sequence
// that leads to a particular package.
func (sp *cmdgo_importStack) shorterThan(t []string) bool {
	s := *sp
	if len(s) != len(t) {
		return len(s) < len(t)
	}

	for i := range s {
		if s[i] != t[i] {
			return s[i] < t[i]
		}
	}
	return false
}

// packageCache is a lookup cache for loadPackage,
// so that if we look up a package multiple times
// we return the same pointer each time.
var cmdgo_packageCache = map[string]*cmdgo_Package{}

// reloadPackage is like loadPackage but makes sure
// not to use the package cache.
func cmdgo_reloadPackage(arg string, stk *cmdgo_importStack) *cmdgo_Package {
	p := cmdgo_packageCache[arg]
	if p != nil {
		delete(cmdgo_packageCache, p.Dir)
		delete(cmdgo_packageCache, p.ImportPath)
	}
	return cmdgo_loadPackage(arg, stk)
}

// dirToImportPath returns the pseudo-import path we use for a package
// outside the Go path. It begins with _/ and then contains the full path
// to the directory. If the package lives in c:\home\gopher\my\pkg then
// the pseudo-import path is _/c_/home/gopher/my/pkg.
// Using a pseudo-import path like this makes the ./ imports no longer
// a special case, so that all the code to deal with ordinary imports works
// automatically.
func cmdgo_dirToImportPath(dir string) string {
	return pathpkg.Join("_", strings.Map(cmdgo_makeImportValid, filepath.ToSlash(dir)))
}

func cmdgo_makeImportValid(r rune) rune {
	// Should match Go spec, compilers, and ../../go/parser/parser.go:/isValidImport.
	const illegalChars = `!"#$%&'()*,:;<=>?[\]^{|}` + "`\uFFFD"
	if !unicode.IsGraphic(r) || unicode.IsSpace(r) || strings.ContainsRune(illegalChars, r) {
		return '_'
	}
	return r
}

// Mode flags for loadImport and download (in get.go).
const (
	// useVendor means that loadImport should do vendor expansion
	// (provided the vendoring experiment is enabled).
	// That is, useVendor means that the import path came from
	// a source file and has not been vendor-expanded yet.
	// Every import path should be loaded initially with useVendor,
	// and then the expanded version (with the /vendor/ in it) gets
	// recorded as the canonical import path. At that point, future loads
	// of that package must not pass useVendor, because
	// disallowVendor will reject direct use of paths containing /vendor/.
	cmdgo_useVendor = 1 << iota

	// getTestDeps is for download (part of "go get") and indicates
	// that test dependencies should be fetched too.
	cmdgo_getTestDeps
)

// loadImport scans the directory named by path, which must be an import path,
// but possibly a local import path (an absolute file system path or one beginning
// with ./ or ../).  A local relative path is interpreted relative to srcDir.
// It returns a *Package describing the package found in that directory.
func cmdgo_loadImport(path, srcDir string, parent *cmdgo_Package, stk *cmdgo_importStack, importPos []token.Position, mode int) *cmdgo_Package {
	stk.push(path)
	defer stk.pop()

	importPath := path
	origPath := path
	isLocal := build.IsLocalImport(path)
	if isLocal {
		importPath = cmdgo_dirToImportPath(filepath.Join(srcDir, path))
	} else if mode&cmdgo_useVendor != 0 {

		path = cmdgo_vendoredImportPath(parent, path)
		importPath = path
	}

	if p := cmdgo_packageCache[importPath]; p != nil {
		if perr := cmdgo_disallowInternal(srcDir, p, stk); perr != p {
			return perr
		}
		if mode&cmdgo_useVendor != 0 {
			if perr := cmdgo_disallowVendor(srcDir, origPath, p, stk); perr != p {
				return perr
			}
		}
		return cmdgo_reusePackage(p, stk)
	}

	p := new(cmdgo_Package)
	p.local = isLocal
	p.ImportPath = importPath
	cmdgo_packageCache[importPath] = p

	buildMode := build.ImportComment
	if mode&cmdgo_useVendor == 0 || path != origPath {

		buildMode |= build.IgnoreVendor
	}
	bp, err := cmdgo_buildContext.Import(path, srcDir, buildMode)
	bp.ImportPath = importPath
	if cmdgo_gobin != "" {
		bp.BinDir = cmdgo_gobin
	}
	if err == nil && !isLocal && bp.ImportComment != "" && bp.ImportComment != path &&
		!strings.Contains(path, "/vendor/") && !strings.HasPrefix(path, "vendor/") {
		err = fmt.Errorf("code in directory %s expects import %q", bp.Dir, bp.ImportComment)
	}
	p.load(stk, bp, err)
	if p.Error != nil && p.Error.Pos == "" && len(importPos) > 0 {
		pos := importPos[0]
		pos.Filename = cmdgo_shortPath(pos.Filename)
		p.Error.Pos = pos.String()
	}

	if perr := cmdgo_disallowInternal(srcDir, p, stk); perr != p {
		return perr
	}
	if mode&cmdgo_useVendor != 0 {
		if perr := cmdgo_disallowVendor(srcDir, origPath, p, stk); perr != p {
			return perr
		}
	}

	return p
}

var cmdgo_isDirCache = map[string]bool{}

func cmdgo_isDir(path string) bool {
	result, ok := cmdgo_isDirCache[path]
	if ok {
		return result
	}

	fi, err := os.Stat(path)
	result = err == nil && fi.IsDir()
	cmdgo_isDirCache[path] = result
	return result
}

// vendoredImportPath returns the expansion of path when it appears in parent.
// If parent is x/y/z, then path might expand to x/y/z/vendor/path, x/y/vendor/path,
// x/vendor/path, vendor/path, or else stay path if none of those exist.
// vendoredImportPath returns the expanded path or, if no expansion is found, the original.
func cmdgo_vendoredImportPath(parent *cmdgo_Package, path string) (found string) {
	if parent == nil || parent.Root == "" {
		return path
	}

	dir := filepath.Clean(parent.Dir)
	root := filepath.Join(parent.Root, "src")
	if !cmdgo_hasFilePathPrefix(dir, root) {

		dir = cmdgo_expandPath(dir)
		root = cmdgo_expandPath(root)
	}
	if !cmdgo_hasFilePathPrefix(dir, root) || len(dir) <= len(root) || dir[len(root)] != filepath.Separator {
		cmdgo_fatalf("invalid vendoredImportPath: dir=%q root=%q separator=%q", dir, root, string(filepath.Separator))
	}

	vpath := "vendor/" + path
	for i := len(dir); i >= len(root); i-- {
		if i < len(dir) && dir[i] != filepath.Separator {
			continue
		}

		if !cmdgo_isDir(filepath.Join(dir[:i], "vendor")) {
			continue
		}
		targ := filepath.Join(dir[:i], vpath)
		if cmdgo_isDir(targ) && cmdgo_hasGoFiles(targ) {
			importPath := parent.ImportPath
			if importPath == "command-line-arguments" {

				importPath = dir[len(root)+1:]
			}

			chopped := len(dir) - i
			if chopped == len(importPath)+1 {

				return vpath
			}
			return importPath[:len(importPath)-chopped] + "/" + vpath
		}
	}
	return path
}

// hasGoFiles reports whether dir contains any files with names ending in .go.
// For a vendor check we must exclude directories that contain no .go files.
// Otherwise it is not possible to vendor just a/b/c and still import the
// non-vendored a/b. See golang.org/issue/13832.
func cmdgo_hasGoFiles(dir string) bool {
	fis, _ := ioutil.ReadDir(dir)
	for _, fi := range fis {
		if !fi.IsDir() && strings.HasSuffix(fi.Name(), ".go") {
			return true
		}
	}
	return false
}

// reusePackage reuses package p to satisfy the import at the top
// of the import stack stk. If this use causes an import loop,
// reusePackage updates p's error information to record the loop.
func cmdgo_reusePackage(p *cmdgo_Package, stk *cmdgo_importStack) *cmdgo_Package {

	if p.imports == nil {
		if p.Error == nil {
			p.Error = &cmdgo_PackageError{
				ImportStack:   stk.copy(),
				Err:           "import cycle not allowed",
				isImportCycle: true,
			}
		}
		p.Incomplete = true
	}

	if p.Error != nil && !p.Error.isImportCycle && stk.shorterThan(p.Error.ImportStack) {
		p.Error.ImportStack = stk.copy()
	}
	return p
}

// disallowInternal checks that srcDir is allowed to import p.
// If the import is allowed, disallowInternal returns the original package p.
// If not, it returns a new package containing just an appropriate error.
func cmdgo_disallowInternal(srcDir string, p *cmdgo_Package, stk *cmdgo_importStack) *cmdgo_Package {

	if p.Error != nil {
		return p
	}

	if len(*stk) == 1 {
		return p
	}

	i, ok := cmdgo_findInternal(p.ImportPath)
	if !ok {
		return p
	}

	if i > 0 {
		i--
	}
	parent := p.Dir[:i+len(p.Dir)-len(p.ImportPath)]
	if cmdgo_hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {
		return p
	}

	srcDir = cmdgo_expandPath(srcDir)
	parent = cmdgo_expandPath(parent)
	if cmdgo_hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {
		return p
	}

	perr := *p
	perr.Error = &cmdgo_PackageError{
		ImportStack: stk.copy(),
		Err:         "use of internal package not allowed",
	}
	perr.Incomplete = true
	return &perr
}

// findInternal looks for the final "internal" path element in the given import path.
// If there isn't one, findInternal returns ok=false.
// Otherwise, findInternal returns ok=true and the index of the "internal".
func cmdgo_findInternal(path string) (index int, ok bool) {

	switch {
	case strings.HasSuffix(path, "/internal"):
		return len(path) - len("internal"), true
	case strings.Contains(path, "/internal/"):
		return strings.LastIndex(path, "/internal/") + 1, true
	case path == "internal", strings.HasPrefix(path, "internal/"):
		return 0, true
	}
	return 0, false
}

// disallowVendor checks that srcDir is allowed to import p as path.
// If the import is allowed, disallowVendor returns the original package p.
// If not, it returns a new package containing just an appropriate error.
func cmdgo_disallowVendor(srcDir, path string, p *cmdgo_Package, stk *cmdgo_importStack) *cmdgo_Package {

	if len(*stk) == 1 {
		return p
	}

	if perr := cmdgo_disallowVendorVisibility(srcDir, p, stk); perr != p {
		return perr
	}

	if i, ok := cmdgo_findVendor(path); ok {
		perr := *p
		perr.Error = &cmdgo_PackageError{
			ImportStack: stk.copy(),
			Err:         "must be imported as " + path[i+len("vendor/"):],
		}
		perr.Incomplete = true
		return &perr
	}

	return p
}

// disallowVendorVisibility checks that srcDir is allowed to import p.
// The rules are the same as for /internal/ except that a path ending in /vendor
// is not subject to the rules, only subdirectories of vendor.
// This allows people to have packages and commands named vendor,
// for maximal compatibility with existing source trees.
func cmdgo_disallowVendorVisibility(srcDir string, p *cmdgo_Package, stk *cmdgo_importStack) *cmdgo_Package {

	if len(*stk) == 1 {
		return p
	}

	i, ok := cmdgo_findVendor(p.ImportPath)
	if !ok {
		return p
	}

	if i > 0 {
		i--
	}
	truncateTo := i + len(p.Dir) - len(p.ImportPath)
	if truncateTo < 0 || len(p.Dir) < truncateTo {
		return p
	}
	parent := p.Dir[:truncateTo]
	if cmdgo_hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {
		return p
	}

	srcDir = cmdgo_expandPath(srcDir)
	parent = cmdgo_expandPath(parent)
	if cmdgo_hasFilePathPrefix(filepath.Clean(srcDir), filepath.Clean(parent)) {
		return p
	}

	perr := *p
	perr.Error = &cmdgo_PackageError{
		ImportStack: stk.copy(),
		Err:         "use of vendored package not allowed",
	}
	perr.Incomplete = true
	return &perr
}

// findVendor looks for the last non-terminating "vendor" path element in the given import path.
// If there isn't one, findVendor returns ok=false.
// Otherwise, findVendor returns ok=true and the index of the "vendor".
//
// Note that terminating "vendor" elements don't count: "x/vendor" is its own package,
// not the vendored copy of an import "" (the empty import path).
// This will allow people to have packages or commands named vendor.
// This may help reduce breakage, or it may just be confusing. We'll see.
func cmdgo_findVendor(path string) (index int, ok bool) {

	switch {
	case strings.Contains(path, "/vendor/"):
		return strings.LastIndex(path, "/vendor/") + 1, true
	case strings.HasPrefix(path, "vendor/"):
		return 0, true
	}
	return 0, false
}

type cmdgo_targetDir int

const (
	cmdgo_toRoot    cmdgo_targetDir = iota // to bin dir inside package root (default)
	cmdgo_toTool                           // GOROOT/pkg/tool
	cmdgo_stalePath                        // the old import path; fail to build
)

// goTools is a map of Go program import path to install target directory.
var cmdgo_goTools = map[string]cmdgo_targetDir{
	"cmd/addr2line":                        cmdgo_toTool,
	"cmd/api":                              cmdgo_toTool,
	"cmd/asm":                              cmdgo_toTool,
	"cmd/compile":                          cmdgo_toTool,
	"cmd/cgo":                              cmdgo_toTool,
	"cmd/cover":                            cmdgo_toTool,
	"cmd/dist":                             cmdgo_toTool,
	"cmd/doc":                              cmdgo_toTool,
	"cmd/fix":                              cmdgo_toTool,
	"cmd/link":                             cmdgo_toTool,
	"cmd/newlink":                          cmdgo_toTool,
	"cmd/nm":                               cmdgo_toTool,
	"cmd/objdump":                          cmdgo_toTool,
	"cmd/pack":                             cmdgo_toTool,
	"cmd/pprof":                            cmdgo_toTool,
	"cmd/trace":                            cmdgo_toTool,
	"cmd/vet":                              cmdgo_toTool,
	"cmd/yacc":                             cmdgo_toTool,
	"code.google.com/p/go.tools/cmd/cover": cmdgo_stalePath,
	"code.google.com/p/go.tools/cmd/godoc": cmdgo_stalePath,
	"code.google.com/p/go.tools/cmd/vet":   cmdgo_stalePath,
}

// expandScanner expands a scanner.List error into all the errors in the list.
// The default Error method only shows the first error.
func cmdgo_expandScanner(err error) error {

	if err, ok := err.(scanner.ErrorList); ok {
		// Prepare error with \n before each message.
		// When printed in something like context: %v
		// this will put the leading file positions each on
		// its own line. It will also show all the errors
		// instead of just the first, as err.Error does.
		var buf bytes.Buffer
		for _, e := range err {
			e.Pos.Filename = cmdgo_shortPath(e.Pos.Filename)
			buf.WriteString("\n")
			buf.WriteString(e.Error())
		}
		return errors.New(buf.String())
	}
	return err
}

var cmdgo_raceExclude = map[string]bool{
	"runtime/race": true,
	"runtime/msan": true,
	"runtime/cgo":  true,
	"cmd/cgo":      true,
	"syscall":      true,
	"errors":       true,
}

var cmdgo_cgoExclude = map[string]bool{
	"runtime/cgo": true,
}

var cmdgo_cgoSyscallExclude = map[string]bool{
	"runtime/cgo":  true,
	"runtime/race": true,
	"runtime/msan": true,
}

// load populates p using information from bp, err, which should
// be the result of calling build.Context.Import.
func (p *cmdgo_Package) load(stk *cmdgo_importStack, bp *build.Package, err error) *cmdgo_Package {
	p.copyBuild(bp)

	p.localPrefix = cmdgo_dirToImportPath(p.Dir)

	if err != nil {
		p.Incomplete = true
		err = cmdgo_expandScanner(err)
		p.Error = &cmdgo_PackageError{
			ImportStack: stk.copy(),
			Err:         err.Error(),
		}
		return p
	}

	useBindir := p.Name == "main"
	if !p.Standard {
		switch cmdgo_buildBuildmode {
		case "c-archive", "c-shared":
			useBindir = false
		}
	}

	if useBindir {

		if cmdgo_goTools[p.ImportPath] == cmdgo_stalePath {
			newPath := strings.Replace(p.ImportPath, "code.google.com/p/go.", "golang.org/x/", 1)
			e := fmt.Sprintf("the %v command has moved; use %v instead.", p.ImportPath, newPath)
			p.Error = &cmdgo_PackageError{Err: e}
			return p
		}
		_, elem := filepath.Split(p.Dir)
		full := cmdgo_buildContext.GOOS + "_" + cmdgo_buildContext.GOARCH + "/" + elem
		if cmdgo_buildContext.GOOS != cmdgo_toolGOOS || cmdgo_buildContext.GOARCH != cmdgo_toolGOARCH {

			elem = full
		}
		if p.build.BinDir != "" {

			p.target = filepath.Join(p.build.BinDir, elem)
			if !p.Goroot && strings.Contains(elem, "/") && cmdgo_gobin != "" {

				p.target = ""
				p.gobinSubdir = true
			}
		}
		if cmdgo_goTools[p.ImportPath] == cmdgo_toTool {

			p.target = filepath.Join(cmdgo_gorootPkg, "tool", full)
		}
		if p.target != "" && cmdgo_buildContext.GOOS == "windows" {
			p.target += ".exe"
		}
	} else if p.local {

		p.target = ""
	} else {
		p.target = p.build.PkgObj
		if cmdgo_buildLinkshared {
			shlibnamefile := p.target[:len(p.target)-2] + ".shlibname"
			shlib, err := ioutil.ReadFile(shlibnamefile)
			if err == nil {
				libname := strings.TrimSpace(string(shlib))
				if cmdgo_buildContext.Compiler == "gccgo" {
					p.Shlib = filepath.Join(p.build.PkgTargetRoot, "shlibs", libname)
				} else {
					p.Shlib = filepath.Join(p.build.PkgTargetRoot, libname)

				}
			} else if !os.IsNotExist(err) {
				cmdgo_fatalf("unexpected error reading %s: %v", shlibnamefile, err)
			}
		}
	}

	importPaths := p.Imports

	if len(p.CgoFiles) > 0 && (!p.Standard || !cmdgo_cgoExclude[p.ImportPath]) {
		importPaths = append(importPaths, "runtime/cgo")
	}
	if len(p.CgoFiles) > 0 && (!p.Standard || !cmdgo_cgoSyscallExclude[p.ImportPath]) {
		importPaths = append(importPaths, "syscall")
	}

	if p.Name == "main" && !p.Goroot && (cmdgo_buildBuildmode == "c-shared" || cmdgo_buildBuildmode == "pie" || cmdgo_buildLinkshared) {
		importPaths = append(importPaths, "runtime/cgo")
	}

	if !p.Standard || (p.ImportPath != "runtime" && !strings.HasPrefix(p.ImportPath, "runtime/internal/") && p.ImportPath != "unsafe") {
		importPaths = append(importPaths, "runtime")

		if cmdgo_buildRace && (!p.Standard || !cmdgo_raceExclude[p.ImportPath]) {
			importPaths = append(importPaths, "runtime/race")
		}

		if cmdgo_buildMSan && (!p.Standard || !cmdgo_raceExclude[p.ImportPath]) {
			importPaths = append(importPaths, "runtime/msan")
		}

		if p.Name == "main" && cmdgo_goarch == "arm" {
			importPaths = append(importPaths, "math")
		}
	}

	if p.Standard && (p.ImportPath == "runtime" || strings.HasPrefix(p.ImportPath, "runtime/internal/")) && p.ImportPath != "runtime/internal/sys" {
		importPaths = append(importPaths, "runtime/internal/sys")
	}

	p.gofiles = cmdgo_stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.XTestGoFiles)
	for i := range p.gofiles {
		p.gofiles[i] = filepath.Join(p.Dir, p.gofiles[i])
	}
	sort.Strings(p.gofiles)

	p.sfiles = cmdgo_stringList(p.SFiles)
	for i := range p.sfiles {
		p.sfiles[i] = filepath.Join(p.Dir, p.sfiles[i])
	}
	sort.Strings(p.sfiles)

	p.allgofiles = cmdgo_stringList(p.IgnoredGoFiles)
	for i := range p.allgofiles {
		p.allgofiles[i] = filepath.Join(p.Dir, p.allgofiles[i])
	}
	p.allgofiles = append(p.allgofiles, p.gofiles...)
	sort.Strings(p.allgofiles)

	f1, f2 := cmdgo_foldDup(cmdgo_stringList(
		p.GoFiles,
		p.CgoFiles,
		p.IgnoredGoFiles,
		p.CFiles,
		p.CXXFiles,
		p.MFiles,
		p.HFiles,
		p.FFiles,
		p.SFiles,
		p.SysoFiles,
		p.SwigFiles,
		p.SwigCXXFiles,
		p.TestGoFiles,
		p.XTestGoFiles,
	))
	if f1 != "" {
		p.Error = &cmdgo_PackageError{
			ImportStack: stk.copy(),
			Err:         fmt.Sprintf("case-insensitive file name collision: %q and %q", f1, f2),
		}
		return p
	}

	imports := make([]*cmdgo_Package, 0, len(p.Imports))
	deps := make(map[string]*cmdgo_Package)
	for i, path := range importPaths {
		if path == "C" {
			continue
		}
		p1 := cmdgo_loadImport(path, p.Dir, p, stk, p.build.ImportPos[path], cmdgo_useVendor)
		if p1.Name == "main" {
			p.Error = &cmdgo_PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("import %q is a program, not an importable package", path),
			}
			pos := p.build.ImportPos[path]
			if len(pos) > 0 {
				p.Error.Pos = pos[0].String()
			}
		}
		if p1.local {
			if !p.local && p.Error == nil {
				p.Error = &cmdgo_PackageError{
					ImportStack: stk.copy(),
					Err:         fmt.Sprintf("local import %q in non-local package", path),
				}
				pos := p.build.ImportPos[path]
				if len(pos) > 0 {
					p.Error.Pos = pos[0].String()
				}
			}
		}
		if p.Standard && p.Error == nil && !p1.Standard && p1.Error == nil {
			p.Error = &cmdgo_PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("non-standard import %q in standard package %q", path, p.ImportPath),
			}
			pos := p.build.ImportPos[path]
			if len(pos) > 0 {
				p.Error.Pos = pos[0].String()
			}
		}

		path = p1.ImportPath
		importPaths[i] = path
		if i < len(p.Imports) {
			p.Imports[i] = path
		}
		deps[path] = p1
		imports = append(imports, p1)
		for _, dep := range p1.deps {

			if deps[dep.ImportPath] == nil || dep.Error != nil {
				deps[dep.ImportPath] = dep
			}
		}
		if p1.Incomplete {
			p.Incomplete = true
		}
	}
	p.imports = imports

	p.Deps = make([]string, 0, len(deps))
	for dep := range deps {
		p.Deps = append(p.Deps, dep)
	}
	sort.Strings(p.Deps)
	for _, dep := range p.Deps {
		p1 := deps[dep]
		if p1 == nil {
			panic("impossible: missing entry in package cache for " + dep + " imported by " + p.ImportPath)
		}
		p.deps = append(p.deps, p1)
		if p1.Error != nil {
			p.DepsErrors = append(p.DepsErrors, p1.Error)
		}
	}

	if p.Standard && (p.ImportPath == "unsafe" || cmdgo_buildContext.Compiler == "gccgo") {
		p.target = ""
	}
	p.Target = p.target

	if !cmdgo_buildContext.CgoEnabled {
		p.CFiles = nil
		p.CXXFiles = nil
		p.MFiles = nil
		p.SwigFiles = nil
		p.SwigCXXFiles = nil

	}

	if len(p.CFiles) > 0 && !p.usesCgo() && !p.usesSwig() && cmdgo_buildContext.Compiler == "gc" {
		p.Error = &cmdgo_PackageError{
			ImportStack: stk.copy(),
			Err:         fmt.Sprintf("C source files not allowed when not using cgo or SWIG: %s", strings.Join(p.CFiles, " ")),
		}
		return p
	}

	if len(p.DepsErrors) == 0 {
		dep1, dep2 := cmdgo_foldDup(p.Deps)
		if dep1 != "" {
			p.Error = &cmdgo_PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("case-insensitive import collision: %q and %q", dep1, dep2),
			}
			return p
		}
	}

	if p.BinaryOnly {

		buildID, err := cmdgo_readBuildID(p)
		if err == nil {
			p.buildID = buildID
		}
	} else {
		cmdgo_computeBuildID(p)
	}
	return p
}

// usesSwig reports whether the package needs to run SWIG.
func (p *cmdgo_Package) usesSwig() bool {
	return len(p.SwigFiles) > 0 || len(p.SwigCXXFiles) > 0
}

// usesCgo reports whether the package needs to run cgo
func (p *cmdgo_Package) usesCgo() bool {
	return len(p.CgoFiles) > 0
}

// packageList returns the list of packages in the dag rooted at roots
// as visited in a depth-first post-order traversal.
func cmdgo_packageList(roots []*cmdgo_Package) []*cmdgo_Package {
	seen := map[*cmdgo_Package]bool{}
	all := []*cmdgo_Package{}
	var walk func(*cmdgo_Package)
	walk = func(p *cmdgo_Package) {
		if seen[p] {
			return
		}
		seen[p] = true
		for _, p1 := range p.imports {
			walk(p1)
		}
		all = append(all, p)
	}
	for _, root := range roots {
		walk(root)
	}
	return all
}

// computeStale computes the Stale flag in the package dag that starts
// at the named pkgs (command-line arguments).
func cmdgo_computeStale(pkgs ...*cmdgo_Package) {
	for _, p := range cmdgo_packageList(pkgs) {
		p.Stale, p.StaleReason = cmdgo_isStale(p)
	}
}

// The runtime version string takes one of two forms:
// "go1.X[.Y]" for Go releases, and "devel +hash" at tip.
// Determine whether we are in a released copy by
// inspecting the version.
var cmdgo_isGoRelease = strings.HasPrefix(runtime.Version(), "go1")

// isStale reports whether package p needs to be rebuilt,
// along with the reason why.
func cmdgo_isStale(p *cmdgo_Package) (bool, string) {
	if p.Standard && (p.ImportPath == "unsafe" || cmdgo_buildContext.Compiler == "gccgo") {

		return false, "builtin package"
	}
	if p.Error != nil {
		return true, "errors loading package"
	}
	if p.Stale {
		return true, p.StaleReason
	}

	if p.BinaryOnly {
		if p.target == "" {

			return true, "no source code for package, but no install target"
		}
		if _, err := os.Stat(p.target); err != nil {

			return true, "no source code for package, but cannot access install target: " + err.Error()
		}
		return false, "no source code for package"
	}

	if cmdgo_buildA {
		return true, "build -a flag in use"
	}

	if p.target == "" {
		return true, "no install target"
	}

	fi, err := os.Stat(p.target)
	if err != nil {
		return true, "cannot stat install target"
	}

	targetBuildID, err := cmdgo_readBuildID(p)
	if err == nil && targetBuildID != p.buildID {
		return true, "build ID mismatch"
	}

	for _, p1 := range p.deps {
		if p1.Stale {
			return true, "stale dependency"
		}
	}

	if p.Standard && cmdgo_isGoRelease {
		return false, "standard package in Go release distribution"
	}

	built := fi.ModTime()

	olderThan := func(file string) bool {
		fi, err := os.Stat(file)
		return err != nil || fi.ModTime().After(built)
	}

	for _, p1 := range p.deps {
		if p1.target != "" && olderThan(p1.target) {
			return true, "newer dependency"
		}
	}

	if p.Root != cmdgo_goroot {
		if olderThan(cmdgo_buildToolchain.compiler()) {
			return true, "newer compiler"
		}
		if p.build.IsCommand() && olderThan(cmdgo_buildToolchain.linker()) {
			return true, "newer linker"
		}
	}

	srcs := cmdgo_stringList(p.GoFiles, p.CFiles, p.CXXFiles, p.MFiles, p.HFiles, p.FFiles, p.SFiles, p.CgoFiles, p.SysoFiles, p.SwigFiles, p.SwigCXXFiles)
	for _, src := range srcs {
		if olderThan(filepath.Join(p.Dir, src)) {
			return true, "newer source file"
		}
	}

	return false, ""
}

// computeBuildID computes the build ID for p, leaving it in p.buildID.
// Build ID is a hash of the information we want to detect changes in.
// See the long comment in isStale for details.
func cmdgo_computeBuildID(p *cmdgo_Package) {
	h := sha1.New()

	inputFiles := cmdgo_stringList(
		p.GoFiles,
		p.CgoFiles,
		p.CFiles,
		p.CXXFiles,
		p.MFiles,
		p.HFiles,
		p.SFiles,
		p.SysoFiles,
		p.SwigFiles,
		p.SwigCXXFiles,
	)
	for _, file := range inputFiles {
		fmt.Fprintf(h, "file %s\n", file)
	}

	if p.Standard && p.ImportPath == "runtime/internal/sys" {
		data, err := ioutil.ReadFile(filepath.Join(p.Dir, "zversion.go"))
		if err != nil {
			cmdgo_fatalf("go: %s", err)
		}
		fmt.Fprintf(h, "zversion %q\n", string(data))
	}

	for _, p1 := range p.deps {
		fmt.Fprintf(h, "dep %s %s\n", p1.ImportPath, p1.buildID)
	}

	p.buildID = fmt.Sprintf("%x", h.Sum(nil))
}

var cmdgo_cwd, _ = os.Getwd()

var cmdgo_cmdCache = map[string]*cmdgo_Package{}

// loadPackage is like loadImport but is used for command-line arguments,
// not for paths found in import statements. In addition to ordinary import paths,
// loadPackage accepts pseudo-paths beginning with cmd/ to denote commands
// in the Go command directory, as well as paths to those directories.
func cmdgo_loadPackage(arg string, stk *cmdgo_importStack) *cmdgo_Package {
	if build.IsLocalImport(arg) {
		dir := arg
		if !filepath.IsAbs(dir) {
			if abs, err := filepath.Abs(dir); err == nil {

				dir = abs
			}
		}
		if sub, ok := cmdgo_hasSubdir(cmdgo_gorootSrc, dir); ok && strings.HasPrefix(sub, "cmd/") && !strings.Contains(sub[4:], "/") {
			arg = sub
		}
	}
	if strings.HasPrefix(arg, "cmd/") && !strings.Contains(arg[4:], "/") {
		if p := cmdgo_cmdCache[arg]; p != nil {
			return p
		}
		stk.push(arg)
		defer stk.pop()

		bp, err := cmdgo_buildContext.ImportDir(filepath.Join(cmdgo_gorootSrc, arg), 0)
		bp.ImportPath = arg
		bp.Goroot = true
		bp.BinDir = cmdgo_gorootBin
		if cmdgo_gobin != "" {
			bp.BinDir = cmdgo_gobin
		}
		bp.Root = cmdgo_goroot
		bp.SrcRoot = cmdgo_gorootSrc
		p := new(cmdgo_Package)
		cmdgo_cmdCache[arg] = p
		p.load(stk, bp, err)
		if p.Error == nil && p.Name != "main" {
			p.Error = &cmdgo_PackageError{
				ImportStack: stk.copy(),
				Err:         fmt.Sprintf("expected package main but found package %s in %s", p.Name, p.Dir),
			}
		}
		return p
	}

	if build.IsLocalImport(arg) {
		bp, _ := cmdgo_buildContext.ImportDir(filepath.Join(cmdgo_cwd, arg), build.FindOnly)
		if bp.ImportPath != "" && bp.ImportPath != "." {
			arg = bp.ImportPath
		}
	}

	return cmdgo_loadImport(arg, cmdgo_cwd, nil, stk, nil, 0)
}

// packages returns the packages named by the
// command line arguments 'args'.  If a named package
// cannot be loaded at all (for example, if the directory does not exist),
// then packages prints an error and does not include that
// package in the results. However, if errors occur trying
// to load dependencies of a named package, the named
// package is still returned, with p.Incomplete = true
// and details in p.DepsErrors.
func cmdgo_packages(args []string) []*cmdgo_Package {
	var pkgs []*cmdgo_Package
	for _, pkg := range cmdgo_packagesAndErrors(args) {
		if pkg.Error != nil {
			cmdgo_errorf("can't load package: %s", pkg.Error)
			continue
		}
		pkgs = append(pkgs, pkg)
	}
	return pkgs
}

// packagesAndErrors is like 'packages' but returns a
// *Package for every argument, even the ones that
// cannot be loaded at all.
// The packages that fail to load will have p.Error != nil.
func cmdgo_packagesAndErrors(args []string) []*cmdgo_Package {
	if len(args) > 0 && strings.HasSuffix(args[0], ".go") {
		return []*cmdgo_Package{cmdgo_goFilesPackage(args)}
	}

	args = cmdgo_importPaths(args)
	var (
		pkgs    []*cmdgo_Package
		stk     cmdgo_importStack
		seenArg = make(map[string]bool)
		seenPkg = make(map[*cmdgo_Package]bool)
	)

	for _, arg := range args {
		if seenArg[arg] {
			continue
		}
		seenArg[arg] = true
		pkg := cmdgo_loadPackage(arg, &stk)
		if seenPkg[pkg] {
			continue
		}
		seenPkg[pkg] = true
		pkgs = append(pkgs, pkg)
	}
	cmdgo_computeStale(pkgs...)

	return pkgs
}

// packagesForBuild is like 'packages' but fails if any of
// the packages or their dependencies have errors
// (cannot be built).
func cmdgo_packagesForBuild(args []string) []*cmdgo_Package {
	pkgs := cmdgo_packagesAndErrors(args)
	printed := map[*cmdgo_PackageError]bool{}
	for _, pkg := range pkgs {
		if pkg.Error != nil {
			cmdgo_errorf("can't load package: %s", pkg.Error)
		}
		for _, err := range pkg.DepsErrors {

			if !printed[err] {
				printed[err] = true
				cmdgo_errorf("%s", err)
			}
		}
	}
	cmdgo_exitIfErrors()

	seen := map[string]bool{}
	reported := map[string]bool{}
	for _, pkg := range cmdgo_packageList(pkgs) {
		if seen[pkg.ImportPath] && !reported[pkg.ImportPath] {
			reported[pkg.ImportPath] = true
			cmdgo_errorf("internal error: duplicate loads of %s", pkg.ImportPath)
		}
		seen[pkg.ImportPath] = true
	}
	cmdgo_exitIfErrors()

	return pkgs
}

// hasSubdir reports whether dir is a subdirectory of
// (possibly multiple levels below) root.
// If so, it sets rel to the path fragment that must be
// appended to root to reach dir.
func cmdgo_hasSubdir(root, dir string) (rel string, ok bool) {
	if p, err := filepath.EvalSymlinks(root); err == nil {
		root = p
	}
	if p, err := filepath.EvalSymlinks(dir); err == nil {
		dir = p
	}
	const sep = string(filepath.Separator)
	root = filepath.Clean(root)
	if !strings.HasSuffix(root, sep) {
		root += sep
	}
	dir = filepath.Clean(dir)
	if !strings.HasPrefix(dir, root) {
		return "", false
	}
	return filepath.ToSlash(dir[len(root):]), true
}

var (
	cmdgo_errBuildIDToolchain = fmt.Errorf("build ID only supported in gc toolchain")
	cmdgo_errBuildIDMalformed = fmt.Errorf("malformed object file")
	cmdgo_errBuildIDUnknown   = fmt.Errorf("lost build ID")
)

var (
	cmdgo_bangArch = []byte("!<arch>")
	cmdgo_pkgdef   = []byte("__.PKGDEF")
	cmdgo_goobject = []byte("go object ")
	cmdgo_buildid  = []byte("build id ")
)

// readBuildID reads the build ID from an archive or binary.
// It only supports the gc toolchain.
// Other toolchain maintainers should adjust this function.
func cmdgo_readBuildID(p *cmdgo_Package) (id string, err error) {
	if cmdgo_buildToolchain != (cmdgo_gcToolchain{}) {
		return "", cmdgo_errBuildIDToolchain
	}

	if p.Name == "main" {
		return cmdgo_ReadBuildIDFromBinary(p.Target)
	}

	if !strings.HasSuffix(p.Target, ".a") {
		return "", &os.PathError{Op: "parse", Path: p.Target, Err: cmdgo_errBuildIDUnknown}
	}

	f, err := os.Open(p.Target)
	if err != nil {
		return "", err
	}
	data := make([]byte, 1024)
	n, err := io.ReadFull(f, data)
	f.Close()

	if err != nil && n == 0 {
		return "", err
	}

	bad := func() (string, error) {
		return "", &os.PathError{Op: "parse", Path: p.Target, Err: cmdgo_errBuildIDMalformed}
	}

	for i := 0; ; i++ {
		j := bytes.IndexByte(data, '\n')
		if j < 0 {
			return bad()
		}
		line := data[:j]
		data = data[j+1:]
		switch i {
		case 0:
			if !bytes.Equal(line, cmdgo_bangArch) {
				return bad()
			}
		case 1:
			if !bytes.HasPrefix(line, cmdgo_pkgdef) {
				return bad()
			}
		case 2:
			if !bytes.HasPrefix(line, cmdgo_goobject) {
				return bad()
			}
		case 3:
			if !bytes.HasPrefix(line, cmdgo_buildid) {

				return "", nil
			}
			id, err := strconv.Unquote(string(line[len(cmdgo_buildid):]))
			if err != nil {
				return bad()
			}
			return id, nil
		}
	}
}

var (
	cmdgo_goBuildPrefix = []byte("\xff Go build ID: \"")
	cmdgo_goBuildEnd    = []byte("\"\n \xff")

	cmdgo_elfPrefix = []byte("\x7fELF")

	cmdgo_machoPrefixes = [][]byte{
		{0xfe, 0xed, 0xfa, 0xce},
		{0xfe, 0xed, 0xfa, 0xcf},
		{0xce, 0xfa, 0xed, 0xfe},
		{0xcf, 0xfa, 0xed, 0xfe},
	}
)

var cmdgo_BuildIDReadSize = 32 * 1024 // changed for testing

// ReadBuildIDFromBinary reads the build ID from a binary.
//
// ELF binaries store the build ID in a proper PT_NOTE section.
//
// Other binary formats are not so flexible. For those, the linker
// stores the build ID as non-instruction bytes at the very beginning
// of the text segment, which should appear near the beginning
// of the file. This is clumsy but fairly portable. Custom locations
// can be added for other binary types as needed, like we did for ELF.
func cmdgo_ReadBuildIDFromBinary(filename string) (id string, err error) {
	if filename == "" {
		return "", &os.PathError{Op: "parse", Path: filename, Err: cmdgo_errBuildIDUnknown}
	}

	f, err := os.Open(filename)
	if err != nil {
		return "", err
	}
	defer f.Close()

	data := make([]byte, cmdgo_BuildIDReadSize)
	_, err = io.ReadFull(f, data)
	if err == io.ErrUnexpectedEOF {
		err = nil
	}
	if err != nil {
		return "", err
	}

	if bytes.HasPrefix(data, cmdgo_elfPrefix) {
		return cmdgo_readELFGoBuildID(filename, f, data)
	}
	for _, m := range cmdgo_machoPrefixes {
		if bytes.HasPrefix(data, m) {
			return cmdgo_readMachoGoBuildID(filename, f, data)
		}
	}

	return cmdgo_readRawGoBuildID(filename, data)
}

// readRawGoBuildID finds the raw build ID stored in text segment data.
func cmdgo_readRawGoBuildID(filename string, data []byte) (id string, err error) {
	i := bytes.Index(data, cmdgo_goBuildPrefix)
	if i < 0 {

		return "", nil
	}

	j := bytes.Index(data[i+len(cmdgo_goBuildPrefix):], cmdgo_goBuildEnd)
	if j < 0 {
		return "", &os.PathError{Op: "parse", Path: filename, Err: cmdgo_errBuildIDMalformed}
	}

	quoted := data[i+len(cmdgo_goBuildPrefix)-1 : i+len(cmdgo_goBuildPrefix)+j+1]
	id, err = strconv.Unquote(string(quoted))
	if err != nil {
		return "", &os.PathError{Op: "parse", Path: filename, Err: cmdgo_errBuildIDMalformed}
	}

	return id, nil
}

var cmdgo_execCmd []string // -exec flag, for run and test

func cmdgo_findExecCmd() []string {
	if cmdgo_execCmd != nil {
		return cmdgo_execCmd
	}
	cmdgo_execCmd = []string{}
	if cmdgo_goos == runtime.GOOS && cmdgo_goarch == runtime.GOARCH {
		return cmdgo_execCmd
	}
	path, err := exec.LookPath(fmt.Sprintf("go_%s_%s_exec", cmdgo_goos, cmdgo_goarch))
	if err == nil {
		cmdgo_execCmd = []string{path}
	}
	return cmdgo_execCmd
}

var cmdgo_cmdRun = &cmdgo_Command{
	UsageLine: "run [build flags] [-exec xprog] gofiles... [arguments...]",
	Short:     "compile and run Go program",
	Long: `
Run compiles and runs the main package comprising the named Go source files.
A Go source file is defined to be a file ending in a literal ".go" suffix.

By default, 'go run' runs the compiled binary directly: 'a.out arguments...'.
If the -exec flag is given, 'go run' invokes the binary using xprog:
	'xprog a.out arguments...'.
If the -exec flag is not given, GOOS or GOARCH is different from the system
default, and a program named go_$GOOS_$GOARCH_exec can be found
on the current search path, 'go run' invokes the binary using that program,
for example 'go_nacl_386_exec a.out arguments...'. This allows execution of
cross-compiled programs when a simulator or other execution method is
available.

For more about build flags, see 'go help build'.

See also: go build.
	`,
}

func init() {
	cmdgo_cmdRun.Run = cmdgo_runRun

	cmdgo_addBuildFlags(cmdgo_cmdRun)
	cmdgo_cmdRun.Flag.Var((*cmdgo_stringsFlag)(&cmdgo_execCmd), "exec", "")
}

func cmdgo_printStderr(args ...interface{}) (int, error) {
	return fmt.Fprint(os.Stderr, args...)
}

func cmdgo_runRun(cmd *cmdgo_Command, args []string) {
	cmdgo_instrumentInit()
	cmdgo_buildModeInit()
	var b cmdgo_builder
	b.init()
	b.print = cmdgo_printStderr
	i := 0
	for i < len(args) && strings.HasSuffix(args[i], ".go") {
		i++
	}
	files, cmdArgs := args[:i], args[i:]
	if len(files) == 0 {
		cmdgo_fatalf("go run: no go files listed")
	}
	for _, file := range files {
		if strings.HasSuffix(file, "_test.go") {

			cmdgo_fatalf("go run: cannot run *_test.go files (%s)", file)
		}
	}
	p := cmdgo_goFilesPackage(files)
	if p.Error != nil {
		cmdgo_fatalf("%s", p.Error)
	}
	p.omitDWARF = true
	if len(p.DepsErrors) > 0 {

		printed := map[*cmdgo_PackageError]bool{}
		for _, err := range p.DepsErrors {
			if !printed[err] {
				printed[err] = true
				cmdgo_errorf("%s", err)
			}
		}
	}
	cmdgo_exitIfErrors()
	if p.Name != "main" {
		cmdgo_fatalf("go run: cannot run non-main package")
	}
	p.target = ""
	var src string
	if len(p.GoFiles) > 0 {
		src = p.GoFiles[0]
	} else if len(p.CgoFiles) > 0 {
		src = p.CgoFiles[0]
	} else {

		hint := ""
		if !cmdgo_buildContext.CgoEnabled {
			hint = " (cgo is disabled)"
		}
		cmdgo_fatalf("go run: no suitable source files%s", hint)
	}
	p.exeName = src[:len(src)-len(".go")]
	a1 := b.action(cmdgo_modeBuild, cmdgo_modeBuild, p)
	a := &cmdgo_action{f: (*cmdgo_builder).runProgram, args: cmdArgs, deps: []*cmdgo_action{a1}}
	b.do(a)
}

// runProgram is the action for running a binary that has already
// been compiled. We ignore exit status.
func (b *cmdgo_builder) runProgram(a *cmdgo_action) error {
	cmdline := cmdgo_stringList(cmdgo_findExecCmd(), a.deps[0].target, a.args)
	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd("", "%s", strings.Join(cmdline, " "))
		if cmdgo_buildN {
			return nil
		}
	}

	cmdgo_runStdin(cmdline)
	return nil
}

// runStdin is like run, but connects Stdin.
func cmdgo_runStdin(cmdline []string) {
	cmd := exec.Command(cmdline[0], cmdline[1:]...)
	cmd.Stdin = os.Stdin
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	cmd.Env = cmdgo_origEnv
	cmdgo_startSigHandlers()
	if err := cmd.Run(); err != nil {
		cmdgo_errorf("%v", err)
	}
}

// interrupted is closed, if go process is interrupted.
var cmdgo_interrupted = make(chan struct{})

// processSignals setups signal handler.
func cmdgo_processSignals() {
	sig := make(chan os.Signal)
	signal.Notify(sig, cmdgo_signalsToIgnore...)
	go func() {
		<-sig
		close(cmdgo_interrupted)
	}()
}

var cmdgo_onceProcessSignals sync.Once

// startSigHandlers start signal handlers.
func cmdgo_startSigHandlers() {
	cmdgo_onceProcessSignals.Do(cmdgo_processSignals)
}

var cmdgo_signalsToIgnore = []os.Signal{os.Interrupt, syscall.SIGQUIT}

// signalTrace is the signal to send to make a Go program
// crash with a stack trace.
var cmdgo_signalTrace os.Signal = syscall.SIGQUIT

// Break init loop.
func init() {
	cmdgo_cmdTest.Run = cmdgo_runTest
}

const cmdgo_testUsage = "test [build/test flags] [packages] [build/test flags & test binary flags]"

var cmdgo_cmdTest = &cmdgo_Command{
	CustomFlags: true,
	UsageLine:   cmdgo_testUsage,
	Short:       "test packages",
	Long: `
'Go test' automates testing the packages named by the import paths.
It prints a summary of the test results in the format:

	ok   archive/tar   0.011s
	FAIL archive/zip   0.022s
	ok   compress/gzip 0.033s
	...

followed by detailed output for each failed package.

'Go test' recompiles each package along with any files with names matching
the file pattern "*_test.go".
Files whose names begin with "_" (including "_test.go") or "." are ignored.
These additional files can contain test functions, benchmark functions, and
example functions.  See 'go help testfunc' for more.
Each listed package causes the execution of a separate test binary.

Test files that declare a package with the suffix "_test" will be compiled as a
separate package, and then linked and run with the main test binary.

The go tool will ignore a directory named "testdata", making it available
to hold ancillary data needed by the tests.

By default, go test needs no arguments.  It compiles and tests the package
with source in the current directory, including tests, and runs the tests.

The package is built in a temporary directory so it does not interfere with the
non-test installation.

` + strings.TrimSpace(cmdgo_testFlag1) + ` See 'go help testflag' for details.

For more about build flags, see 'go help build'.
For more about specifying packages, see 'go help packages'.

See also: go build, go vet.
`,
}

const cmdgo_testFlag1 = `
In addition to the build flags, the flags handled by 'go test' itself are:

	-args
	    Pass the remainder of the command line (everything after -args)
	    to the test binary, uninterpreted and unchanged.
	    Because this flag consumes the remainder of the command line,
	    the package list (if present) must appear before this flag.

	-c
	    Compile the test binary to pkg.test but do not run it
	    (where pkg is the last element of the package's import path).
	    The file name can be changed with the -o flag.

	-exec xprog
	    Run the test binary using xprog. The behavior is the same as
	    in 'go run'. See 'go help run' for details.

	-i
	    Install packages that are dependencies of the test.
	    Do not run the test.

	-o file
	    Compile the test binary to the named file.
	    The test still runs (unless -c or -i is specified).

The test binary also accepts flags that control execution of the test; these
flags are also accessible by 'go test'.
`

var cmdgo_helpTestflag = &cmdgo_Command{
	UsageLine: "testflag",
	Short:     "description of testing flags",
	Long: `
The 'go test' command takes both flags that apply to 'go test' itself
and flags that apply to the resulting test binary.

Several of the flags control profiling and write an execution profile
suitable for "go tool pprof"; run "go tool pprof -h" for more
information.  The --alloc_space, --alloc_objects, and --show_bytes
options of pprof control how the information is presented.

The following flags are recognized by the 'go test' command and
control the execution of any test:

	` + strings.TrimSpace(cmdgo_testFlag2) + `
`,
}

const cmdgo_testFlag2 = `
	-bench regexp
	    Run (sub)benchmarks matching a regular expression.
	    The given regular expression is split into smaller ones by
	    top-level '/', where each must match the corresponding part of a
	    benchmark's identifier.
	    By default, no benchmarks run. To run all benchmarks,
	    use '-bench .' or '-bench=.'.

	-benchmem
	    Print memory allocation statistics for benchmarks.

	-benchtime t
	    Run enough iterations of each benchmark to take t, specified
	    as a time.Duration (for example, -benchtime 1h30s).
	    The default is 1 second (1s).

	-blockprofile block.out
	    Write a goroutine blocking profile to the specified file
	    when all tests are complete.
	    Writes test binary as -c would.

	-blockprofilerate n
	    Control the detail provided in goroutine blocking profiles by
	    calling runtime.SetBlockProfileRate with n.
	    See 'go doc runtime.SetBlockProfileRate'.
	    The profiler aims to sample, on average, one blocking event every
	    n nanoseconds the program spends blocked.  By default,
	    if -test.blockprofile is set without this flag, all blocking events
	    are recorded, equivalent to -test.blockprofilerate=1.

	-count n
	    Run each test and benchmark n times (default 1).
	    If -cpu is set, run n times for each GOMAXPROCS value.
	    Examples are always run once.

	-cover
	    Enable coverage analysis.

	-covermode set,count,atomic
	    Set the mode for coverage analysis for the package[s]
	    being tested. The default is "set" unless -race is enabled,
	    in which case it is "atomic".
	    The values:
		set: bool: does this statement run?
		count: int: how many times does this statement run?
		atomic: int: count, but correct in multithreaded tests;
			significantly more expensive.
	    Sets -cover.

	-coverpkg pkg1,pkg2,pkg3
	    Apply coverage analysis in each test to the given list of packages.
	    The default is for each test to analyze only the package being tested.
	    Packages are specified as import paths.
	    Sets -cover.

	-coverprofile cover.out
	    Write a coverage profile to the file after all tests have passed.
	    Sets -cover.

	-cpu 1,2,4
	    Specify a list of GOMAXPROCS values for which the tests or
	    benchmarks should be executed.  The default is the current value
	    of GOMAXPROCS.

	-cpuprofile cpu.out
	    Write a CPU profile to the specified file before exiting.
	    Writes test binary as -c would.

	-memprofile mem.out
	    Write a memory profile to the file after all tests have passed.
	    Writes test binary as -c would.

	-memprofilerate n
	    Enable more precise (and expensive) memory profiles by setting
	    runtime.MemProfileRate.  See 'go doc runtime.MemProfileRate'.
	    To profile all memory allocations, use -test.memprofilerate=1
	    and pass --alloc_space flag to the pprof tool.

	-outputdir directory
	    Place output files from profiling in the specified directory,
	    by default the directory in which "go test" is running.

	-parallel n
	    Allow parallel execution of test functions that call t.Parallel.
	    The value of this flag is the maximum number of tests to run
	    simultaneously; by default, it is set to the value of GOMAXPROCS.
	    Note that -parallel only applies within a single test binary.
	    The 'go test' command may run tests for different packages
	    in parallel as well, according to the setting of the -p flag
	    (see 'go help build').

	-run regexp
	    Run only those tests and examples matching the regular expression.
	    For tests the regular expression is split into smaller ones by
	    top-level '/', where each must match the corresponding part of a
	    test's identifier.

	-short
	    Tell long-running tests to shorten their run time.
	    It is off by default but set during all.bash so that installing
	    the Go tree can run a sanity check but not spend time running
	    exhaustive tests.

	-timeout t
	    If a test runs longer than t, panic.
	    The default is 10 minutes (10m).

	-trace trace.out
	    Write an execution trace to the specified file before exiting.

	-v
	    Verbose output: log all tests as they are run. Also print all
	    text from Log and Logf calls even if the test succeeds.

Each of these flags is also recognized with an optional 'test.' prefix,
as in -test.v. When invoking the generated test binary (the result of
'go test -c') directly, however, the prefix is mandatory.

The 'go test' command rewrites or removes recognized flags,
as appropriate, both before and after the optional package list,
before invoking the test binary.

For instance, the command

	go test -v -myflag testdata -cpuprofile=prof.out -x

will compile the test binary and then run it as

	pkg.test -test.v -myflag testdata -test.cpuprofile=prof.out

(The -x flag is removed because it applies only to the go command's
execution, not to the test itself.)

The test flags that generate profiles (other than for coverage) also
leave the test binary in pkg.test for use when analyzing the profiles.

When 'go test' runs a test binary, it does so from within the
corresponding package's source code directory. Depending on the test,
it may be necessary to do the same when invoking a generated test
binary directly.

The command-line package list, if present, must appear before any
flag not known to the go test command. Continuing the example above,
the package list would have to appear before -myflag, but could appear
on either side of -v.

To keep an argument for a test binary from being interpreted as a
known flag or a package name, use -args (see 'go help test') which
passes the remainder of the command line through to the test binary
uninterpreted and unaltered.

For instance, the command

	go test -v -args -x -v

will compile the test binary and then run it as

	pkg.test -test.v -x -v

Similarly,

	go test -args math

will compile the test binary and then run it as

	pkg.test math

In the first example, the -x and the second -v are passed through to the
test binary unchanged and with no effect on the go command itself.
In the second example, the argument math is passed through to the test
binary, instead of being interpreted as the package list.
`

var cmdgo_helpTestfunc = &cmdgo_Command{
	UsageLine: "testfunc",
	Short:     "description of testing functions",
	Long: `
The 'go test' command expects to find test, benchmark, and example functions
in the "*_test.go" files corresponding to the package under test.

A test function is one named TestXXX (where XXX is any alphanumeric string
not starting with a lower case letter) and should have the signature,

	func TestXXX(t *testing.T) { ... }

A benchmark function is one named BenchmarkXXX and should have the signature,

	func BenchmarkXXX(b *testing.B) { ... }

An example function is similar to a test function but, instead of using
*testing.T to report success or failure, prints output to os.Stdout.
If the last comment in the function starts with "Output:" then the output
is compared exactly against the comment (see examples below). If the last
comment begins with "Unordered output:" then the output is compared to the
comment, however the order of the lines is ignored. An example with no such
comment, or with no text after "Output:" is compiled but not executed.

Godoc displays the body of ExampleXXX to demonstrate the use
of the function, constant, or variable XXX.  An example of a method M with
receiver type T or *T is named ExampleT_M.  There may be multiple examples
for a given function, constant, or variable, distinguished by a trailing _xxx,
where xxx is a suffix not beginning with an upper case letter.

Here is an example of an example:

	func ExamplePrintln() {
		Println("The output of\nthis example.")
		// Output: The output of
		// this example.
	}

Here is another example where the ordering of the output is ignored:

	func ExamplePerm() {
		for _, value := range Perm(4) {
			fmt.Println(value)
		}

		// Unordered output: 4
		// 2
		// 1
		// 3
		// 0
	}

The entire test file is presented as the example when it contains a single
example function, at least one other function, type, variable, or constant
declaration, and no test or benchmark functions.

See the documentation of the testing package for more information.
`,
}

var (
	cmdgo_testC            bool             // -c flag
	cmdgo_testCover        bool             // -cover flag
	cmdgo_testCoverMode    string           // -covermode flag
	cmdgo_testCoverPaths   []string         // -coverpkg flag
	cmdgo_testCoverPkgs    []*cmdgo_Package // -coverpkg flag
	cmdgo_testO            string           // -o flag
	cmdgo_testProfile      bool             // some profiling flag
	cmdgo_testNeedBinary   bool             // profile needs to keep binary around
	cmdgo_testV            bool             // -v flag
	cmdgo_testTimeout      string           // -timeout flag
	cmdgo_testArgs         []string
	cmdgo_testBench        bool
	cmdgo_testStreamOutput bool // show output as it is generated
	cmdgo_testShowPass     bool // show passing output

	cmdgo_testKillTimeout = 10 * time.Minute
)

var cmdgo_testMainDeps = map[string]bool{

	"testing": true,
	"regexp":  true,
	"os":      true,
}

func cmdgo_runTest(cmd *cmdgo_Command, args []string) {
	var pkgArgs []string
	pkgArgs, cmdgo_testArgs = cmdgo_testFlags(args)

	cmdgo_findExecCmd()

	cmdgo_instrumentInit()
	cmdgo_buildModeInit()
	pkgs := cmdgo_packagesForBuild(pkgArgs)
	if len(pkgs) == 0 {
		cmdgo_fatalf("no packages to test")
	}

	if cmdgo_testC && len(pkgs) != 1 {
		cmdgo_fatalf("cannot use -c flag with multiple packages")
	}
	if cmdgo_testO != "" && len(pkgs) != 1 {
		cmdgo_fatalf("cannot use -o flag with multiple packages")
	}
	if cmdgo_testProfile && len(pkgs) != 1 {
		cmdgo_fatalf("cannot use test profile flag with multiple packages")
	}

	if dt, err := time.ParseDuration(cmdgo_testTimeout); err == nil && dt > 0 {
		cmdgo_testKillTimeout = dt + 1*time.Minute
	}

	cmdgo_testShowPass = cmdgo_testV

	cmdgo_testStreamOutput = len(pkgArgs) == 0 || cmdgo_testBench ||
		(cmdgo_testShowPass && (len(pkgs) == 1 || cmdgo_buildP == 1))

	var b cmdgo_builder
	b.init()

	if cmdgo_buildI {
		cmdgo_buildV = cmdgo_testV

		deps := make(map[string]bool)
		for dep := range cmdgo_testMainDeps {
			deps[dep] = true
		}

		for _, p := range pkgs {

			for _, path := range p.Imports {
				deps[path] = true
			}
			for _, path := range p.vendored(p.TestImports) {
				deps[path] = true
			}
			for _, path := range p.vendored(p.XTestImports) {
				deps[path] = true
			}
		}

		if deps["C"] {
			delete(deps, "C")
			deps["runtime/cgo"] = true
			if cmdgo_goos == runtime.GOOS && cmdgo_goarch == runtime.GOARCH && !cmdgo_buildRace && !cmdgo_buildMSan {
				deps["cmd/cgo"] = true
			}
		}

		delete(deps, "unsafe")

		all := []string{}
		for path := range deps {
			if !build.IsLocalImport(path) {
				all = append(all, path)
			}
		}
		sort.Strings(all)

		a := &cmdgo_action{}
		for _, p := range cmdgo_packagesForBuild(all) {
			a.deps = append(a.deps, b.action(cmdgo_modeInstall, cmdgo_modeInstall, p))
		}
		b.do(a)
		if !cmdgo_testC || a.failed {
			return
		}
		b.init()
	}

	var builds, runs, prints []*cmdgo_action

	if cmdgo_testCoverPaths != nil {

		cmdgo_testCoverPkgs = cmdgo_packagesForBuild(cmdgo_testCoverPaths)

		used := make(map[string]bool)
		for _, p := range pkgs {
			used[p.ImportPath] = true
			for _, dep := range p.Deps {
				used[dep] = true
			}
		}
		for _, p := range cmdgo_testCoverPkgs {
			if !used[p.ImportPath] {
				fmt.Fprintf(os.Stderr, "warning: no packages being tested depend on %s\n", p.ImportPath)
			}
		}

		for _, p := range cmdgo_testCoverPkgs {

			if p.ImportPath == "unsafe" {
				continue
			}
			p.Stale = true
			p.StaleReason = "rebuild for coverage"
			p.fake = true
			p.coverMode = cmdgo_testCoverMode
			var coverFiles []string
			coverFiles = append(coverFiles, p.GoFiles...)
			coverFiles = append(coverFiles, p.CgoFiles...)
			coverFiles = append(coverFiles, p.TestGoFiles...)
			p.coverVars = cmdgo_declareCoverVars(p.ImportPath, coverFiles...)
		}
	}

	for _, p := range pkgs {
		buildTest, runTest, printTest, err := b.test(p)
		if err != nil {
			str := err.Error()
			if strings.HasPrefix(str, "\n") {
				str = str[1:]
			}
			failed := fmt.Sprintf("FAIL\t%s [setup failed]\n", p.ImportPath)

			if p.ImportPath != "" {
				cmdgo_errorf("# %s\n%s\n%s", p.ImportPath, str, failed)
			} else {
				cmdgo_errorf("%s\n%s", str, failed)
			}
			continue
		}
		builds = append(builds, buildTest)
		runs = append(runs, runTest)
		prints = append(prints, printTest)
	}

	root := &cmdgo_action{deps: prints}

	for i, a := range prints {
		if i > 0 {
			a.deps = append(a.deps, prints[i-1])
		}
	}

	if !cmdgo_testC && cmdgo_testBench {

		for i, run := range runs {
			if i == 0 {
				run.deps = append(run.deps, builds...)
			} else {
				run.deps = append(run.deps, prints[i-1])
			}
		}
	}

	okBuild := map[*cmdgo_Package]bool{}
	for _, p := range pkgs {
		okBuild[p] = true
	}
	warned := false
	for _, a := range cmdgo_actionList(root) {
		if a.p == nil || okBuild[a.p] {
			continue
		}
		okBuild[a.p] = true

		for _, p1 := range a.p.imports {
			if p1.fake {
				a.p.fake = true
			}
		}

		if a.f != nil && !okBuild[a.p] && !a.p.fake && !a.p.local {
			if !warned {
				fmt.Fprintf(os.Stderr, "warning: building out-of-date packages:\n")
				warned = true
			}
			fmt.Fprintf(os.Stderr, "\t%s\n", a.p.ImportPath)
		}
	}
	if warned {
		args := strings.Join(pkgArgs, " ")
		if args != "" {
			args = " " + args
		}
		extraOpts := ""
		if cmdgo_buildRace {
			extraOpts = "-race "
		}
		if cmdgo_buildMSan {
			extraOpts = "-msan "
		}
		fmt.Fprintf(os.Stderr, "installing these packages with 'go test %s-i%s' will speed future tests.\n\n", extraOpts, args)
	}

	b.do(root)
}

func cmdgo_contains(x []string, s string) bool {
	for _, t := range x {
		if t == s {
			return true
		}
	}
	return false
}

var cmdgo_windowsBadWords = []string{
	"install",
	"patch",
	"setup",
	"update",
}

func (b *cmdgo_builder) test(p *cmdgo_Package) (buildAction, runAction, printAction *cmdgo_action, err error) {
	if len(p.TestGoFiles)+len(p.XTestGoFiles) == 0 {
		build := b.action(cmdgo_modeBuild, cmdgo_modeBuild, p)
		run := &cmdgo_action{p: p, deps: []*cmdgo_action{build}}
		print := &cmdgo_action{f: (*cmdgo_builder).notest, p: p, deps: []*cmdgo_action{run}}
		return build, run, print, nil
	}

	// Build Package structs describing:
	//	ptest - package + test files
	//	pxtest - package of external test files
	//	pmain - pkg.test binary
	var ptest, pxtest, pmain *cmdgo_Package

	var imports, ximports []*cmdgo_Package
	var stk cmdgo_importStack
	stk.push(p.ImportPath + " (test)")
	for i, path := range p.TestImports {
		p1 := cmdgo_loadImport(path, p.Dir, p, &stk, p.build.TestImportPos[path], cmdgo_useVendor)
		if p1.Error != nil {
			return nil, nil, nil, p1.Error
		}
		if len(p1.DepsErrors) > 0 {
			err := p1.DepsErrors[0]
			err.Pos = ""
			return nil, nil, nil, err
		}
		if cmdgo_contains(p1.Deps, p.ImportPath) || p1.ImportPath == p.ImportPath {

			err := &cmdgo_PackageError{
				ImportStack:   cmdgo_testImportStack(stk[0], p1, p.ImportPath),
				Err:           "import cycle not allowed in test",
				isImportCycle: true,
			}
			return nil, nil, nil, err
		}
		p.TestImports[i] = p1.ImportPath
		imports = append(imports, p1)
	}
	stk.pop()
	stk.push(p.ImportPath + "_test")
	pxtestNeedsPtest := false
	for i, path := range p.XTestImports {
		p1 := cmdgo_loadImport(path, p.Dir, p, &stk, p.build.XTestImportPos[path], cmdgo_useVendor)
		if p1.Error != nil {
			return nil, nil, nil, p1.Error
		}
		if len(p1.DepsErrors) > 0 {
			err := p1.DepsErrors[0]
			err.Pos = ""
			return nil, nil, nil, err
		}
		if p1.ImportPath == p.ImportPath {
			pxtestNeedsPtest = true
		} else {
			ximports = append(ximports, p1)
		}
		p.XTestImports[i] = p1.ImportPath
	}
	stk.pop()

	// Use last element of import path, not package name.
	// They differ when package name is "main".
	// But if the import path is "command-line-arguments",
	// like it is during 'go run', use the package name.
	var elem string
	if p.ImportPath == "command-line-arguments" {
		elem = p.Name
	} else {
		_, elem = path.Split(p.ImportPath)
	}
	testBinary := elem + ".test"

	testDir := filepath.Join(b.work, filepath.FromSlash(p.ImportPath+"/_test"))
	ptestObj := cmdgo_buildToolchain.pkgpath(testDir, p)

	ptestDir, _ := filepath.Split(ptestObj)
	if err := b.mkdir(ptestDir); err != nil {
		return nil, nil, nil, err
	}

	localCover := cmdgo_testCover && cmdgo_testCoverPaths == nil

	if len(p.TestGoFiles) > 0 || localCover || p.Name == "main" {
		ptest = new(cmdgo_Package)
		*ptest = *p
		ptest.GoFiles = nil
		ptest.GoFiles = append(ptest.GoFiles, p.GoFiles...)
		ptest.GoFiles = append(ptest.GoFiles, p.TestGoFiles...)
		ptest.target = ""
		ptest.Imports = cmdgo_stringList(p.Imports, p.TestImports)
		ptest.imports = append(append([]*cmdgo_Package{}, p.imports...), imports...)
		ptest.pkgdir = testDir
		ptest.fake = true
		ptest.forceLibrary = true
		ptest.Stale = true
		ptest.StaleReason = "rebuild for test"
		ptest.build = new(build.Package)
		*ptest.build = *p.build
		m := map[string][]token.Position{}
		for k, v := range p.build.ImportPos {
			m[k] = append(m[k], v...)
		}
		for k, v := range p.build.TestImportPos {
			m[k] = append(m[k], v...)
		}
		ptest.build.ImportPos = m

		if localCover {
			ptest.coverMode = cmdgo_testCoverMode
			var coverFiles []string
			coverFiles = append(coverFiles, ptest.GoFiles...)
			coverFiles = append(coverFiles, ptest.CgoFiles...)
			ptest.coverVars = cmdgo_declareCoverVars(ptest.ImportPath, coverFiles...)
		}
	} else {
		ptest = p
	}

	if len(p.XTestGoFiles) > 0 {
		pxtest = &cmdgo_Package{
			Name:        p.Name + "_test",
			ImportPath:  p.ImportPath + "_test",
			localPrefix: p.localPrefix,
			Root:        p.Root,
			Dir:         p.Dir,
			GoFiles:     p.XTestGoFiles,
			Imports:     p.XTestImports,
			build: &build.Package{
				ImportPos: p.build.XTestImportPos,
			},
			imports:  ximports,
			pkgdir:   testDir,
			fake:     true,
			external: true,
			Stale:    true,
		}
		if pxtestNeedsPtest {
			pxtest.imports = append(pxtest.imports, ptest)
		}
	}

	pmain = &cmdgo_Package{
		Name:       "main",
		Dir:        testDir,
		GoFiles:    []string{"_testmain.go"},
		ImportPath: "testmain",
		Root:       p.Root,
		build:      &build.Package{Name: "main"},
		pkgdir:     testDir,
		fake:       true,
		Stale:      true,
		omitDWARF:  !cmdgo_testC && !cmdgo_testNeedBinary,
	}

	stk.push("testmain")
	for dep := range cmdgo_testMainDeps {
		if dep == ptest.ImportPath {
			pmain.imports = append(pmain.imports, ptest)
		} else {
			p1 := cmdgo_loadImport(dep, "", nil, &stk, nil, 0)
			if p1.Error != nil {
				return nil, nil, nil, p1.Error
			}
			pmain.imports = append(pmain.imports, p1)
		}
	}

	if cmdgo_testCoverPkgs != nil {

		seen := map[*cmdgo_Package]bool{p: true, ptest: true}
		for _, p1 := range pmain.imports {
			seen[p1] = true
		}
		for _, p1 := range cmdgo_testCoverPkgs {
			if !seen[p1] {
				seen[p1] = true
				pmain.imports = append(pmain.imports, p1)
			}
		}
	}

	t, err := cmdgo_loadTestFuncs(ptest)
	if err != nil {
		return nil, nil, nil, err
	}
	if len(ptest.GoFiles) > 0 {
		pmain.imports = append(pmain.imports, ptest)
		t.ImportTest = true
	}
	if pxtest != nil {
		pmain.imports = append(pmain.imports, pxtest)
		t.ImportXtest = true
	}

	if ptest != p && localCover {

		cmdgo_recompileForTest(pmain, p, ptest, testDir)
	}

	if cmdgo_buildContext.GOOS == "darwin" {
		if cmdgo_buildContext.GOARCH == "arm" || cmdgo_buildContext.GOARCH == "arm64" {
			t.NeedCgo = true
		}
	}

	for _, cp := range pmain.imports {
		if len(cp.coverVars) > 0 {
			t.Cover = append(t.Cover, cmdgo_coverInfo{cp, cp.coverVars})
		}
	}

	if !cmdgo_buildN {

		if err := cmdgo_writeTestmain(filepath.Join(testDir, "_testmain.go"), t); err != nil {
			return nil, nil, nil, err
		}
	}

	cmdgo_computeStale(pmain)

	if ptest != p {
		a := b.action(cmdgo_modeBuild, cmdgo_modeBuild, ptest)
		a.objdir = testDir + string(filepath.Separator) + "_obj_test" + string(filepath.Separator)
		a.objpkg = ptestObj
		a.target = ptestObj
		a.link = false
	}

	if pxtest != nil {
		a := b.action(cmdgo_modeBuild, cmdgo_modeBuild, pxtest)
		a.objdir = testDir + string(filepath.Separator) + "_obj_xtest" + string(filepath.Separator)
		a.objpkg = cmdgo_buildToolchain.pkgpath(testDir, pxtest)
		a.target = a.objpkg
	}

	a := b.action(cmdgo_modeBuild, cmdgo_modeBuild, pmain)
	a.objdir = testDir + string(filepath.Separator)
	a.objpkg = filepath.Join(testDir, "main.a")
	a.target = filepath.Join(testDir, testBinary) + cmdgo_exeSuffix
	if cmdgo_goos == "windows" {

		for _, bad := range cmdgo_windowsBadWords {
			if strings.Contains(testBinary, bad) {
				a.target = filepath.Join(testDir, "test.test") + cmdgo_exeSuffix
				break
			}
		}
	}
	buildAction = a

	if cmdgo_testC || cmdgo_testNeedBinary {

		target := filepath.Join(cmdgo_cwd, testBinary+cmdgo_exeSuffix)
		if cmdgo_testO != "" {
			target = cmdgo_testO
			if !filepath.IsAbs(target) {
				target = filepath.Join(cmdgo_cwd, target)
			}
		}
		buildAction = &cmdgo_action{
			f:      (*cmdgo_builder).install,
			deps:   []*cmdgo_action{buildAction},
			p:      pmain,
			target: target,
		}
		runAction = buildAction
	}
	if cmdgo_testC {
		printAction = &cmdgo_action{p: p, deps: []*cmdgo_action{runAction}}
	} else {

		runAction = &cmdgo_action{
			f:          (*cmdgo_builder).runTest,
			deps:       []*cmdgo_action{buildAction},
			p:          p,
			ignoreFail: true,
		}
		cleanAction := &cmdgo_action{
			f:    (*cmdgo_builder).cleanTest,
			deps: []*cmdgo_action{runAction},
			p:    p,
		}
		printAction = &cmdgo_action{
			f:    (*cmdgo_builder).printTest,
			deps: []*cmdgo_action{cleanAction},
			p:    p,
		}
	}

	return buildAction, runAction, printAction, nil
}

func cmdgo_testImportStack(top string, p *cmdgo_Package, target string) []string {
	stk := []string{top, p.ImportPath}
Search:
	for p.ImportPath != target {
		for _, p1 := range p.imports {
			if p1.ImportPath == target || cmdgo_contains(p1.Deps, target) {
				stk = append(stk, p1.ImportPath)
				p = p1
				continue Search
			}
		}

		stk = append(stk, "<lost path to cycle>")
		break
	}
	return stk
}

func cmdgo_recompileForTest(pmain, preal, ptest *cmdgo_Package, testDir string) {

	testCopy := map[*cmdgo_Package]*cmdgo_Package{preal: ptest}
	for _, p := range cmdgo_packageList([]*cmdgo_Package{pmain}) {

		didSplit := false
		split := func() {
			if didSplit {
				return
			}
			didSplit = true
			if p.pkgdir != testDir {
				p1 := new(cmdgo_Package)
				testCopy[p] = p1
				*p1 = *p
				p1.imports = make([]*cmdgo_Package, len(p.imports))
				copy(p1.imports, p.imports)
				p = p1
				p.pkgdir = testDir
				p.target = ""
				p.fake = true
				p.Stale = true
				p.StaleReason = "depends on package being tested"
			}
		}

		for i, dep := range p.deps {
			if p1 := testCopy[dep]; p1 != nil && p1 != dep {
				split()
				p.deps[i] = p1
			}
		}
		for i, imp := range p.imports {
			if p1 := testCopy[imp]; p1 != nil && p1 != imp {
				split()
				p.imports[i] = p1
			}
		}
	}
}

var cmdgo_coverIndex = 0

// isTestFile reports whether the source file is a set of tests and should therefore
// be excluded from coverage analysis.
func cmdgo_isTestFile(file string) bool {

	return strings.HasSuffix(file, "_test.go")
}

// declareCoverVars attaches the required cover variables names
// to the files, to be used when annotating the files.
func cmdgo_declareCoverVars(importPath string, files ...string) map[string]*cmdgo_CoverVar {
	coverVars := make(map[string]*cmdgo_CoverVar)
	for _, file := range files {
		if cmdgo_isTestFile(file) {
			continue
		}
		coverVars[file] = &cmdgo_CoverVar{
			File: filepath.Join(importPath, file),
			Var:  fmt.Sprintf("GoCover_%d", cmdgo_coverIndex),
		}
		cmdgo_coverIndex++
	}
	return coverVars
}

// runTest is the action for running a test binary.
func (b *cmdgo_builder) runTest(a *cmdgo_action) error {
	args := cmdgo_stringList(cmdgo_findExecCmd(), a.deps[0].target, cmdgo_testArgs)
	a.testOutput = new(bytes.Buffer)

	if cmdgo_buildN || cmdgo_buildX {
		b.showcmd("", "%s", strings.Join(args, " "))
		if cmdgo_buildN {
			return nil
		}
	}

	if a.failed {

		a.failed = false
		fmt.Fprintf(a.testOutput, "FAIL\t%s [build failed]\n", a.p.ImportPath)
		cmdgo_setExitStatus(1)
		return nil
	}

	cmd := exec.Command(args[0], args[1:]...)
	cmd.Dir = a.p.Dir
	cmd.Env = cmdgo_envForDir(cmd.Dir, cmdgo_origEnv)
	var buf bytes.Buffer
	if cmdgo_testStreamOutput {
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
	} else {
		cmd.Stdout = &buf
		cmd.Stderr = &buf
	}

	if a.p.usesSwig() {
		env := cmd.Env
		found := false
		prefix := "LD_LIBRARY_PATH="
		for i, v := range env {
			if strings.HasPrefix(v, prefix) {
				env[i] = v + ":."
				found = true
				break
			}
		}
		if !found {
			env = append(env, "LD_LIBRARY_PATH=.")
		}
		cmd.Env = env
	}

	t0 := time.Now()
	err := cmd.Start()

	if err == nil {
		tick := time.NewTimer(cmdgo_testKillTimeout)
		cmdgo_startSigHandlers()
		done := make(chan error)
		go func() {
			done <- cmd.Wait()
		}()
	Outer:
		select {
		case err = <-done:

		case <-tick.C:
			if cmdgo_signalTrace != nil {

				cmd.Process.Signal(cmdgo_signalTrace)
				select {
				case err = <-done:
					fmt.Fprintf(&buf, "*** Test killed with %v: ran too long (%v).\n", cmdgo_signalTrace, cmdgo_testKillTimeout)
					break Outer
				case <-time.After(5 * time.Second):
				}
			}
			cmd.Process.Kill()
			err = <-done
			fmt.Fprintf(&buf, "*** Test killed: ran too long (%v).\n", cmdgo_testKillTimeout)
		}
		tick.Stop()
	}
	out := buf.Bytes()
	t := fmt.Sprintf("%.3fs", time.Since(t0).Seconds())
	if err == nil {
		if cmdgo_testShowPass {
			a.testOutput.Write(out)
		}
		fmt.Fprintf(a.testOutput, "ok  \t%s\t%s%s\n", a.p.ImportPath, t, cmdgo_coveragePercentage(out))
		return nil
	}

	cmdgo_setExitStatus(1)
	if len(out) > 0 {
		a.testOutput.Write(out)

	} else {
		fmt.Fprintf(a.testOutput, "%s\n", err)
	}
	fmt.Fprintf(a.testOutput, "FAIL\t%s\t%s\n", a.p.ImportPath, t)

	return nil
}

// coveragePercentage returns the coverage results (if enabled) for the
// test. It uncovers the data by scanning the output from the test run.
func cmdgo_coveragePercentage(out []byte) string {
	if !cmdgo_testCover {
		return ""
	}

	re := regexp.MustCompile(`coverage: (.*)\n`)
	matches := re.FindSubmatch(out)
	if matches == nil {

		return ""
	}
	return fmt.Sprintf("\tcoverage: %s", matches[1])
}

// cleanTest is the action for cleaning up after a test.
func (b *cmdgo_builder) cleanTest(a *cmdgo_action) error {
	if cmdgo_buildWork {
		return nil
	}
	run := a.deps[0]
	testDir := filepath.Join(b.work, filepath.FromSlash(run.p.ImportPath+"/_test"))
	os.RemoveAll(testDir)
	return nil
}

// printTest is the action for printing a test result.
func (b *cmdgo_builder) printTest(a *cmdgo_action) error {
	clean := a.deps[0]
	run := clean.deps[0]
	os.Stdout.Write(run.testOutput.Bytes())
	run.testOutput = nil
	return nil
}

// notest is the action for testing a package with no test files.
func (b *cmdgo_builder) notest(a *cmdgo_action) error {
	fmt.Printf("?   \t%s\t[no test files]\n", a.p.ImportPath)
	return nil
}

// isTestFunc tells whether fn has the type of a testing function. arg
// specifies the parameter type we look for: B, M or T.
func cmdgo_isTestFunc(fn *ast.FuncDecl, arg string) bool {
	if fn.Type.Results != nil && len(fn.Type.Results.List) > 0 ||
		fn.Type.Params.List == nil ||
		len(fn.Type.Params.List) != 1 ||
		len(fn.Type.Params.List[0].Names) > 1 {
		return false
	}
	ptr, ok := fn.Type.Params.List[0].Type.(*ast.StarExpr)
	if !ok {
		return false
	}

	if name, ok := ptr.X.(*ast.Ident); ok && name.Name == arg {
		return true
	}
	if sel, ok := ptr.X.(*ast.SelectorExpr); ok && sel.Sel.Name == arg {
		return true
	}
	return false
}

// isTest tells whether name looks like a test (or benchmark, according to prefix).
// It is a Test (say) if there is a character after Test that is not a lower-case letter.
// We don't want TesticularCancer.
func cmdgo_isTest(name, prefix string) bool {
	if !strings.HasPrefix(name, prefix) {
		return false
	}
	if len(name) == len(prefix) {
		return true
	}
	rune, _ := utf8.DecodeRuneInString(name[len(prefix):])
	return !unicode.IsLower(rune)
}

type cmdgo_coverInfo struct {
	Package *cmdgo_Package
	Vars    map[string]*cmdgo_CoverVar
}

// loadTestFuncs returns the testFuncs describing the tests that will be run.
func cmdgo_loadTestFuncs(ptest *cmdgo_Package) (*cmdgo_testFuncs, error) {
	t := &cmdgo_testFuncs{
		Package: ptest,
	}
	for _, file := range ptest.TestGoFiles {
		if err := t.load(filepath.Join(ptest.Dir, file), "_test", &t.ImportTest, &t.NeedTest); err != nil {
			return nil, err
		}
	}
	for _, file := range ptest.XTestGoFiles {
		if err := t.load(filepath.Join(ptest.Dir, file), "_xtest", &t.ImportXtest, &t.NeedXtest); err != nil {
			return nil, err
		}
	}
	return t, nil
}

// writeTestmain writes the _testmain.go file for t to the file named out.
func cmdgo_writeTestmain(out string, t *cmdgo_testFuncs) error {
	f, err := os.Create(out)
	if err != nil {
		return err
	}
	defer f.Close()

	if err := cmdgo_testmainTmpl.Execute(f, t); err != nil {
		return err
	}

	return nil
}

type cmdgo_testFuncs struct {
	Tests       []cmdgo_testFunc
	Benchmarks  []cmdgo_testFunc
	Examples    []cmdgo_testFunc
	TestMain    *cmdgo_testFunc
	Package     *cmdgo_Package
	ImportTest  bool
	NeedTest    bool
	ImportXtest bool
	NeedXtest   bool
	NeedCgo     bool
	Cover       []cmdgo_coverInfo
}

func (t *cmdgo_testFuncs) CoverMode() string {
	return cmdgo_testCoverMode
}

func (t *cmdgo_testFuncs) CoverEnabled() bool {
	return cmdgo_testCover
}

// Covered returns a string describing which packages are being tested for coverage.
// If the covered package is the same as the tested package, it returns the empty string.
// Otherwise it is a comma-separated human-readable list of packages beginning with
// " in", ready for use in the coverage message.
func (t *cmdgo_testFuncs) Covered() string {
	if cmdgo_testCoverPaths == nil {
		return ""
	}
	return " in " + strings.Join(cmdgo_testCoverPaths, ", ")
}

// Tested returns the name of the package being tested.
func (t *cmdgo_testFuncs) Tested() string {
	return t.Package.Name
}

type cmdgo_testFunc struct {
	Package   string // imported package name (_test or _xtest)
	Name      string // function name
	Output    string // output, for examples
	Unordered bool   // output is allowed to be unordered.
}

var cmdgo_testFileSet = token.NewFileSet()

func (t *cmdgo_testFuncs) load(filename, pkg string, doImport, seen *bool) error {
	f, err := parser.ParseFile(cmdgo_testFileSet, filename, nil, parser.ParseComments)
	if err != nil {
		return cmdgo_expandScanner(err)
	}
	for _, d := range f.Decls {
		n, ok := d.(*ast.FuncDecl)
		if !ok {
			continue
		}
		if n.Recv != nil {
			continue
		}
		name := n.Name.String()
		switch {
		case name == "TestMain" && cmdgo_isTestFunc(n, "M"):
			if t.TestMain != nil {
				return errors.New("multiple definitions of TestMain")
			}
			t.TestMain = &cmdgo_testFunc{pkg, name, "", false}
			*doImport, *seen = true, true
		case cmdgo_isTest(name, "Test"):
			err := cmdgo_checkTestFunc(n, "T")
			if err != nil {
				return err
			}
			t.Tests = append(t.Tests, cmdgo_testFunc{pkg, name, "", false})
			*doImport, *seen = true, true
		case cmdgo_isTest(name, "Benchmark"):
			err := cmdgo_checkTestFunc(n, "B")
			if err != nil {
				return err
			}
			t.Benchmarks = append(t.Benchmarks, cmdgo_testFunc{pkg, name, "", false})
			*doImport, *seen = true, true
		}
	}
	ex := doc.Examples(f)
	sort.Sort(cmdgo_byOrder(ex))
	for _, e := range ex {
		*doImport = true
		if e.Output == "" && !e.EmptyOutput {

			continue
		}
		t.Examples = append(t.Examples, cmdgo_testFunc{pkg, "Example" + e.Name, e.Output, e.Unordered})
		*seen = true
	}
	return nil
}

func cmdgo_checkTestFunc(fn *ast.FuncDecl, arg string) error {
	if !cmdgo_isTestFunc(fn, arg) {
		name := fn.Name.String()
		pos := cmdgo_testFileSet.Position(fn.Pos())
		return fmt.Errorf("%s: wrong signature for %s, must be: func %s(%s *testing.%s)", pos, name, name, strings.ToLower(arg), arg)
	}
	return nil
}

type cmdgo_byOrder []*doc.Example

func (x cmdgo_byOrder) Len() int { return len(x) }

func (x cmdgo_byOrder) Swap(i, j int) { x[i], x[j] = x[j], x[i] }

func (x cmdgo_byOrder) Less(i, j int) bool { return x[i].Order < x[j].Order }

var cmdgo_testmainTmpl = template.Must(template.New("main").Parse(`
package main

import (
{{if not .TestMain}}
	"os"
{{end}}
	"regexp"
	"testing"

{{if .ImportTest}}
	{{if .NeedTest}}_test{{else}}_{{end}} {{.Package.ImportPath | printf "%q"}}
{{end}}
{{if .ImportXtest}}
	{{if .NeedXtest}}_xtest{{else}}_{{end}} {{.Package.ImportPath | printf "%s_test" | printf "%q"}}
{{end}}
{{range $i, $p := .Cover}}
	_cover{{$i}} {{$p.Package.ImportPath | printf "%q"}}
{{end}}

{{if .NeedCgo}}
	_ "runtime/cgo"
{{end}}
)

var tests = []testing.InternalTest{
{{range .Tests}}
	{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
}

var benchmarks = []testing.InternalBenchmark{
{{range .Benchmarks}}
	{"{{.Name}}", {{.Package}}.{{.Name}}},
{{end}}
}

var examples = []testing.InternalExample{
{{range .Examples}}
	{"{{.Name}}", {{.Package}}.{{.Name}}, {{.Output | printf "%q"}}, {{.Unordered}}},
{{end}}
}

var matchPat string
var matchRe *regexp.Regexp

func matchString(pat, str string) (result bool, err error) {
	if matchRe == nil || matchPat != pat {
		matchPat = pat
		matchRe, err = regexp.Compile(matchPat)
		if err != nil {
			return
		}
	}
	return matchRe.MatchString(str), nil
}

{{if .CoverEnabled}}

// Only updated by init functions, so no need for atomicity.
var (
	coverCounters = make(map[string][]uint32)
	coverBlocks = make(map[string][]testing.CoverBlock)
)

func init() {
	{{range $i, $p := .Cover}}
	{{range $file, $cover := $p.Vars}}
	coverRegisterFile({{printf "%q" $cover.File}}, _cover{{$i}}.{{$cover.Var}}.Count[:], _cover{{$i}}.{{$cover.Var}}.Pos[:], _cover{{$i}}.{{$cover.Var}}.NumStmt[:])
	{{end}}
	{{end}}
}

func coverRegisterFile(fileName string, counter []uint32, pos []uint32, numStmts []uint16) {
	if 3*len(counter) != len(pos) || len(counter) != len(numStmts) {
		panic("coverage: mismatched sizes")
	}
	if coverCounters[fileName] != nil {
		// Already registered.
		return
	}
	coverCounters[fileName] = counter
	block := make([]testing.CoverBlock, len(counter))
	for i := range counter {
		block[i] = testing.CoverBlock{
			Line0: pos[3*i+0],
			Col0: uint16(pos[3*i+2]),
			Line1: pos[3*i+1],
			Col1: uint16(pos[3*i+2]>>16),
			Stmts: numStmts[i],
		}
	}
	coverBlocks[fileName] = block
}
{{end}}

func main() {
{{if .CoverEnabled}}
	testing.RegisterCover(testing.Cover{
		Mode: {{printf "%q" .CoverMode}},
		Counters: coverCounters,
		Blocks: coverBlocks,
		CoveredPackages: {{printf "%q" .Covered}},
	})
{{end}}
	m := testing.MainStart(matchString, tests, benchmarks, examples)
{{with .TestMain}}
	{{.Package}}.{{.Name}}(m)
{{else}}
	os.Exit(m.Run())
{{end}}
}

`))

// testFlagSpec defines a flag we know about.
type cmdgo_testFlagSpec struct {
	name       string
	boolVar    *bool
	flagValue  flag.Value
	passToTest bool // pass to Test
	multiOK    bool // OK to have multiple instances
	present    bool // flag has been seen
}

// testFlagDefn is the set of flags we process.
var cmdgo_testFlagDefn = []*cmdgo_testFlagSpec{

	{name: "c", boolVar: &cmdgo_testC},
	{name: "i", boolVar: &cmdgo_buildI},
	{name: "o"},
	{name: "cover", boolVar: &cmdgo_testCover},
	{name: "covermode"},
	{name: "coverpkg"},
	{name: "exec"},

	{name: "bench", passToTest: true},
	{name: "benchmem", boolVar: new(bool), passToTest: true},
	{name: "benchtime", passToTest: true},
	{name: "count", passToTest: true},
	{name: "coverprofile", passToTest: true},
	{name: "cpu", passToTest: true},
	{name: "cpuprofile", passToTest: true},
	{name: "memprofile", passToTest: true},
	{name: "memprofilerate", passToTest: true},
	{name: "blockprofile", passToTest: true},
	{name: "blockprofilerate", passToTest: true},
	{name: "outputdir", passToTest: true},
	{name: "parallel", passToTest: true},
	{name: "run", passToTest: true},
	{name: "short", boolVar: new(bool), passToTest: true},
	{name: "timeout", passToTest: true},
	{name: "trace", passToTest: true},
	{name: "v", boolVar: &cmdgo_testV, passToTest: true},
}

// add build flags to testFlagDefn
func init() {
	var cmd cmdgo_Command
	cmdgo_addBuildFlags(&cmd)
	cmd.Flag.VisitAll(func(f *flag.Flag) {
		if f.Name == "v" {

			return
		}
		cmdgo_testFlagDefn = append(cmdgo_testFlagDefn, &cmdgo_testFlagSpec{
			name:      f.Name,
			flagValue: f.Value,
		})
	})
}

// testFlags processes the command line, grabbing -x and -c, rewriting known flags
// to have "test" before them, and reading the command line for the 6.out.
// Unfortunately for us, we need to do our own flag processing because go test
// grabs some flags but otherwise its command line is just a holding place for
// pkg.test's arguments.
// We allow known flags both before and after the package name list,
// to allow both
//	go test fmt -custom-flag-for-fmt-test
//	go test -x math
func cmdgo_testFlags(args []string) (packageNames, passToTest []string) {
	inPkg := false
	outputDir := ""
	var explicitArgs []string
	for i := 0; i < len(args); i++ {
		if !strings.HasPrefix(args[i], "-") {
			if !inPkg && packageNames == nil {

				inPkg = true
			}
			if inPkg {
				packageNames = append(packageNames, args[i])
				continue
			}
		}

		if inPkg {

			inPkg = false
		}

		f, value, extraWord := cmdgo_testFlag(args, i)
		if f == nil {

			inPkg = false
			if packageNames == nil {

				packageNames = []string{}
			}
			if args[i] == "-args" || args[i] == "--args" {

				explicitArgs = args[i+1:]
				break
			}
			passToTest = append(passToTest, args[i])
			continue
		}
		if f.flagValue != nil {
			if err := f.flagValue.Set(value); err != nil {
				cmdgo_fatalf("invalid flag argument for -%s: %v", f.name, err)
			}
		} else {
			// Test-only flags.
			// Arguably should be handled by f.flagValue, but aren't.
			var err error
			switch f.name {

			case "c", "i", "v", "cover":
				cmdgo_setBoolFlag(f.boolVar, value)
			case "o":
				cmdgo_testO = value
				cmdgo_testNeedBinary = true
			case "exec":
				cmdgo_execCmd, err = cmdgo_splitQuotedFields(value)
				if err != nil {
					cmdgo_fatalf("invalid flag argument for -%s: %v", f.name, err)
				}
			case "bench":

				cmdgo_testBench = true
			case "timeout":
				cmdgo_testTimeout = value
			case "blockprofile", "cpuprofile", "memprofile":
				cmdgo_testProfile = true
				cmdgo_testNeedBinary = true
			case "trace":
				cmdgo_testProfile = true
			case "coverpkg":
				cmdgo_testCover = true
				if value == "" {
					cmdgo_testCoverPaths = nil
				} else {
					cmdgo_testCoverPaths = strings.Split(value, ",")
				}
			case "coverprofile":
				cmdgo_testCover = true
				cmdgo_testProfile = true
			case "covermode":
				switch value {
				case "set", "count", "atomic":
					cmdgo_testCoverMode = value
				default:
					cmdgo_fatalf("invalid flag argument for -covermode: %q", value)
				}
				cmdgo_testCover = true
			case "outputdir":
				outputDir = value
			}
		}
		if extraWord {
			i++
		}
		if f.passToTest {
			passToTest = append(passToTest, "-test."+f.name+"="+value)
		}
	}

	if cmdgo_testCoverMode == "" {
		cmdgo_testCoverMode = "set"
		if cmdgo_buildRace {

			cmdgo_testCoverMode = "atomic"
		}
	}

	if cmdgo_testProfile && outputDir == "" {
		dir, err := os.Getwd()
		if err != nil {
			cmdgo_fatalf("error from os.Getwd: %s", err)
		}
		passToTest = append(passToTest, "-test.outputdir", dir)
	}

	passToTest = append(passToTest, explicitArgs...)
	return
}

// testFlag sees if argument i is a known flag and returns its definition, value, and whether it consumed an extra word.
func cmdgo_testFlag(args []string, i int) (f *cmdgo_testFlagSpec, value string, extra bool) {
	arg := args[i]
	if strings.HasPrefix(arg, "--") {
		arg = arg[1:]
	}
	switch arg {
	case "-?", "-h", "-help":
		cmdgo_usage()
	}
	if arg == "" || arg[0] != '-' {
		return
	}
	name := arg[1:]

	name = strings.TrimPrefix(name, "test.")
	equals := strings.Index(name, "=")
	if equals >= 0 {
		value = name[equals+1:]
		name = name[:equals]
	}
	for _, f = range cmdgo_testFlagDefn {
		if name == f.name {

			if f.boolVar != nil || cmdgo_isBoolFlag(f.flagValue) {
				if equals < 0 {
					value = "true"
				} else {

					cmdgo_setBoolFlag(new(bool), value)
				}
			} else {
				extra = equals < 0
				if extra {
					if i+1 >= len(args) {
						cmdgo_testSyntaxError("missing argument for flag " + f.name)
					}
					value = args[i+1]
				}
			}
			if f.present && !f.multiOK {
				cmdgo_testSyntaxError(f.name + " flag may be set only once")
			}
			f.present = true
			return
		}
	}
	f = nil
	return
}

// isBoolFlag reports whether v is a bool flag.
func cmdgo_isBoolFlag(v flag.Value) bool {
	vv, ok := v.(interface {
		IsBoolFlag() bool
	})
	if ok {
		return vv.IsBoolFlag()
	}
	return false
}

// setBoolFlag sets the addressed boolean to the value.
func cmdgo_setBoolFlag(flag *bool, value string) {
	x, err := strconv.ParseBool(value)
	if err != nil {
		cmdgo_testSyntaxError("illegal bool flag value " + value)
	}
	*flag = x
}

// setIntFlag sets the addressed integer to the value.
func cmdgo_setIntFlag(flag *int, value string) {
	x, err := strconv.Atoi(value)
	if err != nil {
		cmdgo_testSyntaxError("illegal int flag value " + value)
	}
	*flag = x
}

func cmdgo_testSyntaxError(msg string) {
	fmt.Fprintf(os.Stderr, "go test: %s\n", msg)
	fmt.Fprintf(os.Stderr, `run "go help test" or "go help testflag" for more information`+"\n")
	os.Exit(2)
}

var cmdgo_cmdTool = &cmdgo_Command{
	Run:       cmdgo_runTool,
	UsageLine: "tool [-n] command [args...]",
	Short:     "run specified go tool",
	Long: `
Tool runs the go tool command identified by the arguments.
With no arguments it prints the list of known tools.

The -n flag causes tool to print the command that would be
executed but not execute it.

For more about each tool command, see 'go tool command -h'.
`,
}

var (
	cmdgo_toolGOOS      = runtime.GOOS
	cmdgo_toolGOARCH    = runtime.GOARCH
	cmdgo_toolIsWindows = cmdgo_toolGOOS == "windows"
	cmdgo_toolDir       = build.ToolDir

	cmdgo_toolN bool
)

func init() {
	cmdgo_cmdTool.Flag.BoolVar(&cmdgo_toolN, "n", false, "")
}

const cmdgo_toolWindowsExtension = ".exe"

func cmdgo_tool(toolName string) string {
	toolPath := filepath.Join(cmdgo_toolDir, toolName)
	if cmdgo_toolIsWindows {
		toolPath += cmdgo_toolWindowsExtension
	}
	if len(cmdgo_buildToolExec) > 0 {
		return toolPath
	}

	if _, err := os.Stat(toolPath); err != nil {
		if cmdgo_isInGoToolsRepo(toolName) {
			fmt.Fprintf(os.Stderr, "go tool: no such tool %q; to install:\n\tgo get golang.org/x/tools/cmd/%s\n", toolName, toolName)
		} else {
			fmt.Fprintf(os.Stderr, "go tool: no such tool %q\n", toolName)
		}
		cmdgo_setExitStatus(3)
		cmdgo_exit()
	}
	return toolPath
}

func cmdgo_isInGoToolsRepo(toolName string) bool {
	return false
}

func cmdgo_runTool(cmd *cmdgo_Command, args []string) {
	if len(args) == 0 {
		cmdgo_listTools()
		return
	}
	toolName := args[0]

	for _, c := range toolName {
		switch {
		case 'a' <= c && c <= 'z', '0' <= c && c <= '9', c == '_':
		default:
			fmt.Fprintf(os.Stderr, "go tool: bad tool name %q\n", toolName)
			cmdgo_setExitStatus(2)
			return
		}
	}
	toolPath := cmdgo_tool(toolName)
	if toolPath == "" {
		return
	}
	if cmdgo_toolN {
		cmd := toolPath
		if len(args) > 1 {
			cmd += " " + strings.Join(args[1:], " ")
		}
		fmt.Printf("%s\n", cmd)
		return
	}
	args[0] = toolPath
	toolCmd := &exec.Cmd{
		Path:   toolPath,
		Args:   args,
		Stdin:  os.Stdin,
		Stdout: os.Stdout,
		Stderr: os.Stderr,

		Env: cmdgo_mergeEnvLists([]string{"GOROOT=" + cmdgo_goroot}, os.Environ()),
	}
	err := toolCmd.Run()
	if err != nil {

		if e, ok := err.(*exec.ExitError); !ok || !e.Exited() || cmdgo_buildX {
			fmt.Fprintf(os.Stderr, "go tool %s: %s\n", toolName, err)
		}
		cmdgo_setExitStatus(1)
		return
	}
}

// listTools prints a list of the available tools in the tools directory.
func cmdgo_listTools() {
	f, err := os.Open(cmdgo_toolDir)
	if err != nil {
		fmt.Fprintf(os.Stderr, "go tool: no tool directory: %s\n", err)
		cmdgo_setExitStatus(2)
		return
	}
	defer f.Close()
	names, err := f.Readdirnames(-1)
	if err != nil {
		fmt.Fprintf(os.Stderr, "go tool: can't read directory: %s\n", err)
		cmdgo_setExitStatus(2)
		return
	}

	sort.Strings(names)
	for _, name := range names {

		name = strings.ToLower(name)

		if cmdgo_toolIsWindows && strings.HasSuffix(name, cmdgo_toolWindowsExtension) {
			name = name[:len(name)-len(cmdgo_toolWindowsExtension)]
		}
		fmt.Println(name)
	}
}

// A vcsCmd describes how to use a version control system
// like Mercurial, Git, or Subversion.
type cmdgo_vcsCmd struct {
	name string
	cmd  string // name of binary to invoke command

	createCmd   []string // commands to download a fresh copy of a repository
	downloadCmd []string // commands to download updates into an existing repository

	tagCmd         []cmdgo_tagCmd // commands to list tags
	tagLookupCmd   []cmdgo_tagCmd // commands to lookup tags before running tagSyncCmd
	tagSyncCmd     []string       // commands to sync to specific tag
	tagSyncDefault []string       // commands to sync to default tag

	scheme  []string
	pingCmd string

	remoteRepo  func(v *cmdgo_vcsCmd, rootDir string) (remoteRepo string, err error)
	resolveRepo func(v *cmdgo_vcsCmd, rootDir, remoteRepo string) (realRepo string, err error)
}

var cmdgo_isSecureScheme = map[string]bool{
	"https":   true,
	"git+ssh": true,
	"bzr+ssh": true,
	"svn+ssh": true,
	"ssh":     true,
}

func (v *cmdgo_vcsCmd) isSecure(repo string) bool {
	u, err := url.Parse(repo)
	if err != nil {

		return false
	}
	return cmdgo_isSecureScheme[u.Scheme]
}

// A tagCmd describes a command to list available tags
// that can be passed to tagSyncCmd.
type cmdgo_tagCmd struct {
	cmd     string // command to list tags
	pattern string // regexp to extract tags from list
}

// vcsList lists the known version control systems
var cmdgo_vcsList = []*cmdgo_vcsCmd{
	cmdgo_vcsHg,
	cmdgo_vcsGit,
	cmdgo_vcsSvn,
	cmdgo_vcsBzr,
}

// vcsByCmd returns the version control system for the given
// command name (hg, git, svn, bzr).
func cmdgo_vcsByCmd(cmd string) *cmdgo_vcsCmd {
	for _, vcs := range cmdgo_vcsList {
		if vcs.cmd == cmd {
			return vcs
		}
	}
	return nil
}

// vcsHg describes how to use Mercurial.
var cmdgo_vcsHg = &cmdgo_vcsCmd{
	name: "Mercurial",
	cmd:  "hg",

	createCmd:   []string{"clone -U {repo} {dir}"},
	downloadCmd: []string{"pull"},

	tagCmd: []cmdgo_tagCmd{
		{"tags", `^(\S+)`},
		{"branches", `^(\S+)`},
	},
	tagSyncCmd:     []string{"update -r {tag}"},
	tagSyncDefault: []string{"update default"},

	scheme:     []string{"https", "http", "ssh"},
	pingCmd:    "identify {scheme}://{repo}",
	remoteRepo: cmdgo_hgRemoteRepo,
}

func cmdgo_hgRemoteRepo(vcsHg *cmdgo_vcsCmd, rootDir string) (remoteRepo string, err error) {
	out, err := vcsHg.runOutput(rootDir, "paths default")
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(out)), nil
}

// vcsGit describes how to use Git.
var cmdgo_vcsGit = &cmdgo_vcsCmd{
	name: "Git",
	cmd:  "git",

	createCmd:   []string{"clone {repo} {dir}", "-go-internal-cd {dir} submodule update --init --recursive"},
	downloadCmd: []string{"pull --ff-only", "submodule update --init --recursive"},

	tagCmd: []cmdgo_tagCmd{

		{"show-ref", `(?:tags|origin)/(\S+)$`},
	},
	tagLookupCmd: []cmdgo_tagCmd{
		{"show-ref tags/{tag} origin/{tag}", `((?:tags|origin)/\S+)$`},
	},
	tagSyncCmd: []string{"checkout {tag}", "submodule update --init --recursive"},

	tagSyncDefault: []string{"submodule update --init --recursive"},

	scheme:     []string{"git", "https", "http", "git+ssh", "ssh"},
	pingCmd:    "ls-remote {scheme}://{repo}",
	remoteRepo: cmdgo_gitRemoteRepo,
}

// scpSyntaxRe matches the SCP-like addresses used by Git to access
// repositories by SSH.
var cmdgo_scpSyntaxRe = regexp.MustCompile(`^([a-zA-Z0-9_]+)@([a-zA-Z0-9._-]+):(.*)$`)

func cmdgo_gitRemoteRepo(vcsGit *cmdgo_vcsCmd, rootDir string) (remoteRepo string, err error) {
	cmd := "config remote.origin.url"
	errParse := errors.New("unable to parse output of git " + cmd)
	errRemoteOriginNotFound := errors.New("remote origin not found")
	outb, err := vcsGit.run1(rootDir, cmd, nil, false)
	if err != nil {

		if outb != nil && len(outb) == 0 {
			return "", errRemoteOriginNotFound
		}
		return "", err
	}
	out := strings.TrimSpace(string(outb))

	var repoURL *url.URL
	if m := cmdgo_scpSyntaxRe.FindStringSubmatch(out); m != nil {

		repoURL = &url.URL{
			Scheme: "ssh",
			User:   url.User(m[1]),
			Host:   m[2],
			Path:   m[3],
		}
	} else {
		repoURL, err = url.Parse(out)
		if err != nil {
			return "", err
		}
	}

	for _, s := range vcsGit.scheme {
		if repoURL.Scheme == s {
			return repoURL.String(), nil
		}
	}
	return "", errParse
}

// vcsBzr describes how to use Bazaar.
var cmdgo_vcsBzr = &cmdgo_vcsCmd{
	name: "Bazaar",
	cmd:  "bzr",

	createCmd: []string{"branch {repo} {dir}"},

	downloadCmd: []string{"pull --overwrite"},

	tagCmd:         []cmdgo_tagCmd{{"tags", `^(\S+)`}},
	tagSyncCmd:     []string{"update -r {tag}"},
	tagSyncDefault: []string{"update -r revno:-1"},

	scheme:      []string{"https", "http", "bzr", "bzr+ssh"},
	pingCmd:     "info {scheme}://{repo}",
	remoteRepo:  cmdgo_bzrRemoteRepo,
	resolveRepo: cmdgo_bzrResolveRepo,
}

func cmdgo_bzrRemoteRepo(vcsBzr *cmdgo_vcsCmd, rootDir string) (remoteRepo string, err error) {
	outb, err := vcsBzr.runOutput(rootDir, "config parent_location")
	if err != nil {
		return "", err
	}
	return strings.TrimSpace(string(outb)), nil
}

func cmdgo_bzrResolveRepo(vcsBzr *cmdgo_vcsCmd, rootDir, remoteRepo string) (realRepo string, err error) {
	outb, err := vcsBzr.runOutput(rootDir, "info "+remoteRepo)
	if err != nil {
		return "", err
	}
	out := string(outb)

	found := false
	for _, prefix := range []string{"\n  branch root: ", "\n  repository branch: "} {
		i := strings.Index(out, prefix)
		if i >= 0 {
			out = out[i+len(prefix):]
			found = true
			break
		}
	}
	if !found {
		return "", fmt.Errorf("unable to parse output of bzr info")
	}

	i := strings.Index(out, "\n")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of bzr info")
	}
	out = out[:i]
	return strings.TrimSpace(out), nil
}

// vcsSvn describes how to use Subversion.
var cmdgo_vcsSvn = &cmdgo_vcsCmd{
	name: "Subversion",
	cmd:  "svn",

	createCmd:   []string{"checkout {repo} {dir}"},
	downloadCmd: []string{"update"},

	scheme:     []string{"https", "http", "svn", "svn+ssh"},
	pingCmd:    "info {scheme}://{repo}",
	remoteRepo: cmdgo_svnRemoteRepo,
}

func cmdgo_svnRemoteRepo(vcsSvn *cmdgo_vcsCmd, rootDir string) (remoteRepo string, err error) {
	outb, err := vcsSvn.runOutput(rootDir, "info")
	if err != nil {
		return "", err
	}
	out := string(outb)

	i := strings.Index(out, "\nRepository Root: ")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of svn info")
	}
	out = out[i+len("\nRepository Root: "):]
	i = strings.Index(out, "\n")
	if i < 0 {
		return "", fmt.Errorf("unable to parse output of svn info")
	}
	out = out[:i]
	return strings.TrimSpace(out), nil
}

func (v *cmdgo_vcsCmd) String() string {
	return v.name
}

// run runs the command line cmd in the given directory.
// keyval is a list of key, value pairs.  run expands
// instances of {key} in cmd into value, but only after
// splitting cmd into individual arguments.
// If an error occurs, run prints the command line and the
// command's combined stdout+stderr to standard error.
// Otherwise run discards the command's output.
func (v *cmdgo_vcsCmd) run(dir string, cmd string, keyval ...string) error {
	_, err := v.run1(dir, cmd, keyval, true)
	return err
}

// runVerboseOnly is like run but only generates error output to standard error in verbose mode.
func (v *cmdgo_vcsCmd) runVerboseOnly(dir string, cmd string, keyval ...string) error {
	_, err := v.run1(dir, cmd, keyval, false)
	return err
}

// runOutput is like run but returns the output of the command.
func (v *cmdgo_vcsCmd) runOutput(dir string, cmd string, keyval ...string) ([]byte, error) {
	return v.run1(dir, cmd, keyval, true)
}

// run1 is the generalized implementation of run and runOutput.
func (v *cmdgo_vcsCmd) run1(dir string, cmdline string, keyval []string, verbose bool) ([]byte, error) {
	m := make(map[string]string)
	for i := 0; i < len(keyval); i += 2 {
		m[keyval[i]] = keyval[i+1]
	}
	args := strings.Fields(cmdline)
	for i, arg := range args {
		args[i] = cmdgo_expand(m, arg)
	}

	if len(args) >= 2 && args[0] == "-go-internal-cd" {
		if filepath.IsAbs(args[1]) {
			dir = args[1]
		} else {
			dir = filepath.Join(dir, args[1])
		}
		args = args[2:]
	}

	_, err := exec.LookPath(v.cmd)
	if err != nil {
		fmt.Fprintf(os.Stderr,
			"go: missing %s command. See https://golang.org/s/gogetcmd\n",
			v.name)
		return nil, err
	}

	cmd := exec.Command(v.cmd, args...)
	cmd.Dir = dir
	cmd.Env = cmdgo_envForDir(cmd.Dir, os.Environ())
	if cmdgo_buildX {
		fmt.Printf("cd %s\n", dir)
		fmt.Printf("%s %s\n", v.cmd, strings.Join(args, " "))
	}
	var buf bytes.Buffer
	cmd.Stdout = &buf
	cmd.Stderr = &buf
	err = cmd.Run()
	out := buf.Bytes()
	if err != nil {
		if verbose || cmdgo_buildV {
			fmt.Fprintf(os.Stderr, "# cd %s; %s %s\n", dir, v.cmd, strings.Join(args, " "))
			os.Stderr.Write(out)
		}
		return out, err
	}
	return out, nil
}

// ping pings to determine scheme to use.
func (v *cmdgo_vcsCmd) ping(scheme, repo string) error {
	return v.runVerboseOnly(".", v.pingCmd, "scheme", scheme, "repo", repo)
}

// create creates a new copy of repo in dir.
// The parent of dir must exist; dir must not.
func (v *cmdgo_vcsCmd) create(dir, repo string) error {
	for _, cmd := range v.createCmd {
		if err := v.run(".", cmd, "dir", dir, "repo", repo); err != nil {
			return err
		}
	}
	return nil
}

// download downloads any new changes for the repo in dir.
func (v *cmdgo_vcsCmd) download(dir string) error {
	for _, cmd := range v.downloadCmd {
		if err := v.run(dir, cmd); err != nil {
			return err
		}
	}
	return nil
}

// tags returns the list of available tags for the repo in dir.
func (v *cmdgo_vcsCmd) tags(dir string) ([]string, error) {
	var tags []string
	for _, tc := range v.tagCmd {
		out, err := v.runOutput(dir, tc.cmd)
		if err != nil {
			return nil, err
		}
		re := regexp.MustCompile(`(?m-s)` + tc.pattern)
		for _, m := range re.FindAllStringSubmatch(string(out), -1) {
			tags = append(tags, m[1])
		}
	}
	return tags, nil
}

// tagSync syncs the repo in dir to the named tag,
// which either is a tag returned by tags or is v.tagDefault.
func (v *cmdgo_vcsCmd) tagSync(dir, tag string) error {
	if v.tagSyncCmd == nil {
		return nil
	}
	if tag != "" {
		for _, tc := range v.tagLookupCmd {
			out, err := v.runOutput(dir, tc.cmd, "tag", tag)
			if err != nil {
				return err
			}
			re := regexp.MustCompile(`(?m-s)` + tc.pattern)
			m := re.FindStringSubmatch(string(out))
			if len(m) > 1 {
				tag = m[1]
				break
			}
		}
	}

	if tag == "" && v.tagSyncDefault != nil {
		for _, cmd := range v.tagSyncDefault {
			if err := v.run(dir, cmd); err != nil {
				return err
			}
		}
		return nil
	}

	for _, cmd := range v.tagSyncCmd {
		if err := v.run(dir, cmd, "tag", tag); err != nil {
			return err
		}
	}
	return nil
}

// A vcsPath describes how to convert an import path into a
// version control system and repository name.
type cmdgo_vcsPath struct {
	prefix string                              // prefix this description applies to
	re     string                              // pattern for import path
	repo   string                              // repository to use (expand with match of re)
	vcs    string                              // version control system to use (expand with match of re)
	check  func(match map[string]string) error // additional checks
	ping   bool                                // ping for scheme to use to download repo

	regexp *regexp.Regexp // cached compiled form of re
}

// vcsFromDir inspects dir and its parents to determine the
// version control system and code repository to use.
// On return, root is the import path
// corresponding to the root of the repository.
func cmdgo_vcsFromDir(dir, srcRoot string) (vcs *cmdgo_vcsCmd, root string, err error) {

	dir = filepath.Clean(dir)
	srcRoot = filepath.Clean(srcRoot)
	if len(dir) <= len(srcRoot) || dir[len(srcRoot)] != filepath.Separator {
		return nil, "", fmt.Errorf("directory %q is outside source root %q", dir, srcRoot)
	}

	origDir := dir
	for len(dir) > len(srcRoot) {
		for _, vcs := range cmdgo_vcsList {
			if fi, err := os.Stat(filepath.Join(dir, "."+vcs.cmd)); err == nil && fi.IsDir() {
				return vcs, filepath.ToSlash(dir[len(srcRoot)+1:]), nil
			}
		}

		ndir := filepath.Dir(dir)
		if len(ndir) >= len(dir) {

			break
		}
		dir = ndir
	}

	return nil, "", fmt.Errorf("directory %q is not using a known version control system", origDir)
}

// repoRoot represents a version control system, a repo, and a root of
// where to put it on disk.
type cmdgo_repoRoot struct {
	vcs *cmdgo_vcsCmd

	// repo is the repository URL, including scheme
	repo string

	// root is the import path corresponding to the root of the
	// repository
	root string
}

var cmdgo_httpPrefixRE = regexp.MustCompile(`^https?:`)

// securityMode specifies whether a function should make network
// calls using insecure transports (eg, plain text HTTP).
// The zero value is "secure".
type cmdgo_securityMode int

const (
	cmdgo_secure cmdgo_securityMode = iota
	cmdgo_insecure
)

// repoRootForImportPath analyzes importPath to determine the
// version control system, and code repository to use.
func cmdgo_repoRootForImportPath(importPath string, security cmdgo_securityMode) (*cmdgo_repoRoot, error) {
	rr, err := cmdgo_repoRootFromVCSPaths(importPath, "", security, cmdgo_vcsPaths)
	if err == cmdgo_errUnknownSite {

		lookup := strings.TrimSuffix(importPath, "/...")
		if i := strings.Index(lookup, "/.../"); i >= 0 {
			lookup = lookup[:i]
		}
		rr, err = cmdgo_repoRootForImportDynamic(lookup, security)
		if err != nil {
			err = fmt.Errorf("unrecognized import path %q (%v)", importPath, err)
		}
	}
	if err != nil {
		rr1, err1 := cmdgo_repoRootFromVCSPaths(importPath, "", security, cmdgo_vcsPathsAfterDynamic)
		if err1 == nil {
			rr = rr1
			err = nil
		}
	}

	if err == nil && strings.Contains(importPath, "...") && strings.Contains(rr.root, "...") {

		rr = nil
		err = fmt.Errorf("cannot expand ... in %q", importPath)
	}
	return rr, err
}

var cmdgo_errUnknownSite = errors.New("dynamic lookup required to find mapping")

// repoRootFromVCSPaths attempts to map importPath to a repoRoot
// using the mappings defined in vcsPaths.
// If scheme is non-empty, that scheme is forced.
func cmdgo_repoRootFromVCSPaths(importPath, scheme string, security cmdgo_securityMode, vcsPaths []*cmdgo_vcsPath) (*cmdgo_repoRoot, error) {

	if loc := cmdgo_httpPrefixRE.FindStringIndex(importPath); loc != nil {

		return nil, fmt.Errorf("%q not allowed in import path", importPath[loc[0]:loc[1]]+"//")
	}
	for _, srv := range vcsPaths {
		if !strings.HasPrefix(importPath, srv.prefix) {
			continue
		}
		m := srv.regexp.FindStringSubmatch(importPath)
		if m == nil {
			if srv.prefix != "" {
				return nil, fmt.Errorf("invalid %s import path %q", srv.prefix, importPath)
			}
			continue
		}

		match := map[string]string{
			"prefix": srv.prefix,
			"import": importPath,
		}
		for i, name := range srv.regexp.SubexpNames() {
			if name != "" && match[name] == "" {
				match[name] = m[i]
			}
		}
		if srv.vcs != "" {
			match["vcs"] = cmdgo_expand(match, srv.vcs)
		}
		if srv.repo != "" {
			match["repo"] = cmdgo_expand(match, srv.repo)
		}
		if srv.check != nil {
			if err := srv.check(match); err != nil {
				return nil, err
			}
		}
		vcs := cmdgo_vcsByCmd(match["vcs"])
		if vcs == nil {
			return nil, fmt.Errorf("unknown version control system %q", match["vcs"])
		}
		if srv.ping {
			if scheme != "" {
				match["repo"] = scheme + "://" + match["repo"]
			} else {
				for _, scheme := range vcs.scheme {
					if security == cmdgo_secure && !cmdgo_isSecureScheme[scheme] {
						continue
					}
					if vcs.ping(scheme, match["repo"]) == nil {
						match["repo"] = scheme + "://" + match["repo"]
						break
					}
				}
			}
		}
		rr := &cmdgo_repoRoot{
			vcs:  vcs,
			repo: match["repo"],
			root: match["root"],
		}
		return rr, nil
	}
	return nil, cmdgo_errUnknownSite
}

// repoRootForImportDynamic finds a *repoRoot for a custom domain that's not
// statically known by repoRootForImportPathStatic.
//
// This handles custom import paths like "name.tld/pkg/foo" or just "name.tld".
func cmdgo_repoRootForImportDynamic(importPath string, security cmdgo_securityMode) (*cmdgo_repoRoot, error) {
	slash := strings.Index(importPath, "/")
	if slash < 0 {
		slash = len(importPath)
	}
	host := importPath[:slash]
	if !strings.Contains(host, ".") {
		return nil, errors.New("import path does not begin with hostname")
	}
	urlStr, body, err := cmdgo_httpsOrHTTP(importPath, security)
	if err != nil {
		msg := "https fetch: %v"
		if security == cmdgo_insecure {
			msg = "http/" + msg
		}
		return nil, fmt.Errorf(msg, err)
	}
	defer body.Close()
	imports, err := cmdgo_parseMetaGoImports(body)
	if err != nil {
		return nil, fmt.Errorf("parsing %s: %v", importPath, err)
	}

	mmi, err := cmdgo_matchGoImport(imports, importPath)
	if err != nil {
		if err != cmdgo_errNoMatch {
			return nil, fmt.Errorf("parse %s: %v", urlStr, err)
		}
		return nil, fmt.Errorf("parse %s: no go-import meta tags", urlStr)
	}
	if cmdgo_buildV {
		log.Printf("get %q: found meta tag %#v at %s", importPath, mmi, urlStr)
	}

	if mmi.Prefix != importPath {
		if cmdgo_buildV {
			log.Printf("get %q: verifying non-authoritative meta tag", importPath)
		}
		urlStr0 := urlStr
		var imports []cmdgo_metaImport
		urlStr, imports, err = cmdgo_metaImportsForPrefix(mmi.Prefix, security)
		if err != nil {
			return nil, err
		}
		metaImport2, err := cmdgo_matchGoImport(imports, importPath)
		if err != nil || mmi != metaImport2 {
			return nil, fmt.Errorf("%s and %s disagree about go-import for %s", urlStr0, urlStr, mmi.Prefix)
		}
	}

	if !strings.Contains(mmi.RepoRoot, "://") {
		return nil, fmt.Errorf("%s: invalid repo root %q; no scheme", urlStr, mmi.RepoRoot)
	}
	rr := &cmdgo_repoRoot{
		vcs:  cmdgo_vcsByCmd(mmi.VCS),
		repo: mmi.RepoRoot,
		root: mmi.Prefix,
	}
	if rr.vcs == nil {
		return nil, fmt.Errorf("%s: unknown vcs %q", urlStr, mmi.VCS)
	}
	return rr, nil
}

var cmdgo_fetchGroup singleflight.Group

var (
	cmdgo_fetchCacheMu sync.Mutex
	cmdgo_fetchCache   = map[string]cmdgo_fetchResult{} // key is metaImportsForPrefix's importPrefix
)

// metaImportsForPrefix takes a package's root import path as declared in a <meta> tag
// and returns its HTML discovery URL and the parsed metaImport lines
// found on the page.
//
// The importPath is of the form "golang.org/x/tools".
// It is an error if no imports are found.
// urlStr will still be valid if err != nil.
// The returned urlStr will be of the form "https://golang.org/x/tools?go-get=1"
func cmdgo_metaImportsForPrefix(importPrefix string, security cmdgo_securityMode) (urlStr string, imports []cmdgo_metaImport, err error) {
	setCache := func(res cmdgo_fetchResult) (cmdgo_fetchResult, error) {
		cmdgo_fetchCacheMu.Lock()
		defer cmdgo_fetchCacheMu.Unlock()
		cmdgo_fetchCache[importPrefix] = res
		return res, nil
	}

	resi, _, _ := cmdgo_fetchGroup.Do(importPrefix, func() (resi interface{}, err error) {
		cmdgo_fetchCacheMu.Lock()
		if res, ok := cmdgo_fetchCache[importPrefix]; ok {
			cmdgo_fetchCacheMu.Unlock()
			return res, nil
		}
		cmdgo_fetchCacheMu.Unlock()

		urlStr, body, err := cmdgo_httpsOrHTTP(importPrefix, security)
		if err != nil {
			return setCache(cmdgo_fetchResult{urlStr: urlStr, err: fmt.Errorf("fetch %s: %v", urlStr, err)})
		}
		imports, err := cmdgo_parseMetaGoImports(body)
		if err != nil {
			return setCache(cmdgo_fetchResult{urlStr: urlStr, err: fmt.Errorf("parsing %s: %v", urlStr, err)})
		}
		if len(imports) == 0 {
			err = fmt.Errorf("fetch %s: no go-import meta tag", urlStr)
		}
		return setCache(cmdgo_fetchResult{urlStr: urlStr, imports: imports, err: err})
	})
	res := resi.(cmdgo_fetchResult)
	return res.urlStr, res.imports, res.err
}

type cmdgo_fetchResult struct {
	urlStr  string // e.g. "https://foo.com/x/bar?go-get=1"
	imports []cmdgo_metaImport
	err     error
}

// metaImport represents the parsed <meta name="go-import"
// content="prefix vcs reporoot" /> tags from HTML files.
type cmdgo_metaImport struct {
	Prefix, VCS, RepoRoot string
}

// errNoMatch is returned from matchGoImport when there's no applicable match.
var cmdgo_errNoMatch = errors.New("no import match")

func cmdgo_splitPathHasPrefix(path, prefix []string) bool {
	if len(path) < len(prefix) {
		return false
	}
	for i, p := range prefix {
		if path[i] != p {
			return false
		}
	}
	return true
}

// matchGoImport returns the metaImport from imports matching importPath.
// An error is returned if there are multiple matches.
// errNoMatch is returned if none match.
func cmdgo_matchGoImport(imports []cmdgo_metaImport, importPath string) (_ cmdgo_metaImport, err error) {
	match := -1
	imp := strings.Split(importPath, "/")
	for i, im := range imports {
		pre := strings.Split(im.Prefix, "/")

		if !cmdgo_splitPathHasPrefix(imp, pre) {
			continue
		}

		if match != -1 {
			err = fmt.Errorf("multiple meta tags match import path %q", importPath)
			return
		}
		match = i
	}
	if match == -1 {
		err = cmdgo_errNoMatch
		return
	}
	return imports[match], nil
}

// expand rewrites s to replace {k} with match[k] for each key k in match.
func cmdgo_expand(match map[string]string, s string) string {
	for k, v := range match {
		s = strings.Replace(s, "{"+k+"}", v, -1)
	}
	return s
}

// vcsPaths defines the meaning of import paths referring to
// commonly-used VCS hosting sites (github.com/user/dir)
// and import paths referring to a fully-qualified importPath
// containing a VCS type (foo.com/repo.git/dir)
var cmdgo_vcsPaths = []*cmdgo_vcsPath{

	{
		prefix: "github.com/",
		re:     `^(?P<root>github\.com/[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  cmdgo_noVCSSuffix,
	},

	{
		prefix: "bitbucket.org/",
		re:     `^(?P<root>bitbucket\.org/(?P<bitname>[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
		repo:   "https://{root}",
		check:  cmdgo_bitbucketVCS,
	},

	{
		prefix: "hub.jazz.net/git",
		re:     `^(?P<root>hub.jazz.net/git/[a-z0-9]+/[A-Za-z0-9_.\-]+)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
		check:  cmdgo_noVCSSuffix,
	},

	{
		prefix: "git.apache.org",
		re:     `^(?P<root>git.apache.org/[a-z0-9_.\-]+\.git)(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
	},

	{
		prefix: "git.openstack.org",
		re:     `^(?P<root>git\.openstack\.org/[A-Za-z0-9_.\-]+/[A-Za-z0-9_.\-]+)(\.git)?(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "git",
		repo:   "https://{root}",
	},

	{
		re:   `^(?P<root>(?P<repo>([a-z0-9.\-]+\.)+[a-z0-9.\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\-]+)+?)\.(?P<vcs>bzr|git|hg|svn))(/~?[A-Za-z0-9_.\-]+)*$`,
		ping: true,
	},
}

// vcsPathsAfterDynamic gives additional vcsPaths entries
// to try after the dynamic HTML check.
// This gives those sites a chance to introduce <meta> tags
// as part of a graceful transition away from the hard-coded logic.
var cmdgo_vcsPathsAfterDynamic = []*cmdgo_vcsPath{

	{
		prefix: "launchpad.net/",
		re:     `^(?P<root>launchpad\.net/((?P<project>[A-Za-z0-9_.\-]+)(?P<series>/[A-Za-z0-9_.\-]+)?|~[A-Za-z0-9_.\-]+/(\+junk|[A-Za-z0-9_.\-]+)/[A-Za-z0-9_.\-]+))(/[A-Za-z0-9_.\-]+)*$`,
		vcs:    "bzr",
		repo:   "https://{root}",
		check:  cmdgo_launchpadVCS,
	},
}

func init() {

	for _, srv := range cmdgo_vcsPaths {
		srv.regexp = regexp.MustCompile(srv.re)
	}
	for _, srv := range cmdgo_vcsPathsAfterDynamic {
		srv.regexp = regexp.MustCompile(srv.re)
	}
}

// noVCSSuffix checks that the repository name does not
// end in .foo for any version control system foo.
// The usual culprit is ".git".
func cmdgo_noVCSSuffix(match map[string]string) error {
	repo := match["repo"]
	for _, vcs := range cmdgo_vcsList {
		if strings.HasSuffix(repo, "."+vcs.cmd) {
			return fmt.Errorf("invalid version control suffix in %s path", match["prefix"])
		}
	}
	return nil
}

// bitbucketVCS determines the version control system for a
// Bitbucket repository, by using the Bitbucket API.
func cmdgo_bitbucketVCS(match map[string]string) error {
	if err := cmdgo_noVCSSuffix(match); err != nil {
		return err
	}

	var resp struct {
		SCM string `json:"scm"`
	}
	url := cmdgo_expand(match, "https://api.bitbucket.org/1.0/repositories/{bitname}")
	data, err := cmdgo_httpGET(url)
	if err != nil {
		if httpErr, ok := err.(*cmdgo_httpError); ok && httpErr.statusCode == 403 {

			root := match["root"]
			for _, vcs := range []string{"git", "hg"} {
				if cmdgo_vcsByCmd(vcs).ping("https", root) == nil {
					resp.SCM = vcs
					break
				}
			}
		}

		if resp.SCM == "" {
			return err
		}
	} else {
		if err := json.Unmarshal(data, &resp); err != nil {
			return fmt.Errorf("decoding %s: %v", url, err)
		}
	}

	if cmdgo_vcsByCmd(resp.SCM) != nil {
		match["vcs"] = resp.SCM
		if resp.SCM == "git" {
			match["repo"] += ".git"
		}
		return nil
	}

	return fmt.Errorf("unable to detect version control system for bitbucket.org/ path")
}

// launchpadVCS solves the ambiguity for "lp.net/project/foo". In this case,
// "foo" could be a series name registered in Launchpad with its own branch,
// and it could also be the name of a directory within the main project
// branch one level up.
func cmdgo_launchpadVCS(match map[string]string) error {
	if match["project"] == "" || match["series"] == "" {
		return nil
	}
	_, err := cmdgo_httpGET(cmdgo_expand(match, "https://code.launchpad.net/{project}{series}/.bzr/branch-format"))
	if err != nil {
		match["root"] = cmdgo_expand(match, "launchpad.net/{project}")
		match["repo"] = cmdgo_expand(match, "https://{root}")
	}
	return nil
}

var cmdgo_cmdVersion = &cmdgo_Command{
	Run:       cmdgo_runVersion,
	UsageLine: "version",
	Short:     "print Go version",
	Long:      `Version prints the Go version, as reported by runtime.Version.`,
}

func cmdgo_runVersion(cmd *cmdgo_Command, args []string) {
	if len(args) != 0 {
		cmd.Usage()
	}

	fmt.Printf("go version %s %s/%s (with GopherJS support)\n", runtime.Version(), runtime.GOOS, runtime.GOARCH)
}

func init() {
	cmdgo_addBuildFlags(cmdgo_cmdVet)
}

var cmdgo_cmdVet = &cmdgo_Command{
	Run:       cmdgo_runVet,
	UsageLine: "vet [-n] [-x] [build flags] [packages]",
	Short:     "run go tool vet on packages",
	Long: `
Vet runs the Go vet command on the packages named by the import paths.

For more about vet, see 'go doc cmd/vet'.
For more about specifying packages, see 'go help packages'.

To run the vet tool with specific options, run 'go tool vet'.

The -n flag prints commands that would be executed.
The -x flag prints commands as they are executed.

For more about build flags, see 'go help build'.

See also: go fmt, go fix.
	`,
}

func cmdgo_runVet(cmd *cmdgo_Command, args []string) {
	for _, p := range cmdgo_packages(args) {

		if len(p.GoFiles)+len(p.CgoFiles)+len(p.TestGoFiles) > 0 {
			cmdgo_runVetFiles(p, cmdgo_stringList(p.GoFiles, p.CgoFiles, p.TestGoFiles, p.SFiles))
		}
		if len(p.XTestGoFiles) > 0 {
			cmdgo_runVetFiles(p, cmdgo_stringList(p.XTestGoFiles))
		}
	}
}

func cmdgo_runVetFiles(p *cmdgo_Package, files []string) {
	for i := range files {
		files[i] = filepath.Join(p.Dir, files[i])
	}
	cmdgo_run(cmdgo_buildToolExec, cmdgo_tool("vet"), cmdgo_relPaths(files))
}

const cmdgo_defaultCC = `clang`

const cmdgo_defaultCXX = `clang++`

var cmdgo_osArchSupportsCgo = map[string]bool{
	"android/386":     true,
	"android/amd64":   true,
	"android/arm":     true,
	"android/arm64":   true,
	"darwin/386":      true,
	"darwin/amd64":    true,
	"darwin/arm":      true,
	"darwin/arm64":    true,
	"dragonfly/amd64": true,
	"freebsd/386":     true,
	"freebsd/amd64":   true,
	"freebsd/arm":     false,
	"linux/386":       true,
	"linux/amd64":     true,
	"linux/arm":       true,
	"linux/arm64":     true,
	"linux/mips64":    true,
	"linux/mips64le":  true,
	"linux/ppc64":     false,
	"linux/ppc64le":   true,
	"linux/s390x":     true,
	"nacl/386":        false,
	"nacl/amd64p32":   false,
	"nacl/arm":        false,
	"netbsd/386":      true,
	"netbsd/amd64":    true,
	"netbsd/arm":      true,
	"openbsd/386":     true,
	"openbsd/amd64":   true,
	"openbsd/arm":     false,
	"plan9/386":       false,
	"plan9/amd64":     false,
	"plan9/arm":       false,
	"solaris/amd64":   true,
	"windows/386":     true,
	"windows/amd64":   true,
}
