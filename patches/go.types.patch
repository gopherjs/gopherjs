diff -r 37455f5e1fae go/types/call.go
--- a/go/types/call.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/call.go	Wed Nov 06 20:33:23 2013 +0100
@@ -246,7 +246,6 @@
 }
 
 func (check *checker) selector(x *operand, e *ast.SelectorExpr) {
-	// these must be declared before the "goto Error" statements
 	var (
 		obj      Object
 		index    []int
@@ -267,7 +266,9 @@
 				if !pkg.pkg.fake {
 					check.errorf(e.Pos(), "%s not declared by package %s", sel, ident)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 			if !exp.IsExported() {
 				check.errorf(e.Pos(), "%s not exported by package %s", sel, ident)
@@ -306,7 +307,9 @@
 
 	check.exprOrType(x, e.X)
 	if x.mode == invalid {
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	obj, index, indirect = LookupFieldOrMethod(x.typ, check.pkg, sel)
@@ -317,7 +320,9 @@
 		} else {
 			check.invalidOp(e.Pos(), "%s has no field or method %s", x, sel)
 		}
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return
 	}
 
 	if x.mode == typexpr {
@@ -325,13 +330,17 @@
 		m, _ := obj.(*Func)
 		if m == nil {
 			check.invalidOp(e.Pos(), "%s has no method %s", x, sel)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		// verify that m is in the method set of x.typ
 		if !indirect && ptrRecv(m) {
 			check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x.typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return
 		}
 
 		check.recordSelection(e, MethodExpr, x.typ, m, index, indirect)
@@ -374,7 +383,9 @@
 			//        is shorthand for (&x).m()".
 			if !indirect && x.mode != variable && ptrRecv(obj) {
 				check.invalidOp(e.Pos(), "%s is not in method set of %s", sel, x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return
 			}
 
 			check.recordSelection(e, MethodVal, x.typ, obj, index, indirect)
@@ -422,9 +433,4 @@
 
 	// everything went well
 	x.expr = e
-	return
-
-Error:
-	x.mode = invalid
-	x.expr = e
 }
diff -r 37455f5e1fae go/types/expr.go
--- a/go/types/expr.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/expr.go	Wed Nov 06 20:33:23 2013 +0100
@@ -481,7 +481,9 @@
 				check.updateExprType(x.expr, target, false)
 			}
 		} else if xkind != tkind {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		return
 	}
@@ -502,11 +504,15 @@
 			switch x.typ.(*Basic).kind {
 			case UntypedBool:
 				if !isBoolean(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedInt, UntypedRune, UntypedFloat, UntypedComplex:
 				if !isNumeric(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			case UntypedString:
 				// Non-constant untyped string values are not
@@ -515,15 +521,21 @@
 			case UntypedNil:
 				// Unsafe.Pointer is a basic type that includes nil.
 				if !hasNil(target) {
-					goto Error
+					check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+					x.mode = invalid
+					return
 				}
 			default:
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 		}
 	case *Interface:
 		if !x.isNil() && t.NumMethods() > 0 /* empty interfaces are ok */ {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// Update operand types to the default type rather then
 		// the target (interface) type: values must have concrete
@@ -536,27 +548,28 @@
 		} else {
 			// cannot assign untyped values to non-empty interfaces
 			if t.NumMethods() > 0 {
-				goto Error
+				check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+				x.mode = invalid
+				return
 			}
 			target = defaultType(x.typ)
 		}
 	case *Pointer, *Signature, *Slice, *Map, *Chan:
 		if !x.isNil() {
-			goto Error
+			check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+			x.mode = invalid
+			return
 		}
 		// keep nil untyped - see comment for interfaces, above
 		target = Typ[UntypedNil]
 	default:
-		goto Error
+		check.errorf(x.pos(), "cannot convert %s to %s", x, target)
+		x.mode = invalid
+		return
 	}
 
 	x.typ = target
 	check.updateExprType(x.expr, target, true) // UntypedNils are final
-	return
-
-Error:
-	check.errorf(x.pos(), "cannot convert %s to %s", x, target)
-	x.mode = invalid
 }
 
 func (check *checker) comparison(x, y *operand, op token.Token) {
@@ -763,9 +776,12 @@
 	}
 
 	if (op == token.QUO || op == token.REM) && y.mode == constant && exact.Sign(y.val) == 0 {
-		check.invalidOp(y.pos(), "division by zero")
-		x.mode = invalid
-		return
+		if !isFloat(x.typ) {
+			check.invalidOp(y.pos(), "division by zero")
+			x.mode = invalid
+			return
+		}
+		x.mode = value
 	}
 
 	if x.mode == constant && y.mode == constant {
@@ -908,7 +924,7 @@
 		typ = Typ[Invalid]
 		record = false // nothing to do
 	case novalue:
-		typ = (*Tuple)(nil)
+		typ = (*Tuple)(NewTuple())
 	case constant:
 		typ = x.typ
 		val = x.val
@@ -947,7 +963,9 @@
 
 	switch e := e.(type) {
 	case *ast.BadExpr:
-		goto Error // error was reported before
+		x.mode = invalid
+		x.expr = e
+		return statement // error was reported before
 
 	case *ast.Ident:
 		check.ident(x, e, nil, false)
@@ -956,13 +974,17 @@
 		// ellipses are handled explicitly where they are legal
 		// (array composite literals and parameter lists)
 		check.errorf(e.Pos(), "invalid use of '...'")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.BasicLit:
 		x.setConst(e.Kind, e.Value)
 		if x.mode == invalid {
 			check.invalidAST(e.Pos(), "invalid literal %v", e.Value)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.FuncLit:
@@ -976,7 +998,9 @@
 			check.later(nil, check.decl, sig, e.Body)
 		} else {
 			check.invalidAST(e.Pos(), "invalid function literal %s", e)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.CompositeLit:
@@ -1001,7 +1025,9 @@
 		}
 		if typ == nil {
 			check.errorf(e.Pos(), "missing type in composite literal")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		switch typ, _ := deref(typ); utyp := typ.Underlying().(type) {
@@ -1116,7 +1142,9 @@
 
 		default:
 			check.errorf(e.Pos(), "invalid composite literal type %s", typ)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		x.mode = value
@@ -1133,7 +1161,9 @@
 	case *ast.IndexExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1180,7 +1210,9 @@
 				if key.mode != invalid {
 					check.invalidOp(key.pos(), "cannot use %s as map index of type %s", &key, typ.key)
 				}
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.mode = mapindex
 			x.typ = typ.elem
@@ -1190,12 +1222,16 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot index %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		if e.Index == nil {
 			check.invalidAST(e.Pos(), "missing index for %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		check.index(e.Index, length)
@@ -1204,7 +1240,9 @@
 	case *ast.SliceExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		valid := false
@@ -1214,7 +1252,9 @@
 			if isString(typ) {
 				if slice3(e) {
 					check.invalidOp(x.pos(), "3-index slice of string")
-					goto Error
+					x.mode = invalid
+					x.expr = e
+					return statement
 				}
 				valid = true
 				if x.mode == constant {
@@ -1233,7 +1273,9 @@
 			length = typ.len
 			if x.mode != variable {
 				check.invalidOp(x.pos(), "cannot slice %s (value not addressable)", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 			x.typ = &Slice{elem: typ.elem}
 
@@ -1253,13 +1295,17 @@
 
 		if !valid {
 			check.invalidOp(x.pos(), "cannot slice %s", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// spec: "Only the first index may be omitted; it defaults to 0."
 		if slice3(e) && (e.High == nil || sliceMax(e) == nil) {
 			check.errorf(e.Rbrack, "2nd and 3rd index required in 3-index slice")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 		// check indices
@@ -1305,21 +1351,29 @@
 	case *ast.TypeAssertExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		xtyp, _ := x.typ.Underlying().(*Interface)
 		if xtyp == nil {
 			check.invalidOp(x.pos(), "%s is not an interface", x)
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		// x.(type) expressions are handled explicitly in type switches
 		if e.Type == nil {
 			check.invalidAST(e.Pos(), "use of .(type) outside type switch")
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		T := check.typ(e.Type, nil, false)
 		if T == Typ[Invalid] {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.typeAssertion(x.pos(), x, xtyp, T)
 		x.mode = commaok
@@ -1332,7 +1386,9 @@
 		check.exprOrType(x, e.X)
 		switch x.mode {
 		case invalid:
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		case typexpr:
 			x.typ = &Pointer{base: x.typ}
 		default:
@@ -1341,18 +1397,24 @@
 				x.typ = typ.base
 			} else {
 				check.invalidOp(x.pos(), "cannot indirect %s", x)
-				goto Error
+				x.mode = invalid
+				x.expr = e
+				return statement
 			}
 		}
 
 	case *ast.UnaryExpr:
 		check.expr(x, e.X)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		check.unary(x, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 		if e.Op == token.ARROW {
 			x.expr = e
@@ -1362,13 +1424,17 @@
 	case *ast.BinaryExpr:
 		check.binary(x, e.X, e.Y, e.Op)
 		if x.mode == invalid {
-			goto Error
+			x.mode = invalid
+			x.expr = e
+			return statement
 		}
 
 	case *ast.KeyValueExpr:
 		// key:value expressions are handled in composite literals
 		check.invalidAST(e.Pos(), "no key:value expected")
-		goto Error
+		x.mode = invalid
+		x.expr = e
+		return statement
 
 	case *ast.ArrayType, *ast.StructType, *ast.FuncType,
 		*ast.InterfaceType, *ast.MapType, *ast.ChanType:
@@ -1390,11 +1456,6 @@
 	// everything went well
 	x.expr = e
 	return expression
-
-Error:
-	x.mode = invalid
-	x.expr = e
-	return statement // avoid follow-up errors
 }
 
 // typeAssertion checks that x.(T) is legal; xtyp must be the type of x.
diff -r 37455f5e1fae go/types/gcimporter.go
--- a/go/types/gcimporter.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/gcimporter.go	Wed Nov 06 20:33:23 2013 +0100
@@ -728,7 +728,8 @@
 func (p *gcParser) parseImportDecl() {
 	p.expectKeyword("import")
 	name := p.parsePackageName()
-	p.getPkg(p.parsePackageId(), name)
+	pkg := p.getPkg(p.id, "")
+	pkg.imports = append(pkg.imports, p.getPkg(p.parsePackageId(), name))
 }
 
 // int_lit = [ "+" | "-" ] { "0" ... "9" } .
diff -r 37455f5e1fae go/types/methodset.go
--- a/go/types/methodset.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/methodset.go	Wed Nov 06 20:33:23 2013 +0100
@@ -121,8 +121,8 @@
 		var next []embeddedType // embedded types found at current depth
 
 		// field and method sets at current depth, allocated lazily
-		var fset fieldSet
-		var mset methodSet
+		fset := make(fieldSet)
+		mset := make(methodSet)
 
 		for _, e := range current {
 			// The very first time only, e.typ may be nil.
@@ -229,9 +229,6 @@
 // If multiples is set, f appears multiple times
 // and is treated as a collision.
 func (s fieldSet) add(f *Var, multiples bool) fieldSet {
-	if s == nil {
-		s = make(fieldSet)
-	}
 	key := f.Id()
 	// if f is not in the set, add it
 	if !multiples {
@@ -256,9 +253,6 @@
 	if len(list) == 0 {
 		return s
 	}
-	if s == nil {
-		s = make(methodSet)
-	}
 	for i, f := range list {
 		key := f.Id()
 		// if f is not in the set, add it
diff -r 37455f5e1fae go/types/typemap/typemap.go
--- a/go/types/typemap/typemap.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/typemap/typemap.go	Wed Nov 06 20:33:23 2013 +0100
@@ -130,10 +130,7 @@
 
 // Len returns the number of map entries.
 func (m *M) Len() int {
-	if m != nil {
-		return m.length
-	}
-	return 0
+	return m.length
 }
 
 // Iterate calls function f on each entry in the map in unspecified order.
diff -r 37455f5e1fae go/types/types.go
--- a/go/types/types.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/types.go	Wed Nov 06 20:33:23 2013 +0100
@@ -177,18 +177,12 @@
 
 // NewTuple returns a new tuple for the given variables.
 func NewTuple(x ...*Var) *Tuple {
-	if len(x) > 0 {
-		return &Tuple{x}
-	}
-	return nil
+	return &Tuple{x}
 }
 
 // Len returns the number variables of tuple t.
 func (t *Tuple) Len() int {
-	if t != nil {
-		return len(t.vars)
-	}
-	return 0
+	return len(t.vars)
 }
 
 // At returns the i'th variable of tuple t.
diff -r 37455f5e1fae go/types/universe.go
--- a/go/types/universe.go	Wed Nov 06 13:31:30 2013 -0500
+++ b/go/types/universe.go	Wed Nov 06 20:33:23 2013 +0100
@@ -65,7 +65,7 @@
 
 	// Error has a nil package in its qualified name since it is in no package
 	res := NewVar(token.NoPos, nil, "", Typ[String])
-	sig := &Signature{results: NewTuple(res)}
+	sig := &Signature{results: NewTuple(res), params: NewTuple()}
 	err := NewFunc(token.NoPos, nil, "Error", sig)
 	typ := &Named{underlying: NewInterface([]*Func{err}), complete: true}
 	sig.recv = NewVar(token.NoPos, nil, "", typ)
